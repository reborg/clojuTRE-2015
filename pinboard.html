<!DOCTYPE NETSCAPE-Bookmark-file-1>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">
<TITLE>Pinboard Bookmarks</TITLE>
<H1>Bookmarks</H1>
<DL><p><DT><A HREF="https://docs.oracle.com/javase/specs/jvms/se7/html/" ADD_DATE="1438705744" PRIVATE="0" TOREAD="0" TAGS="clojure,jvm,bytecode,performances,frames">The Java® Virtual Machine Specification</A>
<DD>I know this is a little bit dense, but just by reading chapter 1 and 2 you'll get a very good idea about how the Java bytecode drives the JVM. There are many data structures holding data at the class level and a stack at the mothod level called frame. Bytecode operands operate by moving stuff from the class data structures to the stack and executing operations on them (and sometimes putting results back). Frames are per thread, so each executing instance of a method has a potentially different view of the world. After reading this, easy bytecode snippets make a lot more sense. As a Clojure user you're not expected to know bytecode at all. But as soon as you're into performances you might have.

<DT><A HREF="https://github.com/hraberg/cljs2go" ADD_DATE="1438705141" PRIVATE="0" TOREAD="0" TAGS="clojure,hack,fun,go,clojurescript,hakan">hraberg/cljs2go</A>
<DD>Another interesting project by Håkan. This is taking the ClojureScript compiler chain to compile ClojureScript into Go. See? This is one of the ways a language that is written in itslef can pay off, attracting users that are interested in Clojure instead of Java. The project is aiming high: having ClojureScript to run on the Go platform and leverage the Go tooling and libraries.

<DT><A HREF="https://swannodette.github.io/2015/07/29/clojurescript-17/" ADD_DATE="1438434141" PRIVATE="0" TOREAD="0" TAGS="clojure,clojurescript,cljs,compiler,self-hosting">ClojureScript Next</A>
<DD>This is the more or less official announcement of ClojureScript 1.7, the first ClojureScript version that can compile itself. The meaning of &quot;compiling itself&quot; is well explained in this article by David Nolen. There are a few running examples for each of the steps composing the evaluation of ClojureScript in the browser. Just in case you don't get why all the fuss, keep in mind a few side effects of a language that compiles itself: easier to write in clj/cljs than Java, easier to debug and encouraging contributions. Just to say a few.

<DT><A HREF="https://clojuredocs.org/clojure.core/not-empty" ADD_DATE="1438339367" PRIVATE="0" TOREAD="0" TAGS="clojure,stdlib,empty,seq,core,util,if-let">not-empty - clojure.core</A>
<DD>Amazing sometimes how small a function can get. And yet useful. It is the case of not-empty, that transform an empty collection into a nil. It is useful on if-let clauses, when the result you want to bind locally could be an empty collection. Empty collection will be happily bound by if-let but if you don't want that, call non-empty on it. In this respect is similar to (seq coll) which has similar resulting effects. But seq also cache values transforming coll somehow. not-empty has no other effects on coll.

<DT><A HREF="https://github.com/stuarthalloway/lancet" ADD_DATE="1437679096" PRIVATE="0" TOREAD="0" TAGS="clojure,lancet,leiningen,2009,trivia,book">stuarthalloway/lancet</A>
<DD>A bit of history here. When I've got my beta copy of Programming Clojure sometimes in 2009 there was no Leiningen. Lancet was the lead example in the book, one of the first build systems for Clojure that I know of. Before that the execution model for Clojure app was to download the jars of a project and create the executable either manually or with Ant. Then other things came like Cake and Leiningen that eventually joined effort together.

<DT><A HREF="https://skillsmatter.com/skillscasts/3538-clojure-stm-in-a-nutshell" ADD_DATE="1437669834" PRIVATE="0" TOREAD="0" TAGS="clojure,stm,transaction,dosync">Clojure STM in a nutshell | SkillsCast | 4th September 2012</A>
<DD>Here's a nice STM overview talk with the basic stuff you need to understand the the pointers to move forward. My question is: what's up with the STM? I never saw a real life example of these apparently powerful primitives used in the wild but I'm unsure why.

<DT><A HREF="http://www.infoq.com/presentations/refactoring-functional-programming" ADD_DATE="1437663191" PRIVATE="0" TOREAD="0" TAGS="clojure,haskell,erlang,refactoring,tools,smells">Refactoring Functional Programs: Past and Future</A>
<DD>Interesting presentation in an area that is less formalized with FP (compared for example to standard literature and tooling in statically typed OO). The need for refactoring in FP is the same as OO (elimination of &quot;code smells&quot;) but perhaps not as a big issue when incidental complexity is low. Still, I'm interested in the subject. This presentation shows some of the typical refactoring, especially from the point of view of the tool implementer. Examples are in Haskell and Erlang.

<DT><A HREF="http://blog.juxt.pro/posts/typed-clojure.html" ADD_DATE="1437656097" PRIVATE="0" TOREAD="0" TAGS="clojure,types,core.typed,annotations,juxt">Is Typed Clojure worth the trouble? - Working with types in Clojure</A>
<DD>Great write up by Martin Trojer on the opportunities offered by type annotations in dynamic languages like Clojure. Probably type annotations is one of those things like unit/acceptance testing: when you write them you always need to weight the value they are bringing with the maintenance effort they generate. In the case of types is mainly readability of code. For this reason gradual typing is a must, you really want to operate with annotations in a surgical way and leave the rest intact.

<DT><A HREF="http://ceramic.github.io/" ADD_DATE="1437655469" PRIVATE="0" TOREAD="0" TAGS="clojure,lisp,distribute,package,application,tool">Ceramic</A>
<DD>This is an interesting tool that could inspire something similar for Clojure. It allows you to package up web applications as native apps and distribute them. Say you have a web service of some sort but would like to offer the possiblity to install local version for people who doesn't necessarily want to keep a browser tab always open. It is built on top of Lisp, I suppose it's not going to be a complicated porting.

<DT><A HREF="http://jafingerhut.github.io/clj-ticket-status/clojure-ticket-info.html" ADD_DATE="1437655139" PRIVATE="0" TOREAD="0" TAGS="clojure,core,tickets,weight,vote">Reports on status of Clojure tickets</A>
<DD>I wasn't aware of the weighted voting system for Clojure tickets. You can vote as many as you want but the sum of all your vote will always be 1. That's reasonably fair. Let's see a few of things that are at the top at the moment. We've cache of hashes for records at the top (a perf optimisation for records). Second is around consistency of what characters can be in a symbol. And so on, have a look. Of course the wighted is system is just a tool for helping Alex and the rest of the team get a sense of what's most important, but not definitely the ultimate tool.

<DT><A HREF="http://blog.fikesfarm.com/posts/2015-07-20-ios-clojurescript-repl-available-in-app-store.html" ADD_DATE="1437474688" PRIVATE="0" TOREAD="0" TAGS="clojure,clojurescript,ios,iphone">FikesFarm Blog: iOS ClojureScript REPL Available in App Store</A>
<DD>I already covered this, but now Replete is in the app store and if you have an iPhone you can have a Clojure REPL always with you, no network required. I just installed it (after upgrading to latest OS) and it works as advertised. This is a Javascript interpreter interpreting Clojure via ClojureScript. Amazing.

<DT><A HREF="http://dev.clojure.org/jira/browse/CLJ-1517?focusedCommentId=40370&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-40370" ADD_DATE="1437423202" PRIVATE="0" TOREAD="0" TAGS="clojure,tuples,performances,rich,tellman">tuples</A>
<DD>Tuples are an experimental feature being tested at the moment. It is a rework of Zach Tellman's patch from one year ago (fact that re-heated the discussion around the Clojure contribution model on the mailing list). The idea is to replace very small vectors with specific objects, one for each size up to six. This &quot;unrolled&quot; version doesn't require iteration and significantly speeds up operations on small vectors which happens quite often, especially in json processing. Although touples could be exposed in the standard library the main goal for this are performance of the Clojure runtime. But it looks like the speed up you see by micro-benchmarking doesn't expose the problem that happens after exposing a code area to one (tuples) or the other (vectors) approach. There are many places in the standard library that will go slower with tuples when the list gets longer (and tuples mutate back into vectors). See this thread for more details.

<DT><A HREF="https://www.youtube.com/watch?v=FiflFiZ6pPI" ADD_DATE="1437137263" PRIVATE="0" TOREAD="0" TAGS="clojure,haskell,F#,quotation,LINQ,wadler,curryon,talk">Philip Wadler Everything old is new again Quoted domain specifie languages CURRY ON</A>
<DD>This is the presentation by Phil Wadler I was mentioning in another post. The summary is: use quotation to defer execution of potentially heavy operations (in his exaple, database queries) both in term of space or computation. With the same quoted syntax the end user almost sees the same thing as the original, but the compiler gets a chanche to normalise and execute the operation elsewhere (for example on a remote db). Examples are in F#, Scala and Haskell. Considering quotation is mentioned as originating from McCarthy, I'd be curious to see what can be done in a lispy language.

<DT><A HREF="http://llava.org/" ADD_DATE="1436979824" PRIVATE="0" TOREAD="0" TAGS="clojure,java,llava,history,past,lisp">llava</A>
<DD>llava is lisp syntax that drives Java. You can think of it as a precursor to Clojure. It is old stuff but nonetheless interesting to see how certain problems were solved at the time. If you scroll to the bottom you can see a brief explanation about the motivation for the project and the differences with Kawa (at the time). At the moment can't really understand if it requires a generation step followed by normal compilation. Will investigate further.

<DT><A HREF="https://www.youtube.com/watch?v=VSdnJDO-xdg" ADD_DATE="1436979189" PRIVATE="0" TOREAD="0" TAGS="clojure,video,talk,rich,javaone">Clojure Made Simple - YouTube</A>
<DD>This Rich Hickey's talk from JavaOne 2014 recently became available. It's introductory but plenty of good points to convince programmers to try Clojure. There is a good list of DSLs in Clojure for example. It also contains a &quot;Objects are like marionettes&quot; rant worth watching alone (around 33'). At the end it contains updated numbers and stats about Clojure adoption and community status.

<DT><A HREF="https://www.youtube.com/channel/UC-WICcSW1k3HsScuXxDrp0w" ADD_DATE="1436977598" PRIVATE="0" TOREAD="0" TAGS="clojure,conference,video,curryon,youtube,talks">Curry On! - YouTube</A>
<DD>CurryOn videos will appear here in the following days. There are many talks worth watching as soon as they land here. The first two already available (at the time of writing this) Cliff Click (I read the slides already) and Evan Czaplicki of Elm fame. I'm looking forward to Phil Wadler and Zach Tellmann too.

<DT><A HREF="https://clojuredocs.org/clojure.core/alias" ADD_DATE="1436973419" PRIVATE="0" TOREAD="0" TAGS="clojure,stdlib,alias,core,namespace,refer">alias - clojure.core | ClojureDocs</A>
<DD>The standard core (alias) function creates a link between a symbol and a namespace symbol name, in the current namespace. It is equivalent to the :as keyword used for :require a namespace (which is the preferred form). I didn't see it used often. One last case was with reader-conditionals where compilation is different between clj and cljs and you want to alias a namespace differently for the two languages.

<DT><A HREF="https://github.com/weavejester/duct" ADD_DATE="1436949659" PRIVATE="0" TOREAD="0" TAGS="clojure,components,duct,configuration">weavejester/duct</A>
<DD>Doing some comparisons around component libraries and concepts these days. Duct is a fine example of simplicity. What I like is that it comes with templating and generators to create a skeleton app that contains just what you need to start with. Documentation is terse and clear as well as the principles Duct is based on. One of them is about configuration that is kept under a clean interface but accessible as a namespace dependency. lein setup in a Duct project will create all the local overrides for development. Impressed by the low amount of code to quickly create a prod ready webapp.

<DT><A HREF="https://github.com/mfikes/replete" ADD_DATE="1436543324" PRIVATE="0" TOREAD="0" TAGS="clojure,clojurescript,cljs,compier,repl,ios,metacircular">mfikes/replete</A>
<DD>It had to happen at some point. Let's see if I can explain: cljs compiler can compile cljs into JS. cljs needs big dad Clojure to bootstrap into the compiler that compiles cljs into JS. But differences between cljs and Clojure nowadays are down to just a few essential parts. So a cljs program can be pointed at the cljs compiler/analyzer to compile that into JS. It is then possible to read cljs as a string and to eval it in a pure JS environment. Replete is just that REPL inside a web view on iOS. Metacircular enough.

<DT><A HREF="http://clojutre.org/2015/" ADD_DATE="1436537170" PRIVATE="0" TOREAD="0" TAGS="clojure,conference,finland,sauna,metosin,clojurtre">clojuTRE 2015</A>
<DD>More conferences coming. This one sounds pretty interesting because it's free, short 20 minutes talk and only half a day, giving prominence to the usually unofficial corridor chit chat. The awesome post conference party is also advertised, including the definitive  sauna experience for those interested (I would probably go just for the sauna alone :).

<DT><A HREF="https://github.com/tobyhede/lein-git-deps" ADD_DATE="1436536563" PRIVATE="0" TOREAD="0" TAGS="clojure,lein,plugin,git,clojars,dependency,head">tobyhede/lein-git-deps</A>
<DD>If you know what you're doing this can be an interesting plugin. With this you can use a project on Github as a dependency to your project, similar to normal dependencies with Clojars. Of course you're depending on HEAD of some project so anything can happen at any time, including suddenly breaking compilations and what not. At the same time it can be handy for projects that aren't yet on Clojars or to test a feature that only exists in the current non-released version. Handle with care.

<DT><A HREF="http://functionalkats.com/" ADD_DATE="1436515685" PRIVATE="0" TOREAD="0" TAGS="clojure,conference,fp,talks,dublin">Kats Conf 15</A>
<DD>Many mixed-functional conferences appearing lately, this is another interesting one in Dublin in September. The price is ridiculously low but the line-up in interesting with a mix of academia and industry speakers. It's a one day conference on a Saturday which will probably bring together some FP enthusiast in a pub and some sightseeing the day after (hangover permitting).

<DT><A HREF="https://github.com/cgrand/clojure/commit/f3070e5416487fadfb74fb1f740c28d336ab5c09" ADD_DATE="1436457807" PRIVATE="0" TOREAD="0" TAGS="clojure,commit,persistent,internals,performance,cgrand">Remove ArrayNode and use a second bitmap instead of kv interleaving · cgrand</A>
<DD>cgrand called this &quot;yak shaving conclusions&quot; from EuroClojure and came out with this interesting snippet. ArrayNode is one of the three INode implementations that are used for persistent data structures. This commit removes the need for ArrayNode (what was used to store references to other INode but not actual key-value pairs). That got replaced with another bitmap structure (an int) that is referenced from BitmapIndexedNode. This is on average 15% faster in most of the benchmarks he later published as well.

<DT><A HREF="https://www.youtube.com/playlist?list=PLZdCLR02grLoBx0Y5ZrpdmLxc160PIwzQ" ADD_DATE="1436456227" PRIVATE="0" TOREAD="0" TAGS="clojure,euroclojure,2015,talks,video,youtube">EuroClojure 2015 - YouTube</A>
<DD>No more excuses! The list of videos from the last EuroClojure is now out on YouTube. I can suggest the talks I've enjoyed the most: Om Next, A Deep Dive Into Clojure's Data Structures, Real Estate Clojure, Performance and Lies. Have a look at the rest, you might definitely be attracted more by some other talk.

<DT><A HREF="https://clojuredocs.org/clojure.core/ex-info" ADD_DATE="1435524372" PRIVATE="0" TOREAD="0" TAGS="clojure,exception,map,stdlib,tool">ex-info - clojure.core | ClojureDocs - Community-Powered Clojure Documentation and Examples</A>
<DD>Another little util from the standard library. ex-info creates a specialisation of RunTimeException to carry an additional map. The map can be used to store information about the exception that are not necessarily good to end up all in a string. To extract that map you use the companion (ex-data) function. Easy.

<DT><A HREF="https://github.com/Deraen/vim-cider" ADD_DATE="1435382575" PRIVATE="0" TOREAD="0" TAGS="">Deraen/vim-cider</A>
<DD>Honorable mention for a plugin bringing the refactor-nrepl features into vim. It is still at the beginning, but a few moves are already available, for example clean namespaces. The approach is very similar to a plugin I have been writing myself, with the only obstacle being vim-script (that I need to learn).

<DT><A HREF="https://github.com/escherize/random-avatar" ADD_DATE="1435056929" PRIVATE="0" TOREAD="0" TAGS="clojure,lib,avatar,generator,tool">escherize/random-avatar</A>
<DD>Just in case you're running out of ideas for your multiple identities online, this little Clojure lib can be an helpful tool. As the name says, it creates a random avatar with the promise to be even memorable. It wraps the Java library that does the same thing and at the moment is offering just the very basic.

<DT><A HREF="http://curry-on.org/index.html#program" ADD_DATE="1434554210" PRIVATE="0" TOREAD="0" TAGS="clojure,conference,talks,prague,curry">Curry On Prague! 2015</A>
<DD>What an impressive line up of talks and speakers! There are language innovators, leading company in the software industry and so on. If you have room for a couple of days in Prague this is highly recommended. I think only Zach Tellmann is there with a Clojure talk on macros, but definitely worth the rest of the program for us Clojurians anyway.

<DT><A HREF="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754" ADD_DATE="1434488540" PRIVATE="0" TOREAD="0" TAGS="clojure,frp,functional,reactive,introduction">The introduction to Reactive Programming you've been missing</A>
<DD>A simple article introducing reactive programming. Examples are not in Clojure, but I appreciated the clarity for the explanation of something that is clearly functional in nature. I know FRP (in the Kmett sense) is something much more rigorous, but what seems to be happening is that many languages are taking whatever source of data, converting it into a stream, adding a lot of combinatorial primitives and calling it FRP. Although it is not like that (FRP is in the continuum and functions can apply interpolation algorithms on the fly) evented programming is what went mainstream. What happens with lambda aware languages like Clojure is that the style of taking a sequence and process it in a pipeline is something that happens quite often. In object oriented languages the impact is much more revolutionary.

<DT><A HREF="https://gist.github.com/cgrand/4b59a09345df203fba4c" ADD_DATE="1434486938" PRIVATE="0" TOREAD="0" TAGS="clojure,macro,cgrand,transducers">transmogrify-&gt;&gt; rewrites last-threaded forms to use transducers.</A>
<DD>Interesting little snippet by @cgrand. It takes a -&gt;&gt; threading form a transforms it into the same using transducers instead. If you macroexpand it you can see that all that it takes is to comp all of the threaded operations (like map, filter and so on) and use the new artiy of (sequence) to apply the formed transducer to the original sequence. Well not that easy. It contains a couple of smart stuff. A multimethod is dispatching on the type of operation and taking care of a few corner cases (like reduce, seq, into). In case of a reduce is using some trick with (volatile!) to reduce with mutation. Or so I understand.

<DT><A HREF="http://martintrojer.github.io/frinj-demo/" ADD_DATE="1434486883" PRIVATE="0" TOREAD="0" TAGS="clojure,lib,units,conversion,fun">Frinj ClojureScript demo</A>
<DD>Can I suggest all libraries to have a tutorial like this one? Frinji is the port to Clojure of the Frink library for unit conversion and calculations. Frinji also ported the sample calculations from Frink which is the document you’re looking at. This project gives you yet another idea on how Clojure can be used as a DSL language. Don’t miss the “advanced farting” section.

<DT><A HREF="http://clojurecl.uncomplicate.org/" ADD_DATE="1434486842" PRIVATE="0" TOREAD="0" TAGS="clojure,gpu,computation,parallel,OpenCL,library">ClojureCL - OpenCL 2.0 (GPGPU).</A>
<DD>ClojureCL is a Clojure library to interact with OpenCL, the open standard for General-purpose computing on graphics processing units (GPGPU). With ClojureCL you can create applications that run on the GPU, especially those requiring a high number of potentially parallel calculations. It works on top of JOCL, a Java interface to the native openCL APIs.

<DT><A HREF="https://clojuredocs.org/clojure.core/vary-meta" ADD_DATE="1434486791" PRIVATE="0" TOREAD="0" TAGS="clojure,metadata,meta,alter,stdlib">vary-meta</A>
<DD>Vary-meta is a simple function in the standard library. It is useful shortcut for all those operations where a var needs to be sent around while altering its metadata. It just avoids the (with-meta x (meta x)) pattern. There is a side effecting version called alter-meta! that does the same atomically, that is it will compare and swap metadata on the ref until it succeed (in case of competing threads).

<DT><A HREF="https://github.com/lynaghk/cljx#this-plugin-is-deprecated" ADD_DATE="1434446423" PRIVATE="0" TOREAD="0" TAGS="clojure,conditionals,clojurescript,cljx,annotations,generation">lynaghk/cljx</A>
<DD>Great news indeed! The cljx plugin usage has been deprecated in favour of the newly added reader conditionals in the upcoming Clojure 1.7 release. I've used the plugin with great satisfaction up to now, although the process of files generation was never completely smooth or easy. One of the main problem I had was to have vim plugins to work nicely with ClojureScript generated files, something that Cider seems to solve much better. Apart from editors, generating Clojure and ClojureScript files from a common annotated template is adding a lot of building and testing complexity, making the project.clj  file a total mess. Now that the feature will be added directly into the language all of that will be handled transparently. Yay for reader conditionals!

<DT><A HREF="http://www.lambdacat.com/" ADD_DATE="1434401942" PRIVATE="0" TOREAD="0" TAGS="clojure,elm,fp,functional,screencast">LambdaCat</A>
<DD>A fresh new screencast series on functional programming by @doppioslash. We are at the first episode on Elm, which clocks quite fast at 2:30 total. I like the idea of quick pills instead of more extensive coverage of a topic (there are quite a bunch of normal size screencasts already). Audio and video quality are pretty good. Elm is quite interesting language: it is pretty much Haskell that compiles down to ClojureScript and heavily based on reactive programming. The debugger that can go back and forth in time (even with change) is an direct effect of that. Good stuff, keep 'em coming!

<DT><A HREF="http://functionaltalks.org/" ADD_DATE="1434367146" PRIVATE="0" TOREAD="0" TAGS="clojure,talks,videos,presentations,haskell,monads">Talks – FunctionalTalks.org</A>
<DD>Just learned about this nice list of functional talks. The list is slightly more focused on typed languages but I noticed a couple of Clojure titles too. Quite a bit of Monadic stuff, Scala and some JavaScript completes the picture.

<DT><A HREF="https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/LazySeq.java" ADD_DATE="1433866372" PRIVATE="0" TOREAD="0" TAGS="clojure,lazy,thunk,seq,ephemeral">clojure/LazySeq.java at master · clojure/clojure</A>
<DD>LazySeq is the class at the base of many lazy behaviours in Clojure. It implements a suspended evaluation also known as &quot;thunk&quot;. Tons of instances of this class can be created on processing lazy sequences and thrown away right after evaluation of the item in the sequence they wrap. It is a known fact that the JVM can handle a huge churn of quick throw-away ephemeral objects without too much trouble. The standard library macro &quot;lazy-seq&quot; is used to implement infinite sequential behaviour (like iterate, repeatedly and so on) and it just creates an instance of LazySeq.

<DT><A HREF="https://bugs.openjdk.java.net/browse/JDK-8043364" ADD_DATE="1433804242" PRIVATE="0" TOREAD="0" TAGS="clojure,java,repl,jdk9,new">[#JDK-8043364] JEP 222: jshell: The Java Shell (Read-Eval-Print Loop)</A>
<DD>Just noticing that a REPL under discussion for the future JDK 9 release. This doesn't have a specific impact on other languages running on the JVM that implemented their own. As far as I can see from the notes on the ticket, this REPL will be limited to removing all the boilerplate around simple Java statements, taking care of running Java code in an implicit context.

<DT><A HREF="https://github.com/clojure/clojure/blob/clojure-1.6.0/src/clj/clojure/core.clj#L2781" ADD_DATE="1433797931" PRIVATE="0" TOREAD="0" TAGS="clojure,stdlib,tools,standard,zipmap">clojure/core.clj at clojure-1.6.0 · clojure/clojure</A>
<DD>Zipmap is another of those little utils in the standard library that save quite a bit of thinking. The implementation linked here is also quite simple and readable. The function simply joins together two sequences in a map, considering one sequence the source for keys and the other the source for values. Since it uses recursion, the map is assoc from the last element backward so in the average case the keys will be in reversed order compared to the input sequence. Talking about average since maps are not ordered so this is not necessarily always true.

<DT><A HREF="http://martintrojer.github.io/clojure/2015/06/03/datomic-dos-and-donts/" ADD_DATE="1433350410" PRIVATE="0" TOREAD="0" TAGS="clojure,datomic,license,data">Datomic Do's and Don'ts</A>
<DD>Nice and clean list of do-donts from a Datomic experience in the field. Datomic is controversial, it departs technologically and it creates some troubles in term of licensing. Using it for the right scenario already poses a problem. At the same time, it might be the right choice for everything time related or Clojure based. I'm still waiting the project to use it but I had trouble in the past selling it to the business. I'm not sure if all of the above already characterises it as a failure (for wider adoption). The future will tell.

<DT><A HREF="https://github.com/thi-ng/geom" ADD_DATE="1433282722" PRIVATE="0" TOREAD="0" TAGS="clojure,graphic,geometry,2d,literate,org-mode">thi-ng/geom</A>
<DD>Complete 2d/3d geometry toolkit for Clojure. Under the same thi-ng group of projects on github there are many other interesting library, often graphic oriented, for the serious Clojure drawing enthusiasts. What is interesting about this and other projects is also the fact that is written in literate programming style (emacs/org-mode), where code and wiki pages are the same thing and the tangling operation generates the sources. Interesting stuff, since github understands the format and you can browse sources like reading a book.

<DT><A HREF="https://clojurians.net" ADD_DATE="1433252161" PRIVATE="0" TOREAD="0" TAGS="clojure,community,irc,slack,chat,channels">clojurians on Slack</A>
<DD>It appears IRC is losing its charm these days and many Clojurians (800+) already migrated to the new Slack rooms. This link points to a form you can use to get an invitation (the only way to get into the Slack channels). I'm not sure if there is a poor guy on the other side sending all of them. In that case thanks! Anyway, I happened to already being using Slack for internal communications at work, so it's a good fit for me. Compared to IRC you get a better experience, first of all history and searching (without having to setup a specific client/service for that to happen).

<DT><A HREF="https://skillsmatter.com/conferences/7036-functional-programming-exchange-2015" ADD_DATE="1432739823" PRIVATE="0" TOREAD="0" TAGS="clojure,conference,fpx,me,speaking,talks,elm,ocaml">Functional Programming eXchange 2015 | 11th Jun 2015 | London</A>
<DD>More shameless self-promotion, since I'll be taking my FP basics talk to the Functional Programming eXchange the next June 11th in London. The conference speakers lineup contains talks about Elm, OCaml, Clojure, F# and more general topics. Single day, single track event, no fluff just stuff style. Nice beers and party at the end for more informal discussions to follow. Please come if you're around the price is reasonable.

<DT><A HREF="http://www.infoq.com/presentations/Value-Identity-State-Rich-Hickey" ADD_DATE="1432739482" PRIVATE="0" TOREAD="0" TAGS="clojure,video,presentation,qcon,infoq,rich,refs,agents">Persistent Data Structures and Managed References</A>
<DD>I don't usually miss Rich's talks but this one somehow slipped under the radar until now. Rich goes through FP concepts like pure functions, state and identity and it's stil all valid today (the talk it's from 2009). It also goes into good details about persistent data structures implementation and managed references. I was wondering why refs didn't get that much attention. I never encountered them in the wild (e.g. projects by others) nor I had to use them myself. It's a pity because it's a sophisticated piece of software, but maybe Clojure wasn't selected very often for transactional problems. Not sure.

<DT><A HREF="http://stackoverflow.com/questions/925365/what-is-a-thunk-as-used-in-scheme-or-in-general" ADD_DATE="1432734729" PRIVATE="0" TOREAD="0" TAGS="clojure,thunk,evaluation,laziness,parameters,haskell">programming languages - What is a 'thunk', as used in Scheme or in general? - Stack Overflow</A>
<DD>Probably the most straightforward of all the definition of &quot;thunk&quot; is the one available on StackOverflow. In a Lisp derived language a thunk can be obtained by wrapping an expression in a function of no argument. The thunk can be then sent around and only evaluated when is actually needed. Of course you need to know it is a thunk so you can unwrap it first. Languages like Haskell uses a similar technique in the compiler to store unevaluated parameters that are later pruned (removing unnecessary evaluations) and memorised. Thunk means it doesn't need any more &quot;thought&quot; for evaluation, joking around an english spelling mistake.

<DT><A HREF="http://talks.golang.org/2015/gogo.slide#1" ADD_DATE="1432731550" PRIVATE="0" TOREAD="0" TAGS="clojure,go,presentation,slides,pike,compiler">Go in Go</A>
<DD>Will Clojure 2.0 be the version of Clojure where the language is going to be completely written in Clojure itself? Maybe. For the moment enjoy in these slides by Rob Pike describing how Go was written in Go. The list of reasons why this was done could be exactly the same for Clojure. Also the process could be similar: translation from C was heavily automated with custom made tools to read C and output a very bad Go. Another tool was then responsible to make the first Go much better. More idiomatic transformation are still needed. Also the testing process could be exactly the same: a byte code comparison of the given output to tell if the translation is working as the original.

<DT><A HREF="https://github.com/circleci/frontend" ADD_DATE="1432720658" PRIVATE="0" TOREAD="0" TAGS="clojure,om,clojurescript,ci,circle,project">circleci/frontend</A>
<DD>CircleCI is a continuous integration tool. It's well document and quite used thanks to the first class support for GitHub projects they gave since the beginning. More interestingly for the Weekly is that the front-end (the nice looking UI) is written mainly with Om and ClojureScript and is open source. The project is big, well maintained and tested, so it's a good example project to keep an eye on for anything Om-related.

<DT><A HREF="https://clojuredocs.org/clojure.core/ns-unmap" ADD_DATE="1432301826" PRIVATE="0" TOREAD="0" TAGS="clojure,core,test,unmap,symbol,var,def,deftest">ns-unmap - clojure.core | ClojureDocs - Community-Powered Clojure Documentation and Examples</A>
<DD>Dead easy way to remove a symbol definition from a namespace. The most likely use case is checking things out at the REPL, it is unlikely you'll ever see this in production code. Commenting out a form from a namespace and reloading the namespace is not enough to remove it's definition and that &quot;def&quot; is still there. If we are talking about a deftest for example and you don't want to run the test, commenting out is not enough, you actually need to unmap it from the namespace.

<DT><A HREF="http://www.jbcnconf.com/infoSpeaker.html?ref=rborgatti" ADD_DATE="1432237189" PRIVATE="0" TOREAD="0" TAGS="clojure,talk,me,barcelona,conference,java">Speaker info - JBCNConf</A>
<DD>Just enough self promotion to say that yours truly is going to speak about the basics of functional programming at the Barcelona Java Conference at the end of June. The talk will have a strong lispy background with example in Clojure and of course, Java 8. If you happen to be there for Euroclojure (the two conferences overlap one day) it might be worth checking a few of the talks at JBCConf for the Saturday.

<DT><A HREF="http://weblog.raganwald.com/2006/11/significance-of-meta-circular_22.html" ADD_DATE="1432022134" PRIVATE="0" TOREAD="0" TAGS="clojure,lisp,meta,interpreter,eval,languages,ast">The significance of the meta-circular interpreter</A>
<DD>Oh that's a good explanation for meta-circular interpreters and just in the first few lines. Grokking the impact of that on languages is another discussion. But this (old) article by Reginald Braithwaite goes on explaining what impacts such a feature (popularised by Lisp) has on language implementations. Most notably, it tends to create languages that are easier to change, including the deepest core primitives. It also impacts on meta-programming and in general in performances dealing with nested data structures, such as trees. Of course, because languages written in themselves need to analyse and compile efficiently.

<DT><A HREF="https://github.com/matthiasn/talk-transcripts/blob/master/Hickey_Rich/SimpleMadeEasy.md" ADD_DATE="1431678279" PRIVATE="0" TOREAD="0" TAGS="clojure,talk,rich,simple,easy,complection,complected">talk-transcripts/SimpleMadeEasy.md at master · matthiasn/talk-transcripts</A>
<DD>One of those talk transcripts to keep handy in your bookmark list. This talk by Rich from StrangeLoop 2011 made clear the distinction between what is subjectively &quot;easy&quot; (something that sometimes requires hard work to become familiar) and what is objectively &quot;simple&quot;. It also popularized the word &quot;complection&quot; that nowadays is in widespread use. It all boils down to the content of your toolbox. If you fill it with classes, type-only polymorphism, instance variables and so on, you get a complected toolbox that might feel familiar but it will hit you in the back when the application complexity increases. A must-read (and must-watch) presentation.

<DT><A HREF="http://danmidwood.com/content/2014/11/21/animated-paredit.html" ADD_DATE="1431505673" PRIVATE="0" TOREAD="0" TAGS="clojure,paredit,structural,vim,editor,sexp">The Animated Guide to Paredit</A>
<DD>I'm sharpening my structural editing skills these days and I spend some more time observing my typing to make it more productive. I'm using vim-sexp under VIM and what I'm lacking most of all is the example of how others make good use of structural editing. There are a couple of things I'm using constantly already but I suppose there is more. Paredit literature is perfect in this case, since the logic if the structural change is the same (I just need to change keystrokes). This animated guide is both cool and rich in good examples. I'm searching more of those to use in everyday life apart from the usual (slurping, barfing, matching parens and so on).

<DT><A HREF="http://www.eecs.northwestern.edu/~robby/logos/" ADD_DATE="1431448196" PRIVATE="0" TOREAD="0" TAGS="clojure,racket,plt,scheme,logo">The Many Faces of DrRacket</A>
<DD>I think I've found the best lambda logo so far, the one from the venerable PLT Scheme (aka Racket) around 2003. It was probably designed by Matthew Flatt in person judging from the initials (and someone else). Anyway, the skull makes the lambda really hard to ignore. Lambda rules!

<DT><A HREF="https://github.com/nathanmarz/specter" ADD_DATE="1431374609" PRIVATE="0" TOREAD="0" TAGS="clojure,lenses,data.,structures,walk">nathanmarz/specter</A>
<DD>An interesting little lib from Nathan Marz of Storm fame. Specter is a small &quot;walking language&quot;, a Clojure DSL to query or update data structures. To the top of something like get-in or update-in it adds many feature like ways to filter, chaining multiple operations or apply your own selectors. The source code is so terse and readable that you are struggling to see how all of that can be implemented. It even &quot;precompiles&quot; with speed gain from 3x to 10x.

<DT><A HREF="http://planet.lisp.org/" ADD_DATE="1431076234" PRIVATE="0" TOREAD="0" TAGS="clojure,lisp,history,aggregators,read,rss,feed">Planet Lisp</A>
<DD>Ah the venerable Lisp. There is still a tons of work to do to get close to what was already achieved with Lisp over the course of so many decades. So as a clojurian you should try to keep an eye on what is happening there (at much slower pace nowadays) and have a look at the past. That is, open different Lisp implementations and play with them, use libraries and attend conferences. Planet Lisp collects those resources for you.

<DT><A HREF="http://oss.readytalk.com/avian/#-bout" ADD_DATE="1430997757" PRIVATE="0" TOREAD="0" TAGS="clojure,jdk,avian,alternative,build,lightweight">Avian</A>
<DD>Avian is a Java virtual machine alternative to the standard JVM. It is built to be as minimal as possible and to run well on small devices or constrained environment. There are also attempts to build Clojure on top of it, although I couldn't find evidence that it worked. An interesting project nonetheless.

<DT><A HREF="https://robots.thoughtbot.com/writing-clojure-in-vim" ADD_DATE="1430987460" PRIVATE="0" TOREAD="0" TAGS="clojure,vim,editor,plugin,tools,paredit,sexp">Writing Clojure in Vim</A>
<DD>For you lonely Clojure-Vim developer out there, here's a short selection of the most relevant plugins and tricks you need to use these days. It basically describes my current setup which I'm very proud of. I think the main take-away here is to leave paredit to use the more vim-aware sexp with time pope's mapping.

<DT><A HREF="https://github.com/weavejester/brutha" ADD_DATE="1430987249" PRIVATE="0" TOREAD="0" TAGS="clojure,clojurescript,om,react,reagent">weavejester/brutha</A>
<DD>Another framework in the React-inspired ecosystem. Brutha takes the minimalist approach, leaving out cursors and atoms and leaving to you the responsibility to handle state. In general is good to keep an eye to anything coming from James Reeves ;)

<DT><A HREF="https://github.com/LuxLang/lux" ADD_DATE="1430986973" PRIVATE="0" TOREAD="0" TAGS="clojure,ml,haskell,types,macros,language,lux">LuxLang/lux</A>
<DD>Very experimental stuff, but there some interesting bits in there. Lux is a Clojure inspired (syntax) Haskell inspired (types) ML inspired (modules) language. I quickly glanced over the README and I saw a couple of interesting things: macros carry the entire compiler state with them (monad style) and custom types can be used for destructuring (not just maps/lists). There is much more but it looks a promising idea. It is written in Clojure with its own ASM-based bytecode generation.

<DT><A HREF="https://clojuredocs.org/clojure.core/proxy" ADD_DATE="1430927771" PRIVATE="0" TOREAD="0" TAGS="clojure,proxy,java,asm,class,generation">proxy - clojure.core | ClojureDocs</A>
<DD>Proxy is a quite powerful function. It uses the ASM api to generate a Java class and loads it into the current classloader ready for use. It's not very different from the Clojure compiler internals, but it offers similar functionality in a very compact single function. The generated class is anonymous, so you can only use it in the context of the proxy call (unlike gen-class). When to use? It is very valuable to produce Java classes like callbacks in the context of Java interop. For instance, it makes Swing code quite compact.

<DT><A HREF="https://gist.github.com/littleloops/a4377c93c2ef62b987cf" ADD_DATE="1430818979" PRIVATE="0" TOREAD="0" TAGS="clojure,sexp,pope,plugin,vim,editor,development">vim sexp mappings for normal people cheat sheet</A>
<DD>Must have if you develop Clojure with sexp and Pope's re-interpretation of shortcuts. I'm using it instead of paredit (too emacsy for my tastes) and flying pretty fast. Worth a screencast at some point, stay tuned. s-expression aware tooling for developing Lisp is quite important, since most operations become faster (on top of the already incredibly fast Vim support for &quot;pairs&quot; of things). Give it a try on a lazy Friday afternoon to see what I mean.

<DT><A HREF="http://euroclojure.org/speakers" ADD_DATE="1430816267" PRIVATE="0" TOREAD="0" TAGS="clojure,euroclojure,speakers,talks,barcelona,conference">EuroClojure 2015 - Speakers</A>
<DD>EuroClojure presenters list is out and is full of interesting talks! I'm going to Barcelona, so give me a buzz if you're there for a chat or drink. Personally I'm looking forward to a few talks, like Clojure on Android (more interested in Skummet than Android), c-tries in Clojure, Om, all the experience reports and of course all the corridors chatting. Also worth mentioning that I'm giving a talk on Saturday at the Java Barcelona Conf, an event that is going on at the same time of EuroClojure. I'll post a dedicated link to that.

<DT><A HREF="https://github.com/Frege/frege" ADD_DATE="1430346752" PRIVATE="0" TOREAD="0" TAGS="clojure,jvm,haskell,frege,functional">Frege/frege</A>
<DD>Frege is an Haskell-like language that compiles down to byte code to run on top of the JVM (sounds familiar?). It’s not just Haskell-inspired, it tries to be as similar to Haskell as possible. A list of the restrictions is provided, but what you can already do is quite long and includes typeclasses with parametric polymorphism, type inference, lazy evaluation, pattern matching, all category theory abstractions like functors, monads, monoids plus much more. The fact that the compiler itself, the standard library and the REPL is written in Frege itself already gives an idea that the project is mature.

<DT><A HREF="https://groups.google.com/forum/#!topic/clojure-dev/Dl3Stw5iRVA" ADD_DATE="1430346652" PRIVATE="0" TOREAD="0" TAGS="">Clojure stream socket repl - Google Groups</A>
<DD>Interesting discussion on the Clojure-Dev mailing list. The proposed feature is an addition to Clojure so it can handle multiple concurrent REPL sessions, not all necessarily directed at human end users. Some of the sessions could be used by tools (like refactoring tools) or any other thing that makes sense from the application perspective. Rich chimes in a few times in the thread also showing screenshots from Allegro and LispWorks. When you see those you can see there still *a lot* of work to do (including the multiple REPL sessions that you see there). Good to be inspired from the past.

<DT><A HREF="https://modularity.org/index.html" ADD_DATE="1430346624" PRIVATE="0" TOREAD="0" TAGS="clojure,compoenents,reusable,spring">modularity.org</A>
<DD>modularity.org is the umbrella website that points at the projects forming the Juxt vision for Clojure componentization. I appreciate the effort (if you embrace the style, many components can be used out of the box). At the same time I'd avoid components until the last possible time (startup orchestration becoming too big for example). My impression is that components in Clojure are very similar to Spring in Java, including the “vendor lock-in” effect and the architecture driven approach. My advice is to avoid them when possible and/or grow your own library instead of using a 3rd party component repo. It all sounds to me yet another iteration of the &quot;reusable components&quot; theme that started in the '90.

<DT><A HREF="https://github.com/yogthos/markdown-clj" ADD_DATE="1430346281" PRIVATE="0" TOREAD="0" TAGS="clojure,tool,lib,markdown">yogthos/markdown-clj</A>
<DD>Just in case you need one, here’s an useful markdown parser (and html generator). In its simplest form it will it is just a simple function invocation where the markdown string is passed in. It supports some customisation and works great with ClojureScript.

<DT><A HREF="http://isaaccambron.com/blog/2014/12/13/transducer-composition.html" ADD_DATE="1430346250" PRIVATE="0" TOREAD="0" TAGS="clojure,transducers,comp,composition,order">Transducer Composition</A>
<DD>An exhaustive explanation about transducers composition, including why they are applied in the left-right way they are when composed, instead of normal right-left behaviour. Nothing completely surprising though, since transducers are just a recipe for computation that will be applied on a sequence at some later point. Also useful to remember that during their compositions transducers are not creating intermediary sequences (lazy or not) unlike what would happen in a normal partial application of composed functions.

<DT><A HREF="https://clojure.github.io/clojure/clojure.reflect-api.html" ADD_DATE="1430343583" PRIVATE="0" TOREAD="0" TAGS="clojure,core,stdlib,reflection,class,type">clojure.reflect - Clojure v1.6 API documentation</A>
<DD>By using (use 'clojure.reflect) you get essentially a wrapper around the Java reflection API. The main entry point is (type-reflect) that can return ancestors, modifiers and members of a class. If you for example (type-reflect java.lang.String) you'll see a wall of text at the REPL representing the recursive introspection of all the methods and parameters founds in a Java string class. Use when you need Java reflection but don't want to deal with the messy syntax of the Java api.

<DT><A HREF="http://dev.clojure.org/display/community/Clojure+Community+Organisation" ADD_DATE="1430259974" PRIVATE="0" TOREAD="0" TAGS="clojure,community,organisation,free,cognitect">Clojure Community Organisation - Clojure Community</A>
<DD>Interestingly, somebody is suggesting to support Clojure in an independent (such as in not necessarily for profit) way. That means find a way to support fundamental services apart from the language (such as Clojars) and find a way to accept donations to fund other projects or students. Making this organisation independent from Cognitect is probably the most interesting aspect assuming that the larger the community, the more transparent and independent Clojure should be.

<DT><A HREF="https://www.youtube.com/watch?v=Agu6jipKfYw" ADD_DATE="1430255865" PRIVATE="0" TOREAD="0" TAGS="clojure,frp,talk,video,reactive,arrow,elm">&quot;Controlling Time and Space: understanding the many formulations of FRP&quot; by Evan Czaplicki - YouTube</A>
<DD>A clear explanation of FRP styles by the lead developer of Elm. First of all, FRP is an overloaded term, so overloaded that there is the need to specify the Elm flavour as &quot;first order&quot;. First order FRP gives for granted some &quot;core&quot; principles that you can trade-off to experiment different FRP styles. Some of them are: asynchronous FRP (the reactFX extensions), arrowed FRP or high-order FRP. Some powerful concepts down there: a reduce in FRP worlds is not a single result, but the change over time of the steps of the reducing function. Kind of peeking inside the reduce while it is operating. Another interesting one is the concept of signals of signals, a variable in the continuum that determines which signals is active at any given point.

<DT><A HREF="https://www.youtube.com/watch?v=SrKj4hYic5A" ADD_DATE="1430251405" PRIVATE="0" TOREAD="0" TAGS="clojure,scheme,black,metalevel,repl,context,eval">&quot;Programming Should Eat Itself&quot; by Nada Amin - YouTube</A>
<DD>An interesting talk from StrangeLoop last year. What is intriguing is enabling multiple and totally independent evaluation contexts in a language. When working on a Clojure REPL for example, the unit of evaluation is the namespace, where core functions are injected and user functions from the namespace itself are compiled. Overriding a function in that namespace works, but to what it was evaluated before is lost. It is a &quot;mutating in place&quot; operation. In languages like Black (built on top of Scheme) you can have infinite evaluation spaces, each one containing an entire copy of the language that can change completely if you want. This talk is nicely executed mostly at the REPL showing how to evaluate in and out &quot;metalevels&quot; including instrumenting the basic &quot;eval&quot;.

<DT><A HREF="https://groups.google.com/forum/?nomobile=true#!search/Clojure/clojure/4uDxeOS8pwY/UHiYp7p1a3YJ" ADD_DATE="1430235992" PRIVATE="0" TOREAD="0" TAGS="clojure,history,funny,rich,ml">meaning and pronunciation of Clojure - Google Groups</A>
<DD>The final and authoritative answer about why Clojure has the name it has and how it should be pronounced. In just a few words, it is a googlable name where the C stands for C# (!), the J is Java and L is Lisp. As of how to pronounce it, the &quot;j/s&quot; sound is the same as &quot;azure&quot; or &quot;pleasure&quot;.

<DT><A HREF="https://github.com/juxt/juxt-accounting" ADD_DATE="1429709676" PRIVATE="0" TOREAD="0" TAGS="clojure,juxt,accounting,datomic">juxt/juxt-accounting</A>
<DD>Worth a mention. My friends at Juxt are doing a great work in abusing Clojure in all possible aspects of a programmer life (in a good sense). In this case, an accounting application written in Clojure and based on Datomic. With JUXT accounting, thanks to Datomic, you can do those kind of things like going back in time for a dispute to see how the accounts looked like at that point in time.

<DT><A HREF="https://groups.google.com/forum/#!topic/clojure/rzvMp44ZN0I" ADD_DATE="1429609474" PRIVATE="0" TOREAD="0" TAGS="clojure,gen-class,java,method,function,generation,convention">&quot;-function&quot; special? - Google Groups</A>
<DD>-function is conventional but it has special meaning in the two cases described in this thread. Apart from ClojureScript, the special meaning in Clojure has to do with gen-class. If you use gen-class in a namespace and the namespace contains a function starting with a dash, the Clojure compiler will generate the method name without a dash in the generated Java class, calling into the corresponding dash-prefix function name on the Clojure side.

<DT><A HREF="https://github.com/fogus/trammel" ADD_DATE="1429266139" PRIVATE="0" TOREAD="0" TAGS="clojure,contracts,testing,types,checking,library">fogus/trammel</A>
<DD>Trammel is one of the Clojure library out there that enables contract based programming a-la Eiffel. It takes :pre/:post defn keywords to the next level with a more stylish DSL to access similar functionalities. It also contains specific &quot;constrainer&quot; for the most common cases, such as record-structure checking or type-checking.  The last one in the focumentation, the reference-invariant, will bombs on attempts to update a reference with a value that is not allowed in the precondition.

<DT><A HREF="https://clojuredocs.org/clojure.test/with-test" ADD_DATE="1429265772" PRIVATE="0" TOREAD="0" TAGS="clojure,core,stdlib,test,assert">with-test - clojure.test | ClojureDocs</A>
<DD>with-test enables (simple) unit test embedding directly into function definition. It allows similar clojure.core/test functionality with clojure.test more powerful checkers. After all this is a macro that outputs the body of the function adding to the metadata the :test keyword, so that (test myfunc) will trigger the tests. Worth remembering for quick and dirty &quot;assertions&quot; that can go along with the function definition.

<DT><A HREF="https://github.com/noprompt/garden" ADD_DATE="1429205339" PRIVATE="0" TOREAD="0" TAGS="clojure,clojurescript,css,generation,dsl">noprompt/garden</A>
<DD>Of all the possible alternatives out there to write CSS without actually having to write CSS, garden is the one that starts from pure Clojure (or Clojurescript). Conceptually similar to hiccup nested vectors, it comes with the lein plugin to automatically watch for changes and re-generate CSS. It offers quite a powerful DSL on top of which you can build more abstraction using Clojure functions.

<DT><A HREF="https://github.com/enaqx/awesome-react" ADD_DATE="1429204961" PRIVATE="0" TOREAD="0" TAGS="clojure,clojurescript,om,react">enaqx/awesome-react</A>
<DD>Facebook React library is attracting more and more attention and its ecosystem is exploding. Look at this list of React related resources to get an idea about the amount of material available on the web. This github project markdown collects everything for a lot of different languages, including tutorials, videos, projects and whatnot. Clojurescript got its (small-ish) section in the middle.

<DT><A HREF="https://github.com/r0man/sablono" ADD_DATE="1429204634" PRIVATE="0" TOREAD="0" TAGS="clojure,clojurescript,om,react,hiccup,html,templating,generation">r0man/sablono</A>
<DD>If you are used to Hiccup for html generation and would like to use it with Clojurescript React wrappers, you can look into Sablono. No surprises here, I copy pasted a few hiccups without problems. There are sensible restrictions and conventions, like dashing replacing camel casing. No need to mention it works with Om just fine.

<DT><A HREF="https://github.com/matthiasn/Clojure-Resources" ADD_DATE="1429203991" PRIVATE="0" TOREAD="0" TAGS="clojure,learning,links,list,opinionated,resources,starting">matthiasn/Clojure-Resources</A>
<DD>A curated list of important Clojure links. It is split into categories, including a little bit of everything, from irc channels to podcasts, presentations to libraries. It's definitely opinionated, however it could be a decent starting point for new learners to start with. Bookmarking for potential use.

<DT><A HREF="https://github.com/martinklepsch/tenzing" ADD_DATE="1429111614" PRIVATE="0" TOREAD="0" TAGS="clojure,web,boot,clojurescript,om,tool,generate,template">martinklepsch/tenzing</A>
<DD>Got to know what the cool kids are using these days to do sane clojurescript development. It seems that boot has better support than leiningen for multiple processes forming an application (so you can have refreshing of clojurescript, repl and app all working under the same command line) so tenzing template is based on that. After lein new tenzing &lt;app&gt; and cd into dir, you already have a running clojurescript app with boot dev. There are option supporting bootstrap, om, less, garden and so on, creating all the necessary plumbing for a new shiny webapp. Impressed.

<DT><A HREF="http://rundis.github.io/blog/2015/clojure_light_love.html" ADD_DATE="1429008360" PRIVATE="0" TOREAD="0" TAGS="clojure,refactoring,lighttable,vim,tools,ide">A pinch of Clojure love to Light Table</A>
<DD>Quick link to announce the release of the LightTable refactoring plugin, using all the goodies of refactoring in Clojure these days: refactor-nrepl and cider-nrepl. Vim is getting behind, argh! But now worries, something is cooking with Vim clj refactoring too. We'll see at EuroClojure.

<DT><A HREF="http://cloxp.github.io/cloxp-intro.html" ADD_DATE="1428912245" PRIVATE="0" TOREAD="0" TAGS="clojure,conference,smalltalk,squeak,ideas">cloxp</A>
<DD>Here’s an interesting project. Be sure to attend the Clojure/West incoming session about it. I’ve used Squeak a few times and I’m familiar with the Smalltalk concept of a “live system”, so I was pleased to see something similar where the running code is Clojure. It gets far enough to sound interesting: code evaluation, completion, namespace browsing, LightTable-like instarepl. The idea is that between the several open scratch pads containing Clojure code you build an interacting system. It also comes with a “distraction free” format in which a white, full-screen desktop decorated with Clojure code is all you see.

<DT><A HREF="http://www.infoq.com/presentations/clojure-stories" ADD_DATE="1428911310" PRIVATE="0" TOREAD="0" TAGS="clojure,cgrand,enlive,okasaki,keynote,talk,slides">Down the Clojure Rabbit Hole</A>
<DD>I attended CGrand's keynote while at FP Days 2014. I was also lucky enough to spend most of the intra-talk time talking with him about a lot of subjects and I'm still digesting that big queue of resources. The talk is dense, especially if you read &quot;in between slides&quot;. Some non-exhaustive sample of influential concepts in functional programming: pragmatic use of parenthesis, persistent data structures as numerical systems (see Okasaki), finger trees, validators to enforce invariants, ordering considered harmful. It goes then more into HTML parsing and new ideas in that direction with Enliven. Now time to watch it, enjoy.

<DT><A HREF="http://www.pitheringabout.com/?p=1069" ADD_DATE="1428412380" PRIVATE="0" TOREAD="0" TAGS="clojure,pither,project,large,portal,story">Clojure at a Real Estate Portal | Pithering About</A>
<DD>Nicely written. I enjoy the same positive pragmatic feeling using Clojure every day. I'm not sure if there are contexts in which this initial ease is NOT going to payoff (maybe it depends on my limited experience observing large dynamically typed codebases evolving over time). Having started some Haskell lately, I have the impression that also statically typed FP (not just OO) can suffer from the same mindset to try to figure out correct types up-front. Of course sane discipline and smart developers can overcome this or any other trouble in any language, but still, it brought back a bit of my Java years. Congrats to the team for the great delivery, another example to illustrate real-life Clojure projects aren't really hard to find anymore.

<DT><A HREF="http://stackoverflow.com/questions/23255798/clojure-style-defn-vs-letfn/23256403#23256403" ADD_DATE="1428351174" PRIVATE="0" TOREAD="0" TAGS="clojure,stdlib,style,defn,letfn,mutual,recursion,declare">Clojure style: defn- vs. letfn - Stack Overflow</A>
<DD>This isn't just about style. Letfn allows ahead-of-definition use of functions, similar to (declare). Or as the answer points out, mutual recursion. The same wouldn't be possible with plain let of a list of functions. Then in terms of style, you'd rather use letfn when the function being defined is intended for internal use of another function only. One case is for example iterative-process recursion requiring &quot;results&quot; to be carried over the next computation (and when loop-recur can't be used because it's not in tail position).

<DT><A HREF="https://github.com/razum2um/clj-debugger" ADD_DATE="1428269567" PRIVATE="0" TOREAD="0" TAGS="clojure,debugger,interactive,tools">razum2um/clj-debugger</A>
<DD>A basic interactive debugger. It remembers me of something similar in ruby-land called ruby-debugger. Here's a scenario: your Clojure app is having trouble you enter the REPL and redefine a couple of fns with printlns but they throw a lot of stuff at the screen that is uneasy to follow. You iterate this cycle several times tweaking the print until you can see the problem. With something like clj-debugger the process becomes interactive: you stop at the line and inspect locals, stub results and move forward.

<DT><A HREF="http://conj.io/store/v1/org.clojure/clojure/1.7.0-alpha4/clj/clojure.core/test/" ADD_DATE="1428267935" PRIVATE="0" TOREAD="0" TAGS="clojure,test,pre,post,assert">clojure.core/test</A>
<DD>Nope, this is not clojure.test (the most basic of the Clojure test frameworks). This is even more basic and was there since Clojure 1.0. If you annotate a function with metadata that has a :test keyword, you can then invoke (test myfn) and the function at :test will be invoked. This way the testing function will be very close to the function definition (right at the top). Why this could be useful? For quick tests without the need to create a new namespace. Or maybe some creative side-effect. Along with :pre and :post this is the most basic testing facility out of the box.

<DT><A HREF="http://conj.io/store/v1/org.clojure/clojure/1.7.0-alpha4/clj/clojure.core/shuffle/" ADD_DATE="1427988688" PRIVATE="0" TOREAD="0" TAGS="clojure,stdlib,shuffle,random,fisher,yates">shuffle</A>
<DD>Forgot to mention shuffle in the standard library. It returns a random permutation of the collection given as input. With this one Clojure is playing smart and delegating down to Java Collections.shuffle() method, which is linear time (I think what is described there is the Fisher-Yates at the end).

<DT><A HREF="http://blog.8thlight.com/patrick-gombert/2015/03/23/tail-recursion-in-clojure.html" ADD_DATE="1427376570" PRIVATE="0" TOREAD="0" TAGS="clojure,ast,macro,walk,recur,state,riddley">Tail Recursion In Clojure | 8th Light</A>
<DD>Interesting write-up. Loop-recur is implemented in Java inside Clojure, this blog post is a nice step-by-step guide about how to obtain similar results in macro land. It's making use of sophisticated techniques like walking the AST of the body of the passed in expression (with Riddley). Similar to what happens with core.async, yet another example of the power of macros to hide the state manipulation necessary to achieve a stack-free recursion.

<DT><A HREF="http://www.lispcast.com/Hindley-Milner-in-Clojure" ADD_DATE="1427295326" PRIVATE="0" TOREAD="0" TAGS="clojure,haskell,typed,milner,inference">Hindley-Milner in Clojure | LispCast</A>
<DD>That's an interesting exercise! Some typed languages offer type inference, a way for the compiler to infer the type of an expression just by looking at type declaration in other places. Languages like Haskell or Scala has that. In this small project (on top of big concepts) Eric Normand is implementing the widespread algorithm W for type inference on top of a small typed language (a Clojure DSL) all written in Clojure. Why that's useful? Because it helps understand problems that typed language are trying to solve bridging the gap between dynamically and statically typed languages.

<DT><A HREF="https://yow.eventer.com/yow-2014-1222/stop-treading-water-learning-to-learn-by-edward-kmett-1750" ADD_DATE="1427118903" PRIVATE="0" TOREAD="0" TAGS="clojure,video,fp,talk,keynote,lenses,kmett">Stop Treading Water: Learning to Learn by Edward Kmett</A>
<DD>Enjoyable keynote by Edward Kmett of Lenses fame (but not only). Kmett is a prominent Haskell expert, well known for his hundred libraries on github, but this talk is not about Haskell. Main take away is to not run away in front of complexity, but just find a way to effectively learn difficult topics. The danger is to spend your life solving problems with the wrong tool. He's also  warning us about jargon when used to create closed circles and always try to unroll complex terminology for people who don't necessarily know. This is true for some fundamental functional programming aspects especially when they are close to mathematics.

<DT><A HREF="http://sisal.sourceforge.net/" ADD_DATE="1426769403" PRIVATE="0" TOREAD="0" TAGS="clojure,functional,dataflow,parallel,languages,archeology">Sisal Lives!</A>
<DD>Exactly like in startups, it's unlikely you'll find new ideas in programming languages any time soon. Sisal (Streams and Iteration in a Single Assignment Language) is cited on some articles as a peculiar example of applicative language that is not functional (no high order functions). More importantly it compiles down to a dataflow representation that is implicitly parallel. Grab the tutorial (http://www2.cmp.uea.ac.uk/~jrwg/Sisal/00.Contents.html) if you are so inclined. But not sure the implementation linked here is still working.

<DT><A HREF="https://clojuredocs.org/clojure.core/take-while" ADD_DATE="1426696210" PRIVATE="0" TOREAD="0" TAGS="clojure,drop,while,return,imperative,functional">take-while - clojure.core | ClojureDocs</A>
<DD>And related cousin drop-while are just what the name says, a walk through a collection until some condition is met. It answers the typical procedural view of the problem about how to map a sequence and &quot;return&quot; at some point. There is no return in Clojure in the sense of jumping away from the current execution flow. That is typical of imperative languages and with functional languages you can get away with lazyness.

<DT><A HREF="https://github.com/matthiasn/talk-transcripts" ADD_DATE="1426678465" PRIVATE="0" TOREAD="0" TAGS="clojure,talks,transcripts,slides">matthiasn/talk-transcripts</A>
<DD>Thanks Matthias, this is a great service. Many talks are really worth a transcript, so words and slides can be pondered in total relax without the need to pause a video or just because you can easily digest them offline without a computer. This project collects great transcripts from huge speakers, including Rich Hickey, Guy Steele, Alan Kay and others.

<DT><A HREF="https://github.com/papers-we-love/papers-we-love/blob/master/design/out-of-the-tar-pit.pdf" ADD_DATE="1426678021" PRIVATE="0" TOREAD="0" TAGS="clojure,fp,oop,paradigms,complexity,incidental,paper,pdf">out-of-the-tar-pit.pdf · papers-we-love</A>
<DD>A big classic paper, often cited by Rich and others and great source of inspiration for talks like Are We There Yet and many others. Why is it so important? The paper clearly describes how many applications are only incidentally complex and that is often related to the language used. It then describes what aspects of different programming paradigms (procedural, OO, functional and logic) influence complexity the most. State and explicit procedural ordering are mainly responsible for complexity. The final part illustrates an hybrid approach called Functional Relational Programming that in the opinion of the authors solve incidental complexity best. If you agree with the proposed solution or not, the initial part is great at describing why functional programming is so much better than the imperative approach.

<DT><A HREF="https://www.youtube.com/watch?v=8NUI07y1SlQ" ADD_DATE="1426326833" PRIVATE="0" TOREAD="0" TAGS="clojure,talk,clojure-west,conference,video,vars,startup">Daniel Solano Gomez - How Clojure Works: Understanding the Clojure Runtime - YouTube</A>
<DD>Amazing presentation by Daniel Solano Gomez. The first part is a clear explanation of inner concepts in Clojure like vars, dynamic binding and namespaces. The second part builds on the first to show how this is used to create the dynamic nature of Clojure. The end is about ideas on how to reduce the startup overhead of Clojure, by envisioning different runtimes for different usages.

<DT><A HREF="http://rundis.github.io/blog/2015/clj_light_refactor.html" ADD_DATE="1426150097" PRIVATE="0" TOREAD="0" TAGS="clojure,refactoring,refactor,nrepl,vim,ide">Clojure refactoring in Light Table</A>
<DD>Somebody managed to attach refactor-nrepl to yet another development environment thus demonstrating that the abstraction really works and can be exported out of emacs. This is about LightTable but similar effort is ongoing with Vim. Great stuff.

<DT><A HREF="https://github.com/clojure/algo.monads" ADD_DATE="1426148972" PRIVATE="0" TOREAD="0" TAGS="clojure,monads,haskell,types,abtraction">clojure/algo.monads</A>
<DD>There is place for abstractions in almost every language. The time and context about when to use such abstractions change dramatically between languages. Clojure didn't put particular emphasis on the &quot;wrapped everything&quot; style that can be found for example in Haskell. This is of course related to the dynamic VS static typing debate. Functors, Applicative, Monads are at the end interfaces capturing a specific abstracted behaviour. Learning those abstractions is an useful expansion in a developer toolset that might come handy at some point. This library just implement the monadic abstraction the Clojure way for you so you don't need to reinvent the wheel. When and how to use something like this is very context specific.

<DT><A HREF="http://tuhrig.de/difference-between-save-and-export-in-docker/" ADD_DATE="1425916638" PRIVATE="0" TOREAD="0" TAGS="docker">Difference between save and export in Docker – Thomas Uhrig</A>
<DD>Just found this clear summary about saving docker container (and images) state. Not a Clojurey thingy.

<DT><A HREF="http://www.dunaj.org/" ADD_DATE="1425751583" PRIVATE="0" TOREAD="0" TAGS="clojure,core,api,fork,pypy,dunaj,alternative">Dunaj</A>
<DD>Dunaj is a Clojure fork created to experiment on new Clojure features. The announcement on the Clojure mailing list seems to imply that 10 of those features have already been implemented and they'll be published weekly. Two of them are already out about splitting apart functions in core and type annotation to avoid reflection warnings. So how this is different from features discussed by the Clojure core team the usual way? Probably Dunaj team wanted to implement new features without initial feedback or potential restrictions from Clojure core. As somebody suggested on the ML it is similar to PyPy and that project was definitely beneficial to core Python.

<DT><A HREF="http://danlentz.github.io/clj-uuid/" ADD_DATE="1425481379" PRIVATE="0" TOREAD="0" TAGS="clojure,uuid,library,tool,random,generator">clj-uuid by danlentz</A>
<DD>A clojure library to generate UUID. UUIDs are much more than random strings, with an entire RFC behind them and several different types. Java implements only V3 partially and v4 (the random ones). clj-uuid implements the much more interesting v3-v5 types completely (namespaces UUID) and v1(time-based concurrent). In soon to be released 1.2 Dan claims an impressive 350x v1 speed boost over the Java random version.

<DT><A HREF="https://clojuredocs.org/clojure.core/make-hierarchy" ADD_DATE="1425247162" PRIVATE="0" TOREAD="0" TAGS="clojure,multimethod,hierarchy,resolution,conflict,dispatch">make-hierarchy - clojure.core | ClojureDocs</A>
<DD>I don't remember I ever used make-hierarchy. My multi-methods up to now were simple dispatches on types and not much more. But things can go crazy in interesting ways when the multimethod hierarchy is complex. Make-hierarchy creates a hierarchy structure, similar to the one the multi-method would create and carry over by default. By giving your custom hierarchy to multimethod you can then easily manipulate the strategy to follow in case of type resolution clashing.

<DT><A HREF="https://pragprog.com/book/vmclojeco/clojure-applied" ADD_DATE="1424955988" PRIVATE="0" TOREAD="0" TAGS="clojure,books,practice,domain,modellling">The Pragmatic Bookshelf | Clojure Applied</A>
<DD>Just noticed another interesting addition to the Clojure bookshelf. I remember when the only one available was Clojure Programming in 2009 and now I think there are a dozen Clojure books! Ben Vandgrift and Alex Miller are looking into practical Clojure, from how to design an application, how to make good use of immutability, using parallel programming effectively and so on. But apart from the &quot;cookbook&quot; side of it there are chapters dedicated to: modelling with data, transformations and change management I never saw elsewhere. It can't be purchased right now and it has a published date in the future for the 1st of May.

<DT><A HREF="http://hypirion.com/musings/swearjure" ADD_DATE="1424783105" PRIVATE="0" TOREAD="0" TAGS="clojure,swearjure,fun,readable">polymatheia - Swearjure</A>
<DD>Swearjure is an interesting experiment and amusing time waster. It is definitely educational. What happens when in Clojure you decide to remove the use of letters and numbers? Is it even possible? It looks like it is, with some language gimmicks and twist. Look around for the quick sort implementation in Swearjure. Is it just me or it looks like Haskell? :)

<DT><A HREF="https://github.com/haskell-lisp/yale-haskell" ADD_DATE="1423647498" PRIVATE="0" TOREAD="0" TAGS="clojure,lisp,haskell,compilers,yale,history,trivia">haskell-lisp/yale-haskell</A>
<DD>In those early years when the committee decided to aggregate the dozen plus implementation of lazy-typed purely functional languages into one called Haskell, one prominent implementation from Yale was in lisp. This repo on github is the dump of one of the latest versions in 1993. Would be nice to see if it can still work.

<DT><A HREF="https://groups.google.com/forum/#!forum/comp.lang.functional" ADD_DATE="1423646534" PRIVATE="0" TOREAD="0" TAGS="clojure,history,fp,haskell,ml,miranda">comp.lang.functional - Google Groups</A>
<DD>comp.lang.functional is another piece of history in computer programming. The first message is April 14th 1990 by David Carlton at Harvard University moaning about being the only there knowing the term FP! What follows are all interesting questions about what was going on those years: Haskell GHC didn't exist, Miranda was mainstream, ML was mostly unknown, Lisp was established and so on. If you like to understand why we are where we are today, all good reading. If only it was possible to dump everything for offline reading...

<DT><A HREF="http://www.european-lisp-symposium.org/" ADD_DATE="1423642767" PRIVATE="0" TOREAD="0" TAGS="clojure,lisp,esl,conference,talks,proceedings">8th European Lisp Symposium</A>
<DD>Whoo hoo, the Lisp Symposium is going to be in London this year. It is open to all lispy languages, including Clojure, although I went a couple of editions in the past to see what was going on and it was mostly Lisp and Racket. There is Clojure and Scala in 2011 in Hamburg, hopefully there will be some in London this year as well. Overall interesting talks and even more interesting invited speakers like Richard P. Gabriel last year. I have no idea if you need to be an academic to attend, but if possible I'd like to.

<DT><A HREF="http://jafingerhut.github.io/clojure-info/clojure-for-lispers-transcript.txt" ADD_DATE="1423069269" PRIVATE="0" TOREAD="0" TAGS="clojure,lisp,video,talk,rich,transcript,text">Clojure for Lispers transcript</A>
<DD>Oldie but goodie, here's a transcription of &quot;Clojure for Lispers&quot;, one of the first public presentation Rich ever gave after making Clojure public. Its full of philosophical perls, especially toward the end, where the plan for Clojure world domination is revealed in more details: continuations, tail recursion, lexical scope, classes and OO and whatnot. Good to have it a searchable form if you don't want to watch the entire video to find for a specific bit.

<DT><A HREF="https://github.com/xsc/rewrite-clj" ADD_DATE="1422970544" PRIVATE="0" TOREAD="0" TAGS="clojure,indentation,formatting,sjacket,cgrand,library,refactoring">xsc/rewrite-clj</A>
<DD>Well description is pretty much all you need to know. The background of this is a talk by @cgrand that I enjoyed a while ago, talking about challenges in editor parsing and formatting. Space and indentation preserving transformations are not an easy problem but this library seems to contain all the necessary tooling. It also allows zipper traversal that is space/ident-aware. Use when your project requires styled output of Clojure forms.

<DT><A HREF="https://github.com/ptaoussanis/sente" ADD_DATE="1422864359" PRIVATE="0" TOREAD="0" TAGS="clojure,sente,async,websockets,ajax,events,sockets">ptaoussanis/sente</A>
<DD>So the time has come for your web-site to become &quot;real-time&quot;. One solid approach is certainly server-side push over one of the technologies available, such as WebSockets. But then you have to handle a few things, like reconnections, browser differences, message encoding, Ajax fallback and much more. Sente implements that thin layer on top of this bidirectional communication. It is based on http-kit (so you can expect those 600k+ concurrent connections) and core.async (the best model out there to handle async events from inside a terse API).

<DT><A HREF="https://github.com/trptcolin/clojureslim" ADD_DATE="1422612065" PRIVATE="0" TOREAD="0" TAGS="clojure,acceptances,fixture,fitnesse,slim,test,table">trptcolin/clojureslim</A>
<DD>Fitnesse is the venerable tool that allows input for acceptance tests as tables. In testing automation process it could be a nice tool to put in front of a customer to obtain verification for a feature (and maybe input a few more rows of tests). Over the years it got maintained and expanded. Slims are the &quot;plugins&quot; that allow Fitnesse fixtures to be written in other languages. Of course there is one for Clojure, although it appears to be in its initial state of 3 years ago. Nonetheless, I'm happy to give it a go for some project of mine that fits very well the table model.

<DT><A HREF="https://github.com/clojure/tools.namespace" ADD_DATE="1422546061" PRIVATE="0" TOREAD="0" TAGS="clojure,path,classpath,namespace,reload">clojure/tools.namespace</A>
<DD>tools.namespace is a required dependencies for so many projects that it could be already in your path without you noticing. It provides accurate reloading capabilities for namespaces, an essential feature for any live coding tool, being this the repl or other kind. Code analysis libraries for instance need to walk source folders to inspect namespaces and load them. It's also a fundamental piece in components systems, where the restart of a component often means reloading of the corresponding namespace (and dependencies).

<DT><A HREF="https://github.com/semperos/clj-webdriver" ADD_DATE="1422450116" PRIVATE="0" TOREAD="0" TAGS="clojure,libraries,tool,acceptances,test,automation,browser,selenium">semperos/clj-webdriver</A>
<DD>Years have passed since I last developed some browser automation. Well, glad to see how easy it is now, but remembering very well how low level it used to be. Anyway, great clj wrapper around Selenium web driver. As expected the lispy aspect translated into a pleasant automation API called Taxi. It's all well documented and samples are easy to find. The user group is alive and answering questions. Setup a working example was literally 3 lines of clojure.

<DT><A HREF="http://zirkonit.svbtle.com/clojure-opensource-code-metrics" ADD_DATE="1422024195" PRIVATE="0" TOREAD="0" TAGS="clojure,fun,curious,stats,big,massive,source,benchmark">Clojure Open-Source Code Metrics</A>
<DD>Somebody has collapsed into a single file hundreds of open source Clojure projects. This post illustrates some stats about how Clojure forms are used and distributed across projects. Some interesting bits? Low deftest/defn ratio, many &gt;5 args functions, defrecord but not deftypes. What else this can be used for? How about a test-bench for the Clojure compiler? Or any IDE out there that dare to open a 320k+ lines Clojure file?

<DT><A HREF="http://www.datomic.com/training.html" ADD_DATE="1422022560" PRIVATE="0" TOREAD="0" TAGS="">Training - Datomic</A>
<DD>Glad to see an &quot;endorsed&quot; Datomic training out there for free, from Stu Halloway in person. Despite the documentation, forums, conference talks and so on, Datomic still remains a niche product that few can understand. The six tutorial parts are 40 mins average in length. I don't know what you think but: what's up with Stu's hair? :)

<DT><A HREF="https://github.com/Chouser/clojure-jna" ADD_DATE="1421829578" PRIVATE="0" TOREAD="0" TAGS="clojure,native,C,jna,jni,stub,fast">Chouser/clojure-jna</A>
<DD>JNA (Java Native Access) is an alternative to the venerable JNI (Java Native Interface). While with JNI you need to generate source stubs to talk with native C library, JNA is based on libffi approach, an invocation system that at the cost of a thin layer of indirection wraps C native calls with a generic interface. clojure-jna offers a clojure-based interaction that is even more terse. If you look at the example you can see that invoking a native C function becomes a single liner. It goes beyond that with macros that make calling native code completely transparent.

<DT><A HREF="http://www.guidetovim.com/2013-12-02-mzscheme.html" ADD_DATE="1421829288" PRIVATE="0" TOREAD="0" TAGS="clojure,vim,scheme,plugin,racket,editor,support">Vim with Scheme support</A>
<DD>Only decent guide I could find out there about installing vim with mzScheme support (now Dr. Racket). Unfortunately, it looks like this language support for Vim was sort of abandoned (considering the bugs it generates on later version of Vim). That's a pity, because this is the only low level &quot;lispy&quot; support in Vim that I know of. You can create vim plugins in Scheme for instance, or just use it for daily Vim automation.

<DT><A HREF="https://clojuredocs.org/clojure.core/*compile-files*" ADD_DATE="1421760234" PRIVATE="0" TOREAD="0" TAGS="clojure,uberjar,compile,def,static,dynamic,initialization">*compile-files* - clojure.core | ClojureDocs - Community-Powered Clojure Documentation and Examples</A>
<DD>It is never good practice to put initialisation code into a def. That may become evident when AOT is involved and defs need to be executed (while defn are only executed on actual invocation of the function). If you connect to a network service in a def for example, compilation might succeed or not based on network availability. Only if you really need to, as a workaround, the code can be wrapped in a (when-not *compile-files*) to avoid execution during AOT compilation.

<DT><A HREF="https://github.com/jfacorro/clojure-lab" ADD_DATE="1421742981" PRIVATE="0" TOREAD="0" TAGS="clojure,IDE,editor,swing,poc">jfacorro/clojure-lab</A>
<DD>Clojure-Lab is an IDE written in Clojure. It is in its infancy so do not expect the polishing of other commercial environments. It is usable nonetheless and impressive in terms of driving Swing from Clojure. It has an useful &quot;outline&quot; view that shows functions in a namespace in the order they are defined and REPL integration.

<DT><A HREF="https://github.com/tpope/timl" ADD_DATE="1421396476" PRIVATE="0" TOREAD="0" TAGS="clojure,vim,vimscript,compiler,tpope">tpope/timl</A>
<DD>Awesome or insane, depending on your point of view. Writing a Clojure compiler/interpreter is always a nice experience (countless examples in history of writing your own lisp for teaching purposes). But Tim Pope here took it to the next level by writing it in VimScript! Let me recap: clojure-&gt;vimscript-compiler-&gt;vimscript. What is this useful for? Writing vim plugins in Clojure or everyday clojure evaluation at the vim command line.

<DT><A HREF="https://github.com/clojure/core.incubator/" ADD_DATE="1421395205" PRIVATE="0" TOREAD="0" TAGS="clojure,core,stdlib,format,string,formatter">clojure/core.incubator</A>
<DD>Oh, interesting repo. Here are experimental functions candidate for inclusion in clojure.core. At the moment not a lot, with the most interesting (for me) being an interpolation macro for strings. Like format, this macro allows special placeholder in a string to be replaced positionally by the rest of the arguments passed to the macro. But unlike format (that is using java.util.Formatter under the hood) is as fast as string concatenation.

<DT><A HREF="http://www.braveclojure.com/" ADD_DATE="1421342981" PRIVATE="0" TOREAD="0" TAGS="clojure,book,guide,beginner">Learn to Program the World's Most Bodacious Language with Clojure for the Brave and True</A>
<DD>This book remembers me of Why's (poignant) Guide to Ruby. It is carefully illustrated and the approach is humours. At the same time it is very serious work. It starts from the very beginning, how to setup a working environment for Clojure, but it covers all the hairy topics as well. It is available online and almost finished, it will then go to the print and become a paper book as well.

<DT><A HREF="http://benedekfazekas.github.io/2015/01/05/laziness-driven-changelogs/" ADD_DATE="1421341343" PRIVATE="0" TOREAD="0" TAGS="clojure,changelog,generator,documentation,tool,leiningen,plugin">Laziness driven changelogs</A>
<DD>Gargamel is an opensource tool brought to you by the Mailonline dev labs (thanks @bfazek) written in Clojure. It creates nicely formatted changelogs for git based projects. With that little bit of investment in writing consistent commit comments (hey you should do that anyway!) you can basically have a changelog for free (html or markdown). Install as a lein plugin or use as CLI.

<DT><A HREF="http://www.lambdacon.org/" ADD_DATE="1421253782" PRIVATE="0" TOREAD="0" TAGS="clojure,conference,talk,italy,lambda,functional">LambdaCon - funtastic code and people</A>
<DD>Just found this conference in Italy that I didn't know about. Looks promising. It's the same idea of the London based FPDays, with multiple functional languages speakers and workshops. Only one Clojure talk at the moment, we need some more there! Cheap and in a very nice city like Bologna in Italy, especially in late March.

<DT><A HREF="http://vimeo.com/45695419" ADD_DATE="1420738153" PRIVATE="0" TOREAD="0" TAGS="clojure,euroclojure,video,slides,cgrand,presentation,lenses,counterclockwise,parser">Not so homoiconic - Christophe Grand on Vimeo</A>
<DD>Enjoyed yet another talk by cgrand including the unavoidable references to papers to read to understand the concepts he's implementing in practice. This talk goes through the concepts involved in sources modification, a problem that IDE and source code tools have to face with. A source modification should be space, indentation, metadata, comment (and much more) preserving action. At the same time should give the tool the freedom to uniquely transform pieces of the code for refactoring and other processing needs common in development environments. Christophe borrowed the lens concept and simplified it for a view only (the editor). Conceptually, all transformation should always carry the original departure point over, so they can be repeated at any time in a consistent way.

<DT><A HREF="http://www.haskellcast.com/episode/009-conal-elliott-on-frp-and-denotational-design/" ADD_DATE="1420711945" PRIVATE="0" TOREAD="0" TAGS="clojure,haskell,fpga,research,frp,audio,podcast">Episode 9 - Conal Elliott on FRP and Denotational Design - The Haskell Cast</A>
<DD>Mind blowing interview with Conal Elliot of FRP fame. There is really just a bit of Haskell here, what is interesting are concepts behind FRP as intended initially, not as a stream of discrete events but as a function from reals (time as a continuum). Also interesting discussion on other research topics like more functional image transformations (as a function of space into colors) and special FPGA-based hardware compiler for functional languages. Unfortunately I couldn't understand completely what the main topic of the podcast is, denotational design. But there are pointers and that's the good part.

<DT><A HREF="https://clojuredocs.org/clojure.core/with-redefs-fn" ADD_DATE="1420625697" PRIVATE="0" TOREAD="0" TAGS="clojure,stdlib,core,tools,test,redefs">with-redefs-fn - clojure.core | ClojureDocs - Community-Powered Clojure Documentation and Examples</A>
<DD>with-redefs-fn is similar to with-redefs and based on what the main use case is for using it, it can be a better choice. Namely, with with-redefs-fn you  can re-define a function without the need to wrap it in a &quot;constantly&quot; for example, which would be the case with with-defers. Underneath it, with-redefs is just a macro created on top of with-redefs-fn. Finding this function in normal code would be probably a smell, since the main use case for such a global replacement is testing.

<DT><A HREF="http://emareaf.deviantart.com/art/Rich-Hickey-321501046" ADD_DATE="1420329310" PRIVATE="0" TOREAD="0" TAGS="clojure,rich,drawing,pics,fun">Rich Hickey by emareaf on DeviantArt</A>
<DD>Funny faces you can found around on the inter web! Artengine is written in Clojure and it was used to create this vector image.

<DT><A HREF="http://openjdk.java.net/groups/hotspot/docs/RuntimeOverview.html" ADD_DATE="1419938646" PRIVATE="0" TOREAD="0" TAGS="clojure,java,compiler,jdk,hostpost,native,machine">HotSpot Runtime Overview</A>
<DD>Interesting reading about the principal constituent of the HotSpot virtual machine. Frankly HotSpot is a quite amazing piece of software. At the end of the day it is an assembler generator, transforming the bytecode coming from the compiler into machine code for a specific architecture. It's also caching the generated fragments that are requested more often so they don't need additional generation. But that not the end of the story. Maybe the most amazing feature is that it's constantly inspecting the request for bytecode compilation for specific paths and adapting this caching for different situation, only generating the machine code when needed. In fewer words, self-optimisation. There are other crucial parts like the mapping between native and Java threads and the synchronization machine. Cool stuff (and useful basic concepts for Clojure optimisation).

<DT><A HREF="http://insideclojure.org/" ADD_DATE="1418854933" PRIVATE="0" TOREAD="0" TAGS="clojure,internals,blog,alex,miller,cognitect">Inside Clojure – Tales of Developing Clojure</A>
<DD>Another fine reading. This is Alex Miller of StrangeLoop fame keeping track of the journey inside the Clojure internals while he's working on tickets or improving stuff. Alex is definitely providing a service to the wider audience of Clojure developers that are not necessarily aware of how Clojure works but would like to know without necessarily reading the sources.

<DT><A HREF="https://clojuredocs.org/clojure.core/unchecked-subtract" ADD_DATE="1418765872" PRIVATE="0" TOREAD="0" TAGS="clojure,stdlib,int,conversion,long">unchecked-subtract - clojure.core | ClojureDocs - Community-Powered Clojure Documentation and Examples</A>
<DD>Some surprises about implicit long promotion here. unchecked-* functions are not enforcing an int return type (by design, they deal with longs). This is not what the &quot;unchecked&quot; part is about. Something like (unchecked-dec Integer/MIN_VALUE) roll over into a Long. If instead you need the Java behaviour of (Integer/MIN_VALUE - 1) then you need unchecked-dec-int.

<DT><A HREF="https://groups.google.com/forum/#!topic/clojure-dev/EAqR8a9PVVg" ADD_DATE="1418338589" PRIVATE="0" TOREAD="0" TAGS="clojure,transient,hamt,trie,ctrie,concurrent">Contrib proposal: Ctries in Clojure - Google Groups</A>
<DD>Neat work by Michał Marczyk (who also presented it at the past ClojureExchange edition) implementing a HAMT like concurrent map. The specific use case is similar to that of transients in Clojure, the possibility to switch to a mutable map for faster creation operations but with the difference that a citrie is also concurrent (CAS semantic) while a transient will throw exception if accessed from a different thread. It is based again on Phil Bagwell's work (papers downloadable).

<DT><A HREF="https://github.com/aaronc/freactive" ADD_DATE="1418337251" PRIVATE="0" TOREAD="0" TAGS="clojure,clojurescript,react,reagent,om,freactive,rx">aaronc/freactive</A>
<DD>Freactive is another player in the reactive clojurescript arena. After Om and Reagent, Freactive concentrates specifically on fast animations (and also other things). It takes inspiration from Reagent for the hiccup syntax and cursors from Om. Different from Om (and this React) it doesn't use diffing as main engine to render the next state but changes are bound to the site where they are to be applied. See the README for the details.

<DT><A HREF="https://github.com/clumsyjedi/lein-chrome-extension" ADD_DATE="1418315731" PRIVATE="0" TOREAD="0" TAGS="clojure,clojurescript,chrome,extension,plugin,leiningen">clumsyjedi/lein-chrome-extension</A>
<DD>Say you're looking for a dead easy way to create a new extension for Chrome but tired of the nonsenseness out there you'd like to write it with your beloved ClojureScript. This leiningen template creates all the necessary plumbing (and there is quite a bit of it). You just need to 'lein chrome build once' and point chrome to the target/unpacked folder et voila' a lambda icon appears.

<DT><A HREF="https://github.com/MailOnline/throttle" ADD_DATE="1418302428" PRIVATE="0" TOREAD="0" TAGS="clojure,lib,me,mailonline,http-kit,core.async,throttle">MailOnline/throttle</A>
<DD>Wrote this little lib. There are other generic throttlers for Clojure out there which work on generic functions and offer neat features like bursting. Throttle is mainly dedicated to http stuff though and offers that out of the box. For all scraping-big-data needs throttle is your friend. Say you have thousands requests to make on a regular basis (like Facebook share counts, twitter RTs or other social-network APIs). Throttle helps you avoiding being banned because you are hitting too hard. Give it a collection of URLs and how many req/sec to fire. Is based on core.async and http-kit. Works like a charm.

<DT><A HREF="http://acha-acha.co/#/user/richhickey@gmail.com" ADD_DATE="1417707753" PRIVATE="0" TOREAD="0" TAGS="clojure,git,humour,funny,rich">Rich Hickey — Acha-acha</A>
<DD>A little bit of humour for this essential service that tells you how much you're achieving based on your git activity. And Rich is the winner (at least at the time of this bookmark) with achievement in all the 30 categories. For example: &quot;Narcissist
Use your own name in a commit message&quot; or &quot;In Love with Work
Commit on Feb 14&quot;. Priceless.

<DT><A HREF="http://iloveponies.github.io/" ADD_DATE="1417687757" PRIVATE="0" TOREAD="0" TAGS="clojure,course,workshop,learning,beginner">Functional Programming Workshop</A>
<DD>Nicely done 1 week training for Clojure. It starts from the basics like installing the environment and tools. There are useful exercises each chapter, with the final part of the course implementing a blog engine. I would use for somebody with zero Clojure experience to get them up to speed.

<DT><A HREF="https://groups.google.com/forum/#!msg/clojure/8jHI9qD9qJs/58uFSPl-7n8J" ADD_DATE="1417647557" PRIVATE="0" TOREAD="0" TAGS="clojure,macro,if-let,bindings,multiple">Wouldn't it be nice if if-let allowed more bindings? - Google Groups</A>
<DD>Indeed. This is one I need all the time and I was wondering if there was something preventing if-let to support multiple binding at the language implementation level. in any case, the macro presented here seems to do the trick.

<DT><A HREF="https://github.com/om-cookbook/om-cookbook/tree/master/recipes/dev-setup" ADD_DATE="1417646707" PRIVATE="0" TOREAD="0" TAGS="clojure,clojurescript,om,cookbook,anna">om-cookbook/recipes/dev-setup at master · om-cookbook/om-cookbook</A>
<DD>Anna Pawlicka started a long awaited Om Cookbook. The project is the beginning but already contains hints on how to get started quickly creating a new Om project. At the moment it also contains a recipe to create charts. With the first two easy recipes you are able to create something useful already. Similarly to the Clojure Cookbook it's gonna be even more successful if the rest of the Om/ClojureScript community contributes back.

<DT><A HREF="http://mads379.github.io/ocaml/2014/11/13/ocaml-briefly.html" ADD_DATE="1417641721" PRIVATE="0" TOREAD="0" TAGS="clojure,ocaml,okasaki">OCaml Briefly</A>
<DD>A really short introduction of the main concept and syntax of OCaml. This article is by no mean a definitive tutorial or a guide, but just enough to stimulate curiosity about some features that are not present in Clojure, like the effect of currying everything. Not only that, I was suggested this quick intro by Christophe Grand just to grok enough ML syntax to read Okasaki Purely Functional Data Structures book. Will try out on the book pretty soon.

<DT><A HREF="http://clojure.org/special_forms" ADD_DATE="1417641119" PRIVATE="0" TOREAD="0" TAGS="clojure,contracts,preconditions,form,function">Clojure - special_forms - :pre :post</A>
<DD>Of the many Clojure special form, one that is not found a lot in the wild are the map of :pre and :post conditions. fn and defn supports a conditions map after parameters declaration. The condition map is compiled into “assert” invocations, thus generating a java.lang.AssertionError at runtime when they fail. I wouldn’t use them to check for nils or empty, because they go against the usful Clojure resiliency on missing things. They might have specific use on enforcing business conditions or maybe types where this is important. Let me know if you have any brilliant example of contract based programming to post here.

<DT><A HREF="http://eusebeia.dyndns.org/veblen/veblen" ADD_DATE="1417641042" PRIVATE="0" TOREAD="0" TAGS="clojure,ackermann,growth,bigOh,computable">On Fast-growing Computable Functions</A>
<DD>Since we bumped into the Ackermann function for this month’s SICP book club, I was looking around for example of fast growing functions. If you stay in computer science, you’ll probably see just a few O(n!) when all possible permutations are involved. But there is much more than that and much more than Ackermann. Even if you don’t grasp al the math in this paper there is some humour around that makes it pleasant. At least you will be able to say that the “ordinal pentation” grows faster.

<DT><A HREF="http://www.slideshare.net/ScottWlaschin/fp-patterns-buildstufflt" ADD_DATE="1417426361" PRIVATE="0" TOREAD="0" TAGS="f#,functional,monads,binding,purity,oo,oop">Functional Programming Patterns (BuildStuff '14)</A>
<DD>I don't know F#, but there is something useful in this list of principles and patterns applied to the world of functional programming. I especially liked the examples of practical applications of monads, to remove nested conditionals and check-for-next-step logic (like bloated try catches everywhere). Also the railway analogy is quite powerful and explains monad in simple words. An interesting parallel with mathematical functions is given at the beginning, another simple way to express purity in functional programming. Will try to follow more from Scott Wlaschin in the future.

<DT><A HREF="https://leanpub.com/u/fogus" ADD_DATE="1416925203" PRIVATE="0" TOREAD="0" TAGS="clojure,lisp,fp,magazine,fogus">Read-Eval-Print-λove - Michael Fogus</A>
<DD>A real treat for Lisp lovers, this bi-weekly news-letter by Fogus looks more like an entire magazine considering the length and depth of each issue. The focus is around the Lisp family of languages, with plenty of pointers, bits of history, diagrams and snippets. In the first two issues Fogus is illustrating the primordial functional concepts, showing a list of interesting lisp dialects and McCarthy description of what a Lisp language is. The second issue shows a Lisp implementation and its main constituent. Totally fine read.

<DT><A HREF="http://grimoire.arrdem.com/1.6.0/clojure.core/as-%3E/" ADD_DATE="1416843707" PRIVATE="0" TOREAD="0" TAGS="clojure,thread,macro,-&gt;as,let,binding,parameters,arguments">-&gt;as - Clojure Documentation</A>
<DD>I missed this thread macro variation for some reason. Like a let form, it creates a local binding in the context of a thread pipeline. It's very useful for all those situation where the target object is not necessarily always the first argument (-&gt;) or the last argument (-&gt;&gt;) but a mix of the two or even in the middle of a function call.

<DT><A HREF="https://www.youtube.com/watch?v=4KqUvG8HPYo&index=8&list=PLZdCLR02grLoc322bYirANEso3mmzvCiI" ADD_DATE="1416784060" PRIVATE="0" TOREAD="0" TAGS="clojure,rich,video,talk,conj,transducers">Rich Hickey - Inside Transducers - YouTube</A>
<DD>My first impression of transducers when I first heard of them was very related to the Reducers work and I was wrong, there is much more. A lot more has been done with stateful transducers (for example take or partition-by) also because it is not possible in a parallel context. The design of transducers is more coherent and extended to many more areas than Reducers. One of them is certainly core.async channels. If you consider that there is still a lot of work to do like promise-channels, endpoints and pipelines, the addition of Transducers is creating a powerful set of concurrency abstractions. This talk by Rich gives a very good overview of all of the above, including useful code snippets. It is quite dense presentation though, so it might require additional investigation to digest completely.

<DT><A HREF="https://github.com/pixie-lang/pixie" ADD_DATE="1416515229" PRIVATE="0" TOREAD="0" TAGS="clojure,pixie,lisp,rpython,compiler,transducers,tracing,JIT">pixie-lang/pixie · GitHub</A>
<DD>That guy is on-fire! Timothy Baldridge is already author of so many things, screencasts, core libraries like core.async and now why not putting an innovative language on a side? Pixie is written in RPython, the same as the fast Python cousin, PyPy. RPython tooling allows for fast development of your own VM, including low level stuff like garbage collection and implements for you aggressive fragment caching like inside its tracing JIT. It is heavily inspired by Clojure for its standard library and things like pattern matching or easy native interaction are coming on top.

<DT><A HREF="http://robots.thoughtbot.com/writing-clojure-in-vim" ADD_DATE="1416514383" PRIVATE="0" TOREAD="0" TAGS="clojure,vim,emacs,paredit,editor,plugins">Writing Clojure in Vim</A>
<DD>Some good hints here in order to start with the right tooling writing clojure with vim. Specifically interesting the comparison between vim-paredit and vim-sexp, the latter not changing usual mappings and hence more interesting for people who wants to keep their finger memory intact. I approached vim-paredit once but couldn't be productive right away and now I keep procrastinating on it. I'm also of the impression that paredit value with vim is somehow less than emacs, considering that all the moves to handle wrappings (quotes, symbols, parenthesis, paragraph and so on) are all built-in.

<DT><A HREF="https://github.com/rkneufeld/lein-try" ADD_DATE="1416417242" PRIVATE="0" TOREAD="0" TAGS="clojure,tools,leiningen,plugins,try,library">rkneufeld/lein-try</A>
<DD>I was convinced I already bookmarked this plugin here, but I was wrong. Lein try is simply amazing to try out libs without having to setup a project or jump into a &quot;test&quot; one to change its dependencies. It is like creating a leinengen based project on the spot and start the REPL. One example could be some client for some external service to quickly try to connect to without having to create a full project for that to have a REPL.

<DT><A HREF="http://blog.factual.com/using-clojure-to-generate-java-to-reimplement-clojure" ADD_DATE="1416410710" PRIVATE="0" TOREAD="0" TAGS="clojure,performances,data,structures,unrolling">Using Clojure To Generate Java To Reimplement Clojure - Factual Blog</A>
<DD>High concentration of interesting ideas in this blog post by Zach Tellman. First of all unrolling collections. The general principle is to consider the first few sizes of a collection as special fixed size structures that can only deal with that number of elements and no more. That removes the need for many checks and iteration mechanisms. Clojure implements that with PersistentArrayMap VS PersistentHashMap, considering the first a special case for the first 16 elements of a collection. Second is, let's say you want this specialized data structures in Java for the first six elements of vectors. What happens is that you'll see the same boilerplate code repeating at least 6 times. But not if you can generate that automatically from Clojure which is what Zach did. All of that was submitted as a patch for Clojure to speedup small vectors operation. Good luck to the ticket reviewer and the n-thousands line of generated stuff to review! :)

<DT><A HREF="https://pragprog.com/book/cjclojure/mastering-clojure-macros" ADD_DATE="1416408737" PRIVATE="0" TOREAD="0" TAGS="clojure,macros,macro,book">The Pragmatic Bookshelf | Mastering Clojure Macros</A>
<DD>I recently started reading this thin book to refresh my macro vodoo. I think this is one of those book that is thin not because there is not that much to say, but because it is essential and to the point. The first chapter, with a few step by step examples of macro expansions and evaluation is probably worth the entire book alone. I'm looking forward to speedup your system chapter to see in which way code can easily be handled at compile time, improving performances.

<DT><A HREF="http://dev.clojure.org/jira/browse/CLJ-1529" ADD_DATE="1416408472" PRIVATE="0" TOREAD="0" TAGS="clojure,release,alpha,performances,classes,classloading">[#CLJ-1529] Significantly improve compile time by reducing calls to Class.forName - Clojure JIRA</A>
<DD>Big improvement coming in the next clj 1.7 release, but already available in alpha4. I noticed this hotspot myself profiling the startup time of a huge application at work. This improvement impacts startup or reload time more than normal runtime, since it has to do with class loading (and Clojure knows how to get this part crazy pretty fast considering all the dynamic class generation, one for each fn).

<DT><A HREF="http://www.railslove.com/stories/my-way-into-clojure-building-a-card-game-with-om-part-1" ADD_DATE="1416407233" PRIVATE="0" TOREAD="0" TAGS="clojure,introduction,simplicity,simple,easy,learning,rails">My Way into Clojure: Building a Card Game with Om - Part 1</A>
<DD>It's nice that Clojure introductory articles keep coming covering different perspective. This one is well written and rich in pointers for further readings. The point of view here is the less common one of a JS front-end developer background with Rails experience starting learning about Clojure and FP. The learning curve can be a difficult one, especially when you fail to miss, at first, compelling use cases to do a proper switch. In this case the stronger use case was Om, or more in general the use of Clojure through ClojureScript. It demonstrates how important was for Clojure to jump on the client side from the early beginning (the first ClojureScript attempt is from 2009). The post also illustrates compelling examples of simplicity and ease from the Rails world. inspired by Rich's simplicity talk.

<DT><A HREF="http://infoscience.epfl.ch/record/64394?ln=en" ADD_DATE="1416308109" PRIVATE="0" TOREAD="0" TAGS="clojure,internals,trie,algorithm,structures,hamt">Fast And Space Efficient Trie Searches</A>
<DD>Phil Bagwell's work is well known in Clojure land, since persistent data structures are heavily based on that. This is the most introductory paper about the general problem of optimizing search tries. In this paper the basic trie is presented first and then variants to speed it up follow. A small binary trie can be used to search faster for the next sub-trie but even better, bitmap based access. With this configuration on modern hardware, only one instruction is necessary to count bits, hence accessing the next sub-trie. Another big advantage of bitmapped searches is that they reduce the space wasted for a missing sub-trie to a single &quot;0&quot; bit.

<DT><A HREF="http://spootnik.org/entries/2014/11/03_heads-up-for-clojure-library-writers.html" ADD_DATE="1415012242" PRIVATE="0" TOREAD="0" TAGS="clojure,stdlib,update,update-in">spootnik.org – heads up for clojure library writers</A>
<DD>There are a few inconsistencies in the Clojure stdlib and they often fuel interesting debates in the mailing list. One of them was about the asymmetric get get-in, assoc, assoc-in and update-in that was missing a simple &quot;update&quot;. Minor stuff, yes, but this is coming in the next rel 1.7. Of course the release is bringing a way lot more than this.

<DT><A HREF="https://cognitect.wufoo.com/reports/state-of-clojure-2014-results/" ADD_DATE="1414748809" PRIVATE="0" TOREAD="0" TAGS="clojure,adoption,report,statistics,users">http://blog.cognitect.com/blog/2014/10/20/results-of-2014-state-of-clojure-and-clojurescript-survey</A>
<DD>Here are the glorious Clojure charts and text responses. About 1400 people replied the questions for Clojure, 650 for ClojureScript. Notable results: adoption in prod environment is increasing, usage is mainly for webapp, usage for ETL and big-data is decreasing. As of new features, quicker startup mode for clj dev is at the top (along with the usual better stack traces). Much more insights if you care to dig deeper.

<DT><A HREF="http://grimoire.arrdem.com/1.6.0/clojure.core/bean/" ADD_DATE="1414747954" PRIVATE="0" TOREAD="0" TAGS="clojure,java,interop,bean,readonly,access,object,getter">Grimoire - Clojure Documentation</A>
<DD>The bean function is quite an handy one. Just feed it with a Java object to transform its public fields into a read-only Clojure map. Use when you have interop needs for value objects that need to be accessed frequently in read-only mode. If you need to write, consider wrapping everything in a defmutable (read below).

<DT><A HREF="https://github.com/reborg/reclojure/blob/master/src/reclojure/lang/util.clj#L32" ADD_DATE="1414747846" PRIVATE="0" TOREAD="0" TAGS="clojure,interop,java,deftype,mutable,volatile">defmutable · reborg/reclojure</A>
<DD>This macro is a thin wrapper around deftype. Deftype by default creates an immutable non-associative Clojure structure which is good for 90% of the cases. In Java interop contexts though, you may need something mutable and Clojure allows to define mutable deftype attributes as well with :volatile-mutable. So far so good, but then you need to provide also &quot;setters&quot; for each one of the mutable field. This macro automates everything for you: (defmutable MyType [attr1 attr2]) and then read with (.attr1 (MyType. :a :b)) and write with (.attr1! (MyType. :a :b) :c).

<DT><A HREF="https://github.com/sunng87/slacker" ADD_DATE="1414689403" PRIVATE="0" TOREAD="0" TAGS="clojure,microservices,rpc,lib,serialization,http,rest">sunng87/slacker</A>
<DD>Slacker exposes a Clojure namespace as an RPC service. It can do that in different ways and by default it will go binary protocol (with some options as of the serialization format). Other options are over HTTP or Ring compatible mode. It could be a good option if you're searching  for fast microservice development, without necessarily going through REST-ish things.

<DT><A HREF="https://github.com/ztellman/potemkin" ADD_DATE="1414681924" PRIVATE="0" TOREAD="0" TAGS="clojure,deftype,interop,util,utils,deftype+,abstract">ztellman/potemkin</A>
<DD>Some little treasures here. It is at the end the usual &quot;utils&quot; library but with a twist around creation of types and interfaces. import-vars is useful tool from the point of view of the library implementors, to keep all nice and isolated ns while developing and then torw everything in the same bucket at the end. def-derived-map transform normal objects into map-like objects. deftype+ supports def-abstract-type to create types that shares functions (missing by design with deftype). If you do a lot of interop you don't want to miss this lib.

<DT><A HREF="https://github.com/danielsz/system" ADD_DATE="1414667736" PRIVATE="0" TOREAD="0" TAGS="clojure,components,collection,library,reusable">danielsz/system</A>
<DD>Interesting. It would be good if one opinionated collection of components built on top of Stuart Sierra's component lib would emerge and received collective love by the community. We also maintain and evolve our own collection (https://github.com/MailOnline/clj-components) but the dream of that being completely generic and community driven vanished a long ago. So, if you maintain your own collection, consider contributing back to this library instead. Unless there is even a better one already :)

<DT><A HREF="http://www.colourcoding.net/blog/archive/2014/10/27/design-patterns-happy-birthday-and-goodbye.aspx" ADD_DATE="1414651462" PRIVATE="0" TOREAD="0" TAGS="clojure,oop,fp,patterns,design,objects,gof">Design Patterns: Happy Birthday and Goodbye</A>
<DD>A few concise good points about GoF. There still a lot of good wisdom in the original 23 GoF patterns (I have my copy in the bookshelf and you should have yours). But the heritage from C++ is making them gradually outdated. With dynamic languages and first class functions some of them are even useless. Agree, but won't remove the book from my bookshelf :)

<DT><A HREF="http://www.ibm.com/developerworks/library/j-treevisit/" ADD_DATE="1414572372" PRIVATE="0" TOREAD="0" TAGS="clojure,tree,zippers">Tree visitors in Clojure</A>
<DD>Good article by Alex Miller, now Cognitect, of Strangeloop and The ConJ fame, about trees. He compares the OO approach with a few options in FP-land, including zippers.  He's also making use of a multimethod approach to visit tree nodes based on their type and take action. All illustrated with good examples and drawings.

<DT><A HREF="http://grimoire.arrdem.com/1.6.0/clojure.core/max-key/" ADD_DATE="1414536220" PRIVATE="0" TOREAD="0" TAGS="">max-key - Clojure stdlib</A>
<DD>More interesting bits from the standard library (they apparently never finish). max-key (and brother min-key) applies a function of your choice to a collection of elements, assuming the result of fn is a number. They order the results and return the element that generated the highest (or lowest respectively) result. Easy example: find the longest word with (max-key count [&quot;asd&quot; asdf&quot; &quot;a&quot;]) =&gt; &quot;asdf&quot;

<DT><A HREF="http://stackoverflow.com/questions/1315099/clojure-macro-to-create-a-synonym-for-a-function" ADD_DATE="1414083196" PRIVATE="0" TOREAD="0" TAGS="clojure,scheme,define,def,alias,macro">Clojure macro to create a synonym for a function - Stack Overflow</A>
<DD>Creating an alias of a function name is not frequent in Clojure as in Ruby. But the Ruby semantic is different. Aliasing a function in Ruby offers the possibility to immediately dispose of an old method implementation and replacing it with a new one without breaking compatibility and with the possibility to still use the old implementation internally, resulting in two function definition with the same name that don't replace each other. In Clojure it would be somehow complicated to obtain a similar effect (if and ever you can't really do without). With something simple as introduced in this SO question, you can at least have different names referring to the same function using just some syntactic sugar. Possible uses? Well say you are translating an app from Scheme where define is used instead of def. You could use a macro to have define to work as an alias for def from Clojure and copy paste throughout!

<DT><A HREF="http://stackoverflow.com/questions/7852351/clojure-macro-to-generate-functions" ADD_DATE="1413997221" PRIVATE="0" TOREAD="0" TAGS="clojure,macro,generate,function,dynamic,copypaste">clojure macro to generate functions - Stack Overflow</A>
<DD>Here's another of those tricks that I used all the time in Ruby land, generating functions on the fly that can then be invoked from other part of the application. In Clojure this can be done the dynamic way through &quot;intern&quot; and friends or with a macro. Both options are present in this nice answer by amalloy. When to use? When a set of repetitive functions need to be created, to avoid the actual &quot;copy paste&quot;. It might be a smell or not depending on the specific context, but I would keep the possibility in mind.

<DT><A HREF="http://clojutre.org/2014/" ADD_DATE="1413996035" PRIVATE="0" TOREAD="0" TAGS="clojure,conference,talks,talk,finland">clojuTRE 2014</A>
<DD>Another interesting conference is landing in Europe on November, this time organised in the cold (but friendly) Finland. Thinking about submitting a talk and you should do the same (or just attend). Bodil is already in pole position on the website and I'm sure more great speakers will go on the list.

<DT><A HREF="http://www.haskellcast.com/episode/001-edward-kmett-on-lenses/" ADD_DATE="1413995786" PRIVATE="0" TOREAD="0" TAGS="clojure,haskell,podcast,audio,lenses,fp">Episode 1 - Edward Kmett on Lenses - The Haskell Cast</A>
<DD>I started listening to some non-clojure podcasts lately, like this one on Haskell and others (Erlang for example). I don't understand a single thing :) and that's enough to get me interested. So after some general discussions about Haskell libraries and evolution, Edward Kmett goes into explaining Lenses. One of the possible uses seems to be a more general abstraction to traverse items (trees but not only) hence the name, the capability to &quot;focus&quot; on a portion of a data structure following a path. It got me intrigued though and I'm exploring their usefulness in Clojure land.

<DT><A HREF="https://github.com/MailOnline/clj-stingray" ADD_DATE="1413995440" PRIVATE="0" TOREAD="0" TAGS="clojure,ops,stingray,library">MailOnline/clj-stingray</A>
<DD>Quick self promotion for a project I just published. It's in very early infancy, usable but with just a small part of the REST API set that Riverbed Stingray load balancer has to offer. Why should you use it? Well of course you have Stingray around and you want to do some build automation with it, maybe draining nodes before a deploy or knowing the rules that are directing traffic to your app and act programmatically on them. I'm planning to add more of these use cases on the go. If you feel like, please fork, pull requests to add some more stuff well accepted.

<DT><A HREF="http://hypirion.com/musings/understanding-persistent-vector-pt-1" ADD_DATE="1413992764" PRIVATE="0" TOREAD="0" TAGS="clojure,vector,internals,persistent,trie,branching">polymatheia - Understanding Clojure's Persistent Vector, pt. 1</A>
<DD>Probably one of the best explanation out there about internals of persistent vectors (and maps) in Clojure. There are three parts of this article, the first one dealing with sharing, the second with indexing through bitmaps, the third about using the &quot;tail&quot; optimization. Articles are verbose in a good way, going into glorious details. It was exactly what I needed to understand bitmap indexing! Seriously well done.

<DT><A HREF="http://clojuredocs.org/clojure.core/munge" ADD_DATE="1413974334" PRIVATE="0" TOREAD="0" TAGS="clojure,stdlib,tools,munge,names">munge - Clojure stdlib</A>
<DD>Another little utility. It is exposed but not documented. Munge is used heavily internally to Clojure to make names always digestible for Java side consumption (for example, transforming dashes into underscores, replacing strange chars and so on). The munged string is then Java-safe. Another good use is if you need to persist files using some string that is coming from the running application as a name. Munge will convert spaces for example, so the string can be used as a file name.

<DT><A HREF="https://diogo149.github.io/2014/10/19/om-no/" ADD_DATE="1413878742" PRIVATE="0" TOREAD="0" TAGS="clojure,clojurescript,om,reagent">Om No! Trouble in paradise with ClojureScript and React.js</A>
<DD>This post compares Om with Reagent, two ClojureScript libraries wrapping Facebook React. It starts illustrating the good side of Om and finishes with its main pitfalls. In this particular case, Om biggest problems are general complexity and some unnecessary rendering of components (and others). Overall well balanced and I think the points it makes against Om deserve attention.

<DT><A HREF="http://mostlylazy.com/2012/03/13/episode-0-0-5-chris-houser-at-clojure-conj-2011/" ADD_DATE="1413800606" PRIVATE="0" TOREAD="0" TAGS="clojure,podcast,audio,history">Episode 0.0.5: Chris Houser at Clojure Conj 2011 | Mostly λazy…a Clojure podcast</A>
<DD>I spotted this old episode with Chris Houser on the Mostly Lazy Podcast and enjoyed the nostalgic atmosphere :) Not sure if you're interested in this sort of history bits about Clojure, but I like to put things in context. Chris was with Clojure since the beginning (I think IRC logs exists because of his initial effort) and participated in almost all import design discussions that happened on the list as well. In this episode: the first ClojureSript implementation and error-kit, an exception extension for Clojure that implements Lisp like exceptions. Chas and Chris also discuss the general Clojure community attitude.

<DT><A HREF="http://fpdays.net/2014/location/" ADD_DATE="1413403207" PRIVATE="0" TOREAD="0" TAGS="clojure,conference,talk,fp">FP Days 2014</A>
<DD>Juicy program this year for an interesting all FP 2 days conference, this time in London (previous edition was in Cambridge). Christophe Grand will be keynoting (I hope about Transducers but we'll see) and there are other interesting Clojure talks, like another iteration of Clojure at a Newspaper by Mr Pither. Other languages are present, haskell, lots of F# stuff, refactoring FP and testing FP. if you have an user group you can get a 10% discount.

<DT><A HREF="https://www.youtube.com/watch?v=wASCH_gPnDw" ADD_DATE="1413393954" PRIVATE="0" TOREAD="0" TAGS="clojure,video,introduction,presentation">Expert to Expert: Rich Hickey and Brian Beckman - Inside Clojure - YouTube</A>
<DD>Good introduction to Clojure by Rich himself talking with Brian Beckman. It also goes beyond the basic introduction when Clojure is compared to other languages of the ML family (for example Miranda or ML itself). Rich also gives an overview of persistent data structures internals and concurrency mechanisms.

<DT><A HREF="http://grimoire.arrdem.com/1.6.0/clojure.core/gensym/" ADD_DATE="1413390585" PRIVATE="0" TOREAD="0" TAGS="clojure,macro,symbol,random,names,hygienic">gensym - Clojure standard library</A>
<DD>gensym is a little function that generates an unique symbol name (in the current running process). It optionally takes a prefix that will be used along with a sequential number added to the name. The main use of gensym is to write hygienic macros because it prevents clashes with environment bindings that are already in place at expansion time.

<DT><A HREF="http://grimoire.arrdem.com/1.6.0/clojure.core/locking/" ADD_DATE="1412957013" PRIVATE="0" TOREAD="0" TAGS="clojure,locking,locks,mutable,synchronized,stdlib">locking - clojure.core</A>
<DD>Programmatic locking is not in Clojure. Thread synchronisation and concurrency are handled at a much higher level with atoms, vars, refs and agents. But just in case you need to go low level, the locking function is still less verbose than the Java version that requires the synchronised keyword around an object instance. One use of locking could be if you use deftype with an unsynchronized-mutable field and then you need to protect updates with a lock. Use if you know what you're doing.

<DT><A HREF="http://clojuratica.weebly.com/" ADD_DATE="1412895625" PRIVATE="0" TOREAD="0" TAGS="clojure,mathematica,bridge,wolfram">gasc/Clojuratica · GitHub</A>
<DD>This makes me wonder if there are still things that can be invented to work with Clojure! Also the Mathematica integration! If you are a Mathematica user but would like to code in it using your favourite language, this project is for you. Although I'm not sure is actually maintained anymore, it might make a good use case to revive it to bridge the Wolfram language instead.

<DT><A HREF="http://java.ociweb.com/mark/clojure/ClojureCategorized.html" ADD_DATE="1412459685" PRIVATE="0" TOREAD="0" TAGS="clojure,stdlib,functions,category">Clojure Categorized</A>
<DD>Nice list of standard library categorized in a different way than the main website proposes. Is not up to date. I'm linking it here just in case one day I want to update it with the current stdlib fns. I can see a lot I never used or knew about.

<DT><A HREF="http://blog.n01se.net/blog-n01se-net-p-41.html" ADD_DATE="1412284501" PRIVATE="0" TOREAD="0" TAGS="clojure,history,cic,design">What is Clojure-in-Clojure?</A>
<DD>Amazed how far &quot;modern&quot; Clojure efforts like Clojure in Clojure can be tracked back in time. Clojure in Clojure was on of the focus after release 1.0. For that to happen, Rich envisioned the need for a &quot;newnew&quot; something sitting on top of lower level gen-class that made it easier to port the Java side of clojure. &quot;newnew&quot; then became deftype/defrecord and protocols later that year. One critical design decision was to not support what in Java is supported with abstract classes (but there is definterface just fine and some other trick to get around it). Wonder if this is was determined that Clojure in Clojure is not happening as a straight Java port but more as a rewrite these days.

<DT><A HREF="https://groups.google.com/forum/#!forum/sicp-mailonline" ADD_DATE="1412236031" PRIVATE="0" TOREAD="0" TAGS="clojure,sicp,book,group,me,mailonline">sicp-mailonline - Google Groups</A>
<DD>Announcing a new SICP study group starting next week in London. I organised another one a couple years ago and only managed to the to the 3rd chapter. This time I'd like to work on it with Clojure, my favourite language. If you're London based or you have friends in the area feel free to attend and spread the word.

<DT><A HREF="http://nbeloglazov.com/2014/09/23/gsoc-results.html" ADD_DATE="1412104849" PRIVATE="0" TOREAD="0" TAGS="clojure,gsoc,skummet,oxcart,profiler,analyzer">Clojure Google Summer of Code Results</A>
<DD>Here's a summary of the achievements for the Clojure projects during this Google Summer of Code. There have been three main focuses: performance improvements, typed clojure and extensions to core.matrix. Exciting results in the field of the Clojure compiler performances with Skummet and Oxcart testing ideas for different compilation profiles. Nicola Mometto extended his analyser to work for Clojurescript too. There are many other interesting projects to have a look at on the same post.

<DT><A HREF="http://www.dreamsongs.com/Files/amop-review.pdf" ADD_DATE="1412041992" PRIVATE="0" TOREAD="0" TAGS="clojure,amop,mop,clos,book,review,gabriel,steel,history,lisp">A Review of The Art of the Metaobject Protocol (PDF)</A>
<DD>You might have heard of the Art of the Metaobject Protocol, a book that describes the internals of CLOS, the Common Lisp Object System. The linked pdf is an essay written by Richard P. Gabriel about the context behind the book, some history of CLOS and a summary of the content. MOP is the inner-most layer of CLOS, where the way inheritance, extensibility and polymorphism behave are exposed as an API for you to extend. CLOS is both reflective and introspective. It is reflective in the sense that is defined in itself and introspective in the sense that it defines what is a class, a descendant of a class, a slot container and so on. It provides hooks to alter this semantic allowing the user to create a different OO system all together. Interesting final note: the authors of Scheme were creating new interpreters to understand OO arriving at the end at the conclusion that function calling is the same as message passing. Here we go, the grand unification theory of FP and OO!

<DT><A HREF="https://m.youtube.com/watch?v=oKg1hTOQXoY" ADD_DATE="1412039835" PRIVATE="0" TOREAD="0" TAGS="clojure,lisp,smalltalk,keynote,video,talk,kay,alan,oop,oopsla">Alan Kay at OOPSLA 1997 - The computer revolution hasnt happened yet - YouTube</A>
<DD>This Alan Kay's keynote enters my top 5 straight away with possibly the highest concentration of wisdom per slide. I can give you an overview here, but there is nothing more I can do, just go watch it now! My main takeaways are: OOP was intended as a paradigm to grow systems to unbelievable scale, the same of cells in a living organisms. It was misinterpreted in many ways, starting from C++ (many vitriolic comments) ending to Java without a decent meta-reflective system. In Kay's view, the number &quot;3&quot; could be implemented as a process with an IP and URL. But we can't manage that kind of scale. Our system are so complicated because we think small. Good words about Lisp CLOS and page 14 of the 1962 programmers manual by McCarthy, for its half a page description of the Lisp meta-reflective capabilities in Lisp itself. Much more.

<DT><A HREF="http://www.core-async.info/" ADD_DATE="1411718935" PRIVATE="0" TOREAD="0" TAGS="clojure,core.async,demo,tutorial,api,guide,reference">Get going with core.async: Get going with core.async</A>
<DD>Brand new core-async reference out there. Apart from a nice step by step tutorial (there are many around) the best part I think are the /reference/apidocs and /reference/primitives. The API reference is way better and readable than the standard one. The primitives section contains an interactive channel demo, a very nice learning tool.

<DT><A HREF="https://github.com/strangeloop/StrangeLoop2014/wiki/Coverage" ADD_DATE="1411568092" PRIVATE="0" TOREAD="0" TAGS="clojure,strangeloop,conference,scripts">Coverage · strangeloop/StrangeLoop2014 Wiki</A>
<DD>The official coverage page from StrangeLoop staff collects all the buzz surrounding the conference. Notably: the scripts of some of the talk to read are a useful addition, plus all blogging around the conference. Apparently I missed a great conference this year!

<DT><A HREF="http://podcasts.thoughtbot.com/giantrobots/93" ADD_DATE="1411562827" PRIVATE="0" TOREAD="0" TAGS="clojure,clojurescript,om,nolen,immutable,pointers">Diversity of Approach (David Nolen)</A>
<DD>Almost half of this podcast is dedicated to re-iterate on an important concept baked-in inside Om: fast diffing of nested data structures. Why it works is simple, but maybe David never tells the basic fact about what it means to be an immutable data structure in memory after all. It means that the head pointer of that data structure (or any of its sub-branches) is always the same and never changes. So if the language allows for some sort of view of into memory addresses (like Java does printing an instance with Object.toString()) if you change an element of a vector you get back another head pointer (and the previous is the same). Now, pointers aren't really transparent in Java or JavaScript, but this is conceptually what happens. So how long it takes to know if two immutable data structures are the same? Just compare the head pointers, which in Java is the double == operator. With this fast equality, application that requires intensive mutation on an in-memory data structure (the DOM for example) have a way to be really fast.

<DT><A HREF="http://podcasts.thoughtbot.com/giantrobots/111" ADD_DATE="1411562308" PRIVATE="0" TOREAD="0" TAGS="clojure,lighttable,excel,declarative,programming,analysts,business,startup,podcast,audio">Thinking Outside the Loop (Chris Granger)</A>
<DD>I like Chris Granger (of LightTable fame). He's got big ideas and he delivers them. In this podcast Chris explains the path that brought him from user interaction testing at Microsoft, to LightTable live-coding environment, to experimenting with Aurora prototype down to the new startup is that is soon to be launched. The problem he's trying to solve is how to have what we usually call business analysts to be able to code without being actually programmers. Is that even possible? Well, think about Excel. The future is declarative and visual and this is what Chris is working on, a new visual language that evolves Excel into a real programming environment. Inspiring. In the show notes, the link to the paper that inspired him in this new challenge.

<DT><A HREF="https://www.youtube.com/watch?v=EjCWdsrVcBM" ADD_DATE="1411561679" PRIVATE="0" TOREAD="0" TAGS="clojure,video,strangeloop,wolfram,language">&quot;Inside the Wolfram Language&quot; by Stephen Wolfram - YouTube</A>
<DD>Another interesting talk from StrangeLoop this year. What Stephen Wolfram is showing us with his language is frankly mind blowing. It's not about the language itself I think (which resembles a Lisp on square brackets), but more about the IDE and the environment it works in. It can apparently represent anything, from image to sounds, internet to pdf reports, deploy to the cloud or iphone, generate other languages or REST Apis. An interesting question would probably be what it *cannot* do. It is certainly inspiring as a live programming environment (like LightTable on steroids) and as a all-around scratch pad for anything research oriented. As of real-world every-day programming I don't think so. It seems to be closed-source, closed-world that you are going to lock yourself in.

<DT><A HREF="http://www.youtube.com/watch?v=6mTbuzafcII" ADD_DATE="1411555128" PRIVATE="0" TOREAD="0" TAGS="clojure,talk,video,strangeloop,rich,transducers,reducers">&quot;Transducers&quot; by Rich Hickey - YouTube</A>
<DD>Another great talk by Rich from Strange Loop 2014 conference. Transducers implement an elegant functional abstraction that enables &quot;packaging&quot; of data transformation logic that can be re-used. Personally I don't perceive them as revolutionary or ground-breaking though. I would like to see Reducers to be retrofitted to make good use of transducers chains (if that is not possible already) so the two features (transducers and reducers) can effectively be seen as part of a consistent design.

<DT><A HREF="https://tbaldridge.pivotshare.com/" ADD_DATE="1411405594" PRIVATE="0" TOREAD="0" TAGS="clojure,videos,screencasts,core.async,baldrige">Clojure Tutorials - with Tim Baldridge</A>
<DD>Highly instructive series of screencasts from Tim Baldridge of core.async (and much more) fame. He keeps them coming at an amazing speed, 2/3 per week of about 10-15 mins each and considering the 4$/monthly it is a steal. The quality is also very good. I watched a couple of them and I've been impressed. There is also an option to access them on dropbox as mp4 that makes them very handy on troubled connections.

<DT><A HREF="http://om-bootstrap.herokuapp.com/" ADD_DATE="1411379080" PRIVATE="0" TOREAD="0" TAGS="clojure,clojurescript,om,reactive,bootstrap,web">Om Bootstrap</A>
<DD>Interesting port of Bootstrap into ClojureScript Om already in a reasonable working state. Expanding a little bit on the concept, it means to translate the JavaScript part of Bootstrap into ClojureScript and migrate those components to Om including all the reactive goodness. What impact it can have on Bootstrap itself as a normal user is hard to say, but it is probably important if you want to interact or extend with the Bootstrap components from within your application.

<DT><A HREF="http://www.learndatalogtoday.org/" ADD_DATE="1410972639" PRIVATE="0" TOREAD="0" TAGS="clojure,datomic,datalog,tutorial">Learn Datalog Today!</A>
<DD>Notable initiative. Despite being some 30 years old, Datalog is not as known as the distant cousin SQL. It has a steep learning curve if you never touched any Prolog or being exposed to rule engines and there is a lack of modern approaches on how to learn it, especially step by step guides. These days Datomic is proposing Datalog as the main query language. This website seems that missing resource including nice exercises at the bottom. Thanks to Jonas Enlund and the summer rain of 2013 for putting this together.

<DT><A HREF="http://www.amazon.com/Clojure-Bookshelf/lm/R3LG3ZBZS4GCTH/ref=cm_lm_byauthor_title_full" ADD_DATE="1410820047" PRIVATE="0" TOREAD="0" TAGS="clojure,books,rich,list,amazon">Amazon.com: Clojure Bookshelf</A>
<DD>I knew about the Clojure bookshelf but never bookmarked here. This is Rich Hickey's collection of recommended books, including the indispensable hammock for a more comfortable reading experience. They are recommended in the sense that they were in Rich's reading list starting before the first Clojure work and somehow contributed to this successful language. Definitely have a look here for some background on some the most advanced Clojure features.

<DT><A HREF="http://podcasts.thoughtbot.com/giantrobots/115" ADD_DATE="1410798249" PRIVATE="0" TOREAD="0" TAGS="clojure,podcast,audio,oo,fp,mathematica,wolfram">There's a Spectrum Involved Here (Brandon Bloom)</A>
<DD>I was a long time listener of GiantRobots podcast back when I was into Rails and then stopped listening at some point. I rediscovered recently many interesting interviews are going on there, including people from the Clojure and functional community. Like this episode with Brandon Bloom that I know by fame on IRC and the mailing list. He likes to get things out quickly and this approach reflects in his language toolset. He likes to start playing with an idea with rule based languages like Mathematica. He prefers more structure with dynamic functional languages (Clojure) and only add typing later on (if needed). OO is also considered but not design the entire system. In this sense OO is very good ad describing closed systems (what happens inside an object) but it gets difficult to manage when too many interactions happen (the entire system). The spectrum in the title is any dogmatic approach to development where a language or framework is used out of context.

<DT><A HREF="https://groups.google.com/forum/m/#!msg/comp.lang.lisp/HQFMhGrKrcg/wJwhkvc4O8gJ" ADD_DATE="1410732262" PRIVATE="0" TOREAD="0" TAGS="clojure,lisp,ant,colony,simulation,example,stm,concurrency">Ants: Clojure vs. Common Lisp - Google Groups</A>
<DD>From the oldie but goodie series, this is a juicy discussion on comp.lang.lisp about advantages and potential pitfalls of software transactional memory implementations. It all start with Pascal Costanza (of Lisp fame) reproducing the ant colony example in Lisp using locks and the claim that is not that complicated to reproduce Clojure features. Of course Rich chimes in right after. What the ant colony example can achieve is not clear at first sight, but the fact that it doesn't deadlock or waste system resources is something that is not easy to achieve.

<DT><A HREF="https://gist.github.com/reborg/3e241b1dc8bf8ace0bcb" ADD_DATE="1410539186" PRIVATE="0" TOREAD="0" TAGS="clojure,pdf,papers,cs,theory,computer,science">PDF Links #Clojure IRC</A>
<DD>Crowd sourced PDFs from the very special people in the Clojure IRC channel. Some of them are not relevant (see Object Oriented Cobol book!) but on average the CS papers mentioned here constitute the theoretical basis of many of the Clojure features. There are also papers from other languages for feature comparison, interesting  slides from talks and much more. I'd really love to do something similar using the clojure-ml as a source if such an archive existed somewhere!

<DT><A HREF="https://github.com/palletops/lein-uberimage" ADD_DATE="1410538368" PRIVATE="0" TOREAD="0" TAGS="clojure,docker,automation,image,distribute,uberjar">palletops/lein-uberimage</A>
<DD>Interesting stuff. This creates a Docker image to run your Clojure app. Useful to distribute a JVM with the app, something that is not always a given for all platforms. I assume you can also customise the created docker image to get other stuff on board, like Redis or ElasticSearch. That is much easier to distribute than install every time!

<DT><A HREF="http://cdn.cognitect.com/presentations/2014/insidechannels.pdf" ADD_DATE="1410509858" PRIVATE="0" TOREAD="0" TAGS="clojure,euroclojure,rich,core.async,channels,slides,pdf,talk">[PDF] Inside Channels - EuroClojure 2014 - Rich Hickey</A>
<DD>I was there watching the talk live, but this talk Rich gave at EuroClojure is very dense and deserve a few more passes. Also because there were technical problems synching the slides, the only way you have to watch Rich giving the talk and also look at the slides is to use this pdf that Alex Miller made available on the clojure ML.

<DT><A HREF="http://blog.cognitect.com/cognicast/061-matthew-flatt" ADD_DATE="1410508333" PRIVATE="0" TOREAD="0" TAGS="clojure,racket,scheme,macros,syntax">Matthew Flatt - Cognicast Episode 061 — Cognitect Blog</A>
<DD>This Cognicast with Matthew Flatt is full of goodies. I've used Dr.Racket and Racket a bit for my SICP studies and I've been impressed by what IDE can achieve (and what I'd really love to use daily for my Clojure dev). Racket is a Scheme dialect and it doesn't run on top of the JVM. This means 20+ years of complete freedom to evolve the language in any possible direction, including things that Clojure can't support (like TCO or continuations). I like to think that Racket is what Clojure could evolve into (in terms of features) if there were no JVM constrains. Matthew is concentrating lately on the macro system that he's got idea how to re-implement from scratch. Something they've done already is the complete access to the compiler view of the scope at macro-expansion time, something that resemble an compiler-API that is used both at compile time and runtime.

<DT><A HREF="https://github.com/clojure/clojure/blob/master/src/clj/clojure/core.clj#L7233" ADD_DATE="1410356369" PRIVATE="0" TOREAD="0" TAGS="clojure,1.7,new,dedupe,transducers,duplicates">dedupe - clojure 1.7</A>
<DD>Randomly selecting bits of the soon to be released Clojure 1.7. dedupe iterates through a collection keeping only one of the potentially consecutive duplicates found in coll. So: (dedupe (interleave (range 10) (range 10))) is again (range 10). As many other collection functions also dedupe gets the transducers treatment. When invoked without arguments returns a transducer that can then be stack up in a chain.

<DT><A HREF="https://gist.github.com/richhickey/b5aefa622180681e1c81" ADD_DATE="1410341673" PRIVATE="0" TOREAD="0" TAGS="clojure,gist,transducers,reducers,recipe,iteration">transducerfun.clj</A>
<DD>This Gist by Rich gives an example of what can be done with transducers, staking up a pile of operations in the xform transducer to be used in many possible ways: making it a normal lazy sequence, creating a recipe over specific data (with iteration), reducing it or making it into a vector (no laziness) or using it in a core.async channel. If you want to try the snippet on master, just replace flatmap with mapcat.

<DT><A HREF="http://blog.cognitect.com/cognicast/062-eric-normand" ADD_DATE="1410161195" PRIVATE="0" TOREAD="0" TAGS="clojure,gazette,eric,normand,podcast,audio,lisp,haskell">Eric Normand - Cognicast Episode 062 — Cognitect Blog</A>
<DD>Interesting episode with Eric Normand of Lispcasts and Clojure Gazette fame. Eric has an amazing background. He did common lisp extensively and a couple of years of Haskell professionally and now he's concentrating purely on Clojure. With that background the amount of links to good literature that Eric gives is amazing (on this podcast and on the Gazette) as it is his point of view about typed and dynamic functional languages. His last effort is http://www.purelyfunctional.tv, a continuation on his educational activity started with Lispcasts.

<DT><A HREF="http://grimoire.arrdem.com/1.6.0/clojure.core/counted_QMARK/" ADD_DATE="1409922559" PRIVATE="0" TOREAD="0" TAGS="clojure,stdlib,counted?,counted,length,type,time">counted? - Clojure Documentation</A>
<DD>counted? function in the standard library is one of those about capabilities of data structures. It returns true if you can execute a count on a collection in constant time. But without looking at the sources it is quite confusing. For example counted? on an a java array of ints will return false, but it invokes Java native length underneath that is of course constant time. So the interpretation is more: if coll is a Clojure collection it tells you if it counts in constant time, if it's not a Clojure collection it will always return false. The source is indeed just checking that the type implements the interface Counted.

<DT><A HREF="http://www.oracle.com/technetwork/java/javase/community/jlssessions-2255337.html" ADD_DATE="1409836389" PRIVATE="0" TOREAD="0" TAGS="clojure,talks,java,jvm,summit,optimisation,internals,datomic">JVM Language Summit 2014</A>
<DD>The JVM language summit conference is mainly about language implementations on the JVM and low level features that Clojure programmers are not supposed to be interested in. Anyway if you are interested in the kind of stuff Clojure can take advantage of in the new releases to be better and faster these videos/slides are for you. You can also go back 3 years worth of content. Pay particular attention to Guy Steele, Cliff Click, John Rose. Rich Hickey is present with Datomic in 2012. Happy viewing.

<DT><A HREF="http://dev.clojure.org/display/design/Feature+Expressions" ADD_DATE="1409763489" PRIVATE="0" TOREAD="0" TAGS="clojure,feature,new,wiki,discussion">Feature Expressions - Clojure Design - Clojure Development</A>
<DD>Feature Expressions is currently a “maybe” Clojure feature which is under discussion on the wiki (along many others). The idea is borrowed from the equivalent Common Lisp feature that solves the problem of targeting different platforms with custom language constructs so a specific expression will be compiled only when on a specific platform. Clojure has been ported to at least three major platforms, the JVM, .NET CLR and JavaScript engines and still offers close relationship with the hosting platform, allowing for specific host expressions (java interop is quite powerful for this reason). A similar approach was attempted successfully with lein/cljx.

<DT><A HREF="https://vimeo.com/100518965" ADD_DATE="1409762499" PRIVATE="0" TOREAD="0" TAGS="clojure,talks,video,euroclojure,2014,talk,me">The Compiler, the Runtime and other interesting &quot;beasts&quot; from the Clojure codebase - Renzo Borgatti on Vimeo</A>
<DD>After some delay, all the EuroClojure talks videos are now available, including mine that is linked here. Pity that there is no slide to screen sync, since I’ve used animations for code scrolling that won’t be visible. Many people told me it was an interesting talk, go see yourself. :)

<DT><A HREF="http://blog.gmarceau.qc.ca/2009/05/speed-size-and-dependability-of.html" ADD_DATE="1409760741" PRIVATE="0" TOREAD="0" TAGS="clojure,functional,fp,paradigm,speed,fast,benchmarks">Guillaume Marceau: The speed, size and dependability of programming languages</A>
<DD>This is the amazing result of comparing 33 languages over 429 programs. Each program has been written in each language and the article compares size (LOC) and speed. If you look at the results of functional languages, the conclusion is that being functional does not have an impact on performances. The biggest impact on speed is how mature the runtime of the language is. So there are languages that are really expressive but not a lot of investment was done to make them faster and the other way around. Sweet spots are for example Lua and Haskell.

<DT><A HREF="http://www.viva64.com/en/b/0260/print/" ADD_DATE="1409758533" PRIVATE="0" TOREAD="0" TAGS="clojure,bug,test,copy,paste">The Last Line Effect</A>
<DD>An interesting point of view is described in this article, somebody who search bugs professionally but is not really a tester. The kind of bug described here has to do with the copy paste of single lines to repeat the same behaviour with different values. The article claims that bugs in the last of this mechanical repetition are 4 times more common. Not strictly Clojure related, but my thinking here is that this bug is typical with imperative programming and much less of a concern with FP, where with immutable structures the same code is written concatenating functions.

<DT><A HREF="https://clojurecup.com/#/" ADD_DATE="1409754054" PRIVATE="0" TOREAD="0" TAGS="clojure,clojurecup,competition,rumble,rails">Clojure Cup 2014</A>
<DD>Another edition of the ClojureCup is coming this year, 27-28 sept, with sing-up starting in 3 days. This is a coding competition where teams have 48 hours to complete a (web or otherwise) Clojure app. If you have a weekend to spare and some idea with you and your colleagues this is the perfect time to signup and code some Clojure and maybe push even higher and create your own startup.

<DT><A HREF="https://www.kickstarter.com/projects/1751759988/sicp-distilled" ADD_DATE="1409739563" PRIVATE="0" TOREAD="0" TAGS="clojure,sicp,learning,book,tutorial,screencast">SICP Distilled by thattommyhall — Kickstarter</A>
<DD>Worth mentioning that Tommy Hall is organising these screencast series (and possibly other formats) about the content of this popular book, using Clojure as the main dialect. The goal is to distill the most important part of SICP making it easier to access a book that is conceptually very dense. You don't need to pledge a huge amount of money to make this happen, so please go ahead and contribute.

<DT><A HREF="http://cufp.org/2014/" ADD_DATE="1409730212" PRIVATE="0" TOREAD="0" TAGS="clojure,FP,conference,CUFP">CUFP</A>
<DD>I heard about CUFP (Commercial Users of Functional Programming) conference a little too late to be useful for this post, but it sounds like an interesting conference to track about FP. There is no Clojure presence as far as I can see, but this could change next year. The list of tutorials is extremely interesting, with presence of all major and some esoteric language as well. Will have a look after the conference to see if videos of the talk are available.

<DT><A HREF="http://grimoire.arrdem.com/1.6.0/clojure.data/diff/" ADD_DATE="1407950189" PRIVATE="0" TOREAD="0" TAGS="clojure,stdlib,tools,lib,diff">clojure.data/diff - Clojure Documentation</A>
<DD>For the unknown pearls in the standard library, this week I'd like to introduce you to clojure.data/diff. This namespace seems dedicated to diff because the other functions seem to be internal implementation details. This is a polymorphic diff that based on the input params is doing its best to return the diff as seen from both sides and the actual difference as the third part of the results. It can be used for all sort of useful stuff related to comparing data structures with a result that is easy to process.

<DT><A HREF="http://www.functionalgeekery.com/episode-13-martin-j-logan/" ADD_DATE="1407941325" PRIVATE="0" TOREAD="0" TAGS="clojure,erlang,actors,agents,podcast,audio">Functional Geekery Episode 13 – Martin J. LoganFunctional Geekery | Functional Geekery</A>
<DD>This FG episode is about Erlang, sorry to file it under Clojure stuff. But it is an interesting and entertaining episode with Martin Logan, an Erlang veteran, illustrating a bit of history of the language and its community. Although Clojure doesn't embrace the actor model as a fundamental concurrency construct, there is certainly inspiration coming from that with agents in Clojure and they both share immutability as their core principle. Also consider a quick look at Elixir, a modern take to Erlang with a more Ruby-like syntax.

<DT><A HREF="http://grimoire.arrdem.com/1.6.0/clojure.core/promise/" ADD_DATE="1407940408" PRIVATE="0" TOREAD="0" TAGS="clojure,concurrency,future,promise,core.async,blocking,queue">Promise - Clojure Documentation</A>
<DD>Promises is another Clojure construct to help in creating powerful concurrency models. It doesn't contain behaviour for a computation (like futures) but it is just delivered results with deliver. Promises are often found in conjunction with futures since the behave like single-entry blocking queues. The future can deliver to a promise that is passed in when the future is created and the main thread can at some point block while deref the promise. The advantage is that you don't need to code any nasty &quot;wait&quot; semantic (like futures). There is also another important aspect of combining futures and promises this way: the callback fn can be generic and the result handled to the promise in-situ, creating the semantic of a synchronous call. The same happens as well in core.async, but the thread where the computation is running is non-blocking.

<DT><A HREF="https://skillsmatter.com/skillscasts/4073-dissecting-reducers" ADD_DATE="1407588705" PRIVATE="0" TOREAD="0" TAGS="clojure,reducers,transducers,talk,video,skillsmatter,me,reborg">Dissecting Reducers - Skills Matter</A>
<DD>If you're struggling understanding the new transducers primitives that Clojure 1.7 will be introducing, I strongly suggest you get your self familiar with Reducers first, because the implementation of the transforming reducers (map, filter etc) is exactly the same. This is also a very nice example of functional abstraction or &quot;pattern&quot; approach to functional programming that is worth dissenting in deep. What I've linked here is a talk (30') I gave last year about reducers from the point of view of functional abstractions (more than the parallelism they introduce with fold).

<DT><A HREF="http://ianrumford.github.io/blog/2014/08/08/Some-trivial-examples-of-using-Clojure-Transducers/" ADD_DATE="1407588399" PRIVATE="0" TOREAD="0" TAGS="clojure,reducers,transducers,functional,patterns,idiomatic">Some trivial examples of using Clojure Transducers - An Ostler in IT</A>
<DD>Of all the transducers buzz I've found around I've selected the following post because it's mainly examples. Like the author of the post, I've also found transducers a natural evolution of reducers and after I went beyond the new lingo I felt myself home again. One important difference that you can clearly see here, is that reducers are not able to apply a pipeline of transformations without actually &quot;reduce&quot; the collection. The only way to achieve that effect is with &quot;into&quot; that uses reduce internally completely throwing away laziness. Transducers effectively abandons the intimate relationship with reduce (and fold).

<DT><A HREF="http://www.digitalcld.com/cld/recommended-reading-microservices-architectures-and-clojure/" ADD_DATE="1407319979" PRIVATE="0" TOREAD="0" TAGS="clojure,services,architeture">Recommended Reading : Microservices Architectures and Clojure (A Quick Survey of Resources) | Architecting Beyond Twenty Twenty</A>
<DD>In this post you can find a list of micro services related material (presentations, videos, articles) with a specific focus on Clojure solutions. Why all this interest about micro or nano services? Because it adds quite a bit of freedom in terms of composability and scalability of a system. Micro services are also easier to deploy compared to a monolith application, where keeping track of what is going live isn't an easy task at all. Clojure is perfect platform for micro services, because it's dynamic (quicker feedback loop), run on the JVM (widespread) and contains mature deploy tooling and monitoring (including everything that was developed for Java already).

<DT><A HREF="https://github.com/Prismatic/eng-practices" ADD_DATE="1407246907" PRIVATE="0" TOREAD="0" TAGS="clojure,prismatic,craftsmanship,practice,engineering">Prismatic/eng-practices</A>
<DD>Thanks for sharing Prismatic! These are interesting and detailed readings about the engineering practices Prismatic has been implementing and evolving on the field. This is the main reason they are concise and to the point. You can find here at the moment some elaborate discussion about Clojure type of polymorphism, namespace organisation and testing. Not strictly related to Clojure but definitely worth a reading as well: Prismatic git workflow and iOS profiling.

<DT><A HREF="https://github.com/bellkev/dacom" ADD_DATE="1407188799" PRIVATE="0" TOREAD="0" TAGS="clojure,leiningen,sample,template,project,deploy">bellkev/dacom</A>
<DD>A Datomic, Compojure, Chors, core.async, Om stack ready to hack with. If you resist the temptation to update the dependencies to the latest and greatest (please do yourself a favour and don't touch them until you're missing a feature) this project works out of the box and contains a working stack with the above technology nicely integrated and automated. It uses Bower, Boostrap and LessCss to automate the client side and it also contains lein tasks to prepare and initialise the Datomic instance and Austin integration for ClojureScript. If you don't like the idea of cloning it, just go for the &quot;lein new dacom&quot; template and the app will get your name. Well done.

<DT><A HREF="https://github.com/johnwayner/lein-datomic" ADD_DATE="1407185379" PRIVATE="0" TOREAD="0" TAGS="clojure,datomic,leiningen,plugin">johnwayner/lein-datomic</A>
<DD>If you prefer just Datomic automation, this small plugin contains a few useful tasks integrated with leiningen. Given an existing project it adds commands like the Datomic instance start or re-initialisation with the schema configured in project.clj. Documentation is essential but clear. Also easy to fork and extend.

<DT><A HREF="http://annapawlicka.com/common-mistakes-to-avoid-when-creating-an-om-component-part-1/" ADD_DATE="1407140545" PRIVATE="0" TOREAD="0" TAGS="clojure,clojurescript,om,react,reactive,pifalls">Anna Pawlicka | Common mistakes to avoid when creating an Om component. Part 1.</A>
<DD>Nice collection of Om pitfalls, things that are easy to not understand correctly and (usually) silently fail. At least, this is also my initial experience with Om and ClojureScript. One part of the &quot;fragile&quot; impression is definitely the learning curve, which includes something that is similar to a new programming paradigm (reactive programming is a little bit, especially if you add lifecycle events to deal with state changes). But the other part is more about the fact that the technology is really young and tooling around it fails if you use a different minor version.

<DT><A HREF="http://grimoire.arrdem.com/1.6.0/clojure.core/gen_DASH_class/" ADD_DATE="1406109645" PRIVATE="0" TOREAD="0" TAGS="clojure,aot,gen-class,interop,java,stdlib">clojure.core/gen-class · Grimoire</A>
<DD>gen-class creates a Java class and spits that to disk. It can be instructed with all sort of Java goodies, like implemented interfaces, methods, ctor plus some goodies like a post-init constructor. One of the main reasons of gen-class is Java interoperability, where it is important that the class is not generated on the fly in a deeply nested classloader and is reachable through normal class path lookup such as Class/forName calls. gen-class has only value during AOT compilation and does nothing at the REPL.

<DT><A HREF="https://news.ycombinator.com/item?id=8069346" ADD_DATE="1406103562" PRIVATE="0" TOREAD="0" TAGS="clojure,transit,thrift,format,json,edn">Transit – A format for conveying values between different languages | Hacker News</A>
<DD>Transit is a new data transfer format from the Cognitect crew. What it offers and what adds to the plate of an already rich horizon of data transfer format was not clear to me after reading the official presentation page. As usual HN does a great job comparing with the existing stuff and hence my link to it. Rich, Fogus and Swanndonnette are all in the thread, so you can see that the competitive advantage of Transit over other formats seems to be about the compression mechanism, pluggable human-readability, json interoperability and the extension mechanism. EDN isn't deprecated or anything like that, but it sounds like for future work you better look at Transit instead.

<DT><A HREF="https://github.com/cemerick/austin" ADD_DATE="1405672911" PRIVATE="0" TOREAD="0" TAGS="clojure,clojurescript,repl,browser,phantomjs,headless,dev">cemerick/austin</A>
<DD>Austin is the glue between the lein building process of a ClojureScript based project and the browser. With Austin things like evaluation of ClojureScript in the repl is possible, with several options, headless or fully integrated with Chrome for example. I think the most compelling use case during development is making a change and have the browser to automatically update the changes, no refresh required. Other compelling reason is full access to the dom at the repl for debugging and experimentation.

<DT><A HREF="http://james-iry.blogspot.co.uk/2009/05/brief-incomplete-and-mostly-wrong.html" ADD_DATE="1405635099" PRIVATE="0" TOREAD="0" TAGS="clojure,history,humour,languages">One Div Zero: A Brief, Incomplete, and Mostly Wrong History of Programming Languages</A>
<DD>Totally cracked up by this humorous history of programming languages :) All the stereotypes are there. Probably the one I liked the most is Perl. I think ARC got mentioned instead of Clojure because in 2009-ish it was still considered the new Lisp. History turned out to be different.

<DT><A HREF="http://www.cliki.net/Naming conventions" ADD_DATE="1405634161" PRIVATE="0" TOREAD="0" TAGS="clojure,convention,naming,functions,cl,lisp">CLiki: Naming conventions</A>
<DD>These are the naming convention guidelines you were all waiting for! It's common lisp, but hey, it is not that different from the same kind of naming conventions of  Clojure sources. Of course they are not all applicable, but they help a lot giving just a bit of semantic to a function name in case Clojure doesn't.

<DT><A HREF="http://okasaki.blogspot.de/2008/02/ten-years-of-purely-functional-data.html?m=1" ADD_DATE="1405531474" PRIVATE="0" TOREAD="0" TAGS="clojure,books,okasaki,structures,persistent,data,ml,ocaml">Okasaki: Ten Years of Purely Functional Data Structures</A>
<DD>A blog post from Okasaki, author of Purely Functional Data Structures, describing the history behind the book that is still popular these days. Okasaki also answers a few frequently asked questions. StandardML was selected for specific reasons related to its control of lazy VS strict evaluation but it won't be the same choice today: the book would likely be re-written in OCaml. Why not a dynamically typed language? Because Okasaki thinks that functional data structures are better explained when types are explicit. Just in case you don't know, Clojure is implementing and extending some of the persistent data structures described there (in Java). If you want a preview of the book before buying, keep in mind that Okasaki's thesis is available online with a very similar content. Worth learning SML just to follow this book! Unfortunately, no 2nd edition is in sight.

<DT><A HREF="http://stackoverflow.com/questions/14488150/how-to-write-a-dissoc-in-command-for-clojure" ADD_DATE="1405530097" PRIVATE="0" TOREAD="0" TAGS="clojure,stdlib,core,dissoc,map,keys">How to write a dissoc-in command for clojure? - Stack Overflow</A>
<DD>There is no dissoc-in in the standard library. There used to be one in clojure.contrib that got dispersed when libraries entered their own repos. But it is also simple to replicate with an update-in as suggested in this SO answer. You just need to stop one key before in the list of inner keys and add it to a dissoc invocation for the corresponding map: (update-in {:a {:b 0 :c 1}} [:a] dissoc :b)

<DT><A HREF="http://www.functionalgeekery.com/episode-12-adi-bolboaca/" ADD_DATE="1405443075" PRIVATE="0" TOREAD="0" TAGS="clojure,convention,naming,code-retreat,clean-code,cleancode,style,lisp,abstraction">Functional Geekery Episode 12 – Adi BolboacaFunctional Geekery | Functional Geekery</A>
<DD>Controversial (in a good sense) Functional Geekery episode. When speaking about style and idiomatic Clojure, I tend to be inspired by one of the most popular source of Clojure wisdom: clojure/core.clj. The style there leans toward essentiality, where variable names are just a few letters and they tend to follow an implicit convention (f, g are function names, xs is a collection of x and so on). But uncle Bob clean-code style is much more verbose in that respect, suggesting more speaking names. I agree with all the rest of the discussion, in term of SOLID principles applied to FP and the overall idea to dedicate a code-retreat format to FP style programming. But I'm not sure about naming. What determines understandability in a language is also the culture and conventions that are stratified into it. Clojure is inspired by CL in many ways, including naming and it looks unproductive to me to try to change 50+ years of conventional wisdom to another convention.

<DT><A HREF="http://grimoire.arrdem.com/1.6.0/clojure.core/rseq/" ADD_DATE="1405430676" PRIVATE="0" TOREAD="0" TAGS="clojure,rseq,stdlib,sort,reverse">rseq · clojure.core</A>
<DD>For the &quot;standard library in small pills&quot; series, here's the mostly unknown rseq. It works like seq, transforming something sortable into a sequence but at the same time it is reversing its order. Use cases? None at hand, but consider that it is doing it O(1). How can it be? Little trickeries: the PersistentVector underneath is unchanged, but is wrapped in an RSeq object that is counting backward when next() is required, starting from the end! Good luck garbage collector when I unroll 1M of these :)

<DT><A HREF="http://stackoverflow.com/questions/4839013/how-does-clojures-defrecord-method-name-resolution-work" ADD_DATE="1405410765" PRIVATE="0" TOREAD="0" TAGS="clojure,defprotocol,defmethod,clos,oop,oo,paradigm">protocols - How does clojure's defrecord method name resolution work? - Stack Overflow</A>
<DD>Enlightening quick SO answer from Christophe Grand about potential name clashing in protocol definitions. defprotocol and defrecord are a powerful tool provided by Clojure to replicate some object oriented runtime polymorphism. They've got rough edges as soon as you start pushing too far with them, something you can experience if you try to port a complex object model from Java &quot;literally&quot;. defprotocol for instance, creates the function definitions inside the namespace they are declared in, with the consequence that there shouldn't be other &quot;normal&quot; functions with the same name and no other protocols definitions with the same name, let alone using function names from clojure.core. At the same time if you define protocols in different namespaces you can incur in weird require+import constrains to use them in other places. Add the fact that other than the basic examples, there is no throughout guide to &quot;build yourself a CLOS in Clojure&quot;. We can certainly discuss if this is needed at all...

<DT><A HREF="https://github.com/jakemcc/lein-test-refresh" ADD_DATE="1405361138" PRIVATE="0" TOREAD="0" TAGS="clojure,testing,ut,midje,core.test,lein,plugin,autotest">lein test-refresh</A>
<DD>If only I knew about this a couple months ago... I wouldn't have ported the test suite to Midje with autotest, my favourite unit test framework. Or maybe not, because I'm quite fluent with the Midje API and got used to the expressiveness it can provide. Anyway, if you are on clojure.test, this lein plugin is an automatic runner that runs in the background and send you notifications about the status of the tests while you are typing in the editor. It is my favourite workflow at the moment, which includes the REPL running for experimentation and solutions while the overall functional interface is driven by tests. I don't use the same for legacy code, where somebody else wrote it, although I tend to cover &quot;after&quot; with test the part I don't understand.

<DT><A HREF="http://learnlispthehardway.org/" ADD_DATE="1405112531" PRIVATE="0" TOREAD="0" TAGS="clojure,lisp,book,zed,shaw,learning">L(λ)THW Learn Lisp The Hard Way</A>
<DD>Interesting initiative that could be ported to Clojure and has already been ported many times to many languages. Zed Shaw started it all (I think it was Learn C The Hard Way) and then produced another bunch of them. The template to write books using the same style is publicly available and Zed Shaw is encouraging others to write their own. This is the &quot;brave&quot; Lisp attempt, considering the amount of top quality books around about programming in Lisp. The author explained the effort behind this achievement on HackerNews. This is not a couple of days project and it is coming out nicely. Remember the following rule of thumb: learning Lisp is providing you the all principle (and often nomenclature and conventions) behind Clojure.

<DT><A HREF="http://grimoire.arrdem.com/1.6.0/clojure.core/cycle/" ADD_DATE="1404995994" PRIVATE="0" TOREAD="0" TAGS="clojure,take,cycle,repeat,list,zebra,round-robin">clojure.core/cycle</A>
<DD>Cycle is similar to clojure.core/repeat, but it operates on a sequence by recursively merging it to a copy of itself, ad infinitum. Cycle is your friend on things that needs to be provided in a round-robin fashion, including assignment of a finite set of identifiers or simply creating a css zebra list of some sort. Repeat is less useful here since it will repeat a single item instead. Always use with clojure.core/take on front!

<DT><A HREF="http://adambard.com/blog/greatest-clojure-hits/" ADD_DATE="1404887769" PRIVATE="0" TOREAD="0" TAGS="clojure,beginner,articles,posts,collection,begin">My Top Clojure Articles - Adam Bard and his magical blog</A>
<DD>Signalling a nice collection of Clojure related articles by Adam Bard. They are divided by level of proficiency with the language, so it makes it a very good start to pick up Clojure from scratch.

<DT><A HREF="http://vimeo.com/euroclojure/videos" ADD_DATE="1404859673" PRIVATE="0" TOREAD="0" TAGS="clojure,euroclojure,2014,videos,talks,conference">EuroClojure’s Videos on Vimeo</A>
<DD>Unless they are already displayed when you read this, keep an eye on the EuroClojure channel on Vimeo because videos will appear very soon here. Go for David Nolen for the inspirational talk, Tommy Hall for the entertaining one or yours truly (Renzo) because this is a shameless plug!

<DT><A HREF="http://thoughtworks.fileburst.com/assets/technology-radar-july-2014-en.pdf" ADD_DATE="1404836330" PRIVATE="0" TOREAD="0" TAGS="clojure,clojurescript,om,react,radar,tw,thoughtworks">Thoughtworks technology radar</A>
<DD>The last technology radar sees ClojureScript in the trial phase, up to the top close to the adopt section. Clojure the core language is not present, but just because it was in the adopted section last Radar issue. Om/ClojureScript is present also in the explanation notes. There are other well known technologies and platforms, but there are also new entires I'd like to have a look at.

<DT><A HREF="http://www.arrdem.com/grimoire/" ADD_DATE="1404818664" PRIVATE="0" TOREAD="0" TAGS="clojure,documentation,community,docs,clojuredocs">Grimoire</A>
<DD>Grimoire is a new documentation service and community contributed example repo similar to ClojureDocs.org. ClojureDocs.org still comes up high in google searches despite it is documenting Clojure 1.3, by providing examples that are not easy to find elsewhere. Grimoire is instead up to date and also gives access to all the examples in clojuredocs. Grimoire is open to community contribution over git pull requests and will likely be improved in the future to make contributions easier.

<DT><A HREF="https://groups.google.com/forum/#!msg/clojure/zfd0Mj6JLXY/AWPzUsUf01MJ" ADD_DATE="1404807509" PRIVATE="0" TOREAD="0" TAGS="clojure,extend,extend-type,protocols">Difference between defrecord and extend - Google Groups</A>
<DD>This interesting thread finally solved my problem. Extending a type to a protocol is *not* equivalent to a defrecord definition that implements that same protocol. They generate different kind of polymorphism. The first main difference is that extending a type with a protocol is not adding functions to its interface (and this you can't invoke them on a record instance). Second main difference is that extending the type with a protocol allows for an implementation swap at any point, while defrecord definition of functions are forever.

<DT><A HREF="http://clojure.org/todo" ADD_DATE="1404718316" PRIVATE="0" TOREAD="0" TAGS="clojure,history,todo,2009,future,long">Clojure - todo</A>
<DD>Another small bit of history, a Clojure todo list back from 2009. Is not very important today but I want to keep an handle to things I discover randomly just in case. Interesting to notice that 90% of what we are talking about nowadays with faster compilers for mobile or Cloj in Cloj were already there. Others like Datalog were not baked in directly in the language but in Datomic.

<DT><A HREF="http://us4.campaign-archive.com/?u=a33b5228d1b5bf2e0c68a83f4&id=4e6baaf423" ADD_DATE="1404497382" PRIVATE="0" TOREAD="0" TAGS="clojure,compiler,mometto,cic,porting">Clojure Gazette 1.81 - Nicola Mometto</A>
<DD>I'm very interested in everything compiler related these days and of-course I'm following the amazing work Nicola is doing to port Clojure in Clojure. This Clojure Gazette is an interview with Nicola that explains a little but of the background about his work, past, present and future. I hope we'll be soon meeting Nicola at some Clojure conference speaking about the work he's doing, but as he said in the interview, he's mostly spending his time coding and the better way to know about his work is to follow the public activity on github.

<DT><A HREF="http://docs.caudate.me/lein-midje-doc/" ADD_DATE="1404219559" PRIVATE="0" TOREAD="0" TAGS="clojure,midje,documentation,literate,examples,live">midje-doc</A>
<DD>Midje-doc generates beautiful documentation starting from midje facts, which are treated as examples to show how code works. There is some directives you can give during namespace declaration to tell midje-doc how do you want your tests to be translated into &quot;live documentation&quot;. Midje-doc supports the midje :autotest philosophy and can show how the documentation shapes up while facts are being written. There is a 14' screencast to demonstrate all of this on the github repo page.

<DT><A HREF="http://clojure-android.info/blog/2014/06/10/lean-compiler-first-iteration/" ADD_DATE="1404201019" PRIVATE="0" TOREAD="0" TAGS="clojure,skummet,speed,optimisation,compiler,var,static">[GSoC 2014] Lean compiler: first iteration - Clojure on Android</A>
<DD>Quick one to signal that project Skummet is now able to output static declaration of Vars in the generated Clojure byte-code, one of the several optimisations envisioned for Android environment that could have also beneficial impact for quick development feedback at the REPL. I tried the build on my own projects without noticing any errors.

<DT><A HREF="http://www.amazon.co.uk/Lisp-Small-Pieces-Christian-Queinnec/dp/0521545668/ref=sr_1_1?ie=UTF8&qid=1404165485&sr=8-1&keywords=Lisp+small+pieces" ADD_DATE="1404199035" PRIVATE="0" TOREAD="0" TAGS="clojure,lisp,scheme,internals,compiler,theory,book">Lisp in Small Pieces: Christian Queinnec</A>
<DD>Just ordered a copy of this (quite pricey) book about Lisp implementations. I found the book linked in many places, including rhickey suggesting it on IRC (5 years ago). The content is about typical problems and solutions for implementation of lispy-like languages (Scheme is the one used in the book), including compiled output, intermediate bytecodes or interpretation. The Rich Reference Implementation of Clojure is indeed all about this sort of problem.

<DT><A HREF="http://stackoverflow.com/questions/1885448/how-do-you-evaluate-a-string-as-a-clojure-expression" ADD_DATE="1404146377" PRIVATE="0" TOREAD="0" TAGS="clojure,macro,eval,read-string,deferred">metaprogramming - How do you evaluate a string as a clojure expression? - Stack Overflow</A>
<DD>I had to use something similar recently, so I could pass around a macro to be used in a different place from where it appeared in the code. With normal function you can always use (var fn) or the equivalent #' reader macro to create for example a map of keys to fns. But macros are evaluated at compile time and thus something like (@#'clojure.repl/doc str) doesn't work while (@#'clojure.lang/+ 1 1) is perfectly fine. The only (not very nice) way I found was to use (eval (read-string &quot;clojure.repl/doc str&quot;)) to make it work. Mind that there are very few cases where you might need something like this, which is also suffering from security problems if eval-ing user input.

<DT><A HREF="https://gist.github.com/philandstuff/299cda371c7e74b03f18" ADD_DATE="1404126655" PRIVATE="0" TOREAD="0" TAGS="clojure,euroclojure,conference,notes,2014,gist">Euroclojure 2014</A>
<DD>Here are the definitive notes for EuroClojure. Phil Potter wrote all of the notes at smoking speed over the conference, except during his own talk (I'm sure he'll fix this annoying detail next year :) By the way, talks were amazing, with tons of ideas and links to follow that you can read on this gist as well. Thanks Phil!

<DT><A HREF="http://jakemccrary.com/blog/2014/06/22/comparing-clojure-testing-libraries-output/" ADD_DATE="1403984139" PRIVATE="0" TOREAD="0" TAGS="clojure,test,midje,expectations,comparison,libraries">Comparing Clojure Testing Libraries: Output - Jake McCrary</A>
<DD>An interesting comparison between output of testing libraries. Expectations is the winner of this informal but still useful comparison, mainly because of the care that put into the correct formatting of output between different data types. Midje is coming last with a promise (see comments below) by Brian Marick to make it better than ever. Can't wait.

<DT><A HREF="https://github.com/quil/quil" ADD_DATE="1403875937" PRIVATE="0" TOREAD="0" TAGS="clojure,quil,wrapper,openGL,draw,graphics">quil/quil</A>
<DD>Quil is a Clojure wrapper around processing.org, which is a drawing language and environment written in Java. With a few more wrapping layers on top, we are talking about driving openGL from Clojure. Quil is suitable for all your graphical and animation needs down to the pixel level, with a huge library of primitive available for more abstract drawing. I saw it in action during the interlude lunch-time lightning talk, showing tracks of a sequencer  on the screen in a simple and effective way.

<DT><A HREF="http://stackoverflow.com/questions/4288476/clojure-rest-vs-next" ADD_DATE="1403627081" PRIVATE="0" TOREAD="0" TAGS="clojure,next,rest,lazy,sequence,std,lib">lazy evaluation - Clojure: rest vs. next - Stack Overflow</A>
<DD>Nice discussion on StackOverflow about next VS rest. It can get quite philosophical and reading the sources is not helping a lot (I could only track that ASeq.rest() is calling next() inside but each collection has a different implementation of this). One sure thing is that to return nil next needs to look ahead and realise at least the next element or the next chunk of a sequence. So rest is more lazy than next.

<DT><A HREF="https://github.com/Chouser/clojure-compiler/blob/master/src/net/n01se/clojure_compiler.clj" ADD_DATE="1403511198" PRIVATE="0" TOREAD="0" TAGS="clojure,history,cic,compiler,houser">clojure-compiler/src/net/n01se/clojure_compiler.clj at master · Chouser/clojure-compiler</A>
<DD>Another bit of Clojure history. Chris Houser is one of the protagonist of the Clojure scene and one of the earliest receptor of Rich's ideas about the future of Clojure. Apart from his very good book (manning.com/fogus) he should also be credited for a couple of important early attempts: ClojureScript and Clojure in Clojure. Although his work didn't end up being part the current related efforts, it is stil inspirational. Linked here is a clojure compiler in clojure from 2009. If you look at the bottom, it is tested by parsing the compiler itself.

<DT><A HREF="http://hugoduncan.org/post/shell_scripting_in_clojure_with_pallet/" ADD_DATE="1403303629" PRIVATE="0" TOREAD="0" TAGS="clojure,shell,scripting,generate,bash">Pelure - Shell Scripting in Clojure with Pallet</A>
<DD>github.com/pallet/stevedore is an internal clojure DSL that emits bash shell scripting. Personally I don't write a lot of shell scripting, just the right amount when needed and when that happens I'm definitely going to look up yet again how I need to implement a condition or a loop. No more with Stevedore. I just write my favourite Clojure with some imperative style and voila, I can output shell scripting. Maybe that could be the base skeleton to start with. It allows advanced &quot;macro style&quot; scripting, with quoting pure Clojure to express some more complicated stuff that doesn't necessarily belong to the DSL language. Cool.

<DT><A HREF="http://clojuredocs.org/clojure_core/clojure.core/group-by" ADD_DATE="1403170759" PRIVATE="0" TOREAD="0" TAGS="clojure,stdlib,util,group-by,tool,transient,performances">ClojureDocs - clojure.core/group-by</A>
<DD>And just when you were abandoning all further attempts and accepted to use a fairly understandable &quot;reduce&quot; here comes the group-by. The name speaks quite clearly: give it a list of maps and a key and group-by will group those maps by the value of that key. The reduce is still there in the sources but handed gracefully and with an eye on performances by the standard library. If you open the sources you'll see that it is assoc! a transient map to build up results and make it persistent at the end.

<DT><A HREF="http://www.uswitch.com/tech/more-open-source-clojure-systems-please/" ADD_DATE="1403079554" PRIVATE="0" TOREAD="0" TAGS="clojure,adoption,experience,share,opensource,library,uswitch">More Open-Source Clojure Systems, Please</A>
<DD>uSwitch is a neat Clojure shop in London and they recently decided to share some of the goodies they are producing over there. This post also illustrates a few of the Clojure infrastructure best practices and tools they adopted, including a component system, riemann monitoring and much more. The post is also an invite for all the other Clojure shops to open-source more of their work. I couldn't agree more. At the Dailymail I started taking care of this part a little more and open sourced the first of a series of libraries/tools that are part of our daily practice. But we still have a lot to do in this direction. Stay tuned and share more.

<DT><A HREF="http://clojuredocs.org/clojure_core/clojure.core/comment" ADD_DATE="1402933769" PRIVATE="0" TOREAD="0" TAGS="clojure,comments,ignore,reader,skip,macro">ClojureDocs - clojure.core/comment</A>
<DD>comment is a macro that ignores the given body and returns nil. When comment is used in normal code it still needs to go through the reader before macro expansion inside the  compiler when it is finally yielding nil. This has the important consequence that what is enclosed in a comment needs to be well formed, at least for the syntax checking that the Clojure reader is applying. For example the following: (comment {:a a :b}) won't pass the MapReader check, because the reader knows nothing about the behaviour of the comment macro. The #_ reader macro ignores the next form and doesn't force any compiler step, so it is usually a better choice.

<DT><A HREF="http://stackoverflow.com/questions/20831029/how-is-it-possible-to-intern-macros-in-clojure" ADD_DATE="1402577665" PRIVATE="0" TOREAD="0" TAGS="clojure,intern,symbol,function,macro,metaprogramming,def,defn,stdlib">how is it possible to intern macros in clojure? - Stack Overflow</A>
<DD>Interning is the operation of storing a new symbol to var mapping pair in a namespace instance. The var can point to a function or a macro or something else. After interning the new symbol starts to work exactly like any other created using def/defn. Interning can be useful when the definition is done at runtime rather than compile time (a special case indeed, but similar to what is called meta-programming in other languages). This stack overflow question was answered to understand what to do in case of a macro, which turns out to be just some metadata away. The interned macro is then used in the context of the namespace it was defined into.

<DT><A HREF="http://clojuredocs.org/clojure_core/clojure.core/with-redefs" ADD_DATE="1402406222" PRIVATE="0" TOREAD="0" TAGS="clojure,tests,stub,redef,binding,thread">ClojureDocs - clojure.core/with-redefs</A>
<DD>with-redefs is the less sophisticated binding cousin. It changes the var root of a var for all the executing threads instead of being selective as binding is. It does this to all vars, those marked :^dynamic and those that are not. This brutal approach doesn't have a lot of application in normal code, since it implies a global state change that other portion of the code might not be aware of. This is the reason why it is preferable to binding to mock out a function in testing. with-redefs will operate as expected even in case where tests are concurrent.

<DT><A HREF="http://corfield.org/blog/post.cfm/automated-browser-based-testing-with-clojure" ADD_DATE="1402061218" PRIVATE="0" TOREAD="0" TAGS="clojure,selenium,automation,webdriver,testing,acceptance">Automated Browser-based Testing with Clojure — An Architect's View</A>
<DD>When the time will come to have some browser automation covering the main feature of our app, I want to be ready. I'm very reluctant to have a comprehensive suite of browser based tests and make it part of a top-down process, but I'm happy to have a sanity automation clicking around and tell me if something *important* is severely damaged. It looks like Gregoire's clj-webdriver is that nifty Selenium WebDriver wrapper that can be used easily from Clojure. This post by Sean Corfield (look for the active people in the Clojure ML to know more about him) explains and to set it up.

<DT><A HREF="http://clojuredocs.org/clojure_core/clojure.core/not-empty" ADD_DATE="1401960618" PRIVATE="0" TOREAD="0" TAGS="clojure,stdlib,idiomatic,core,not-empty,collection,nil">ClojureDocs - clojure.core/not-empty</A>
<DD>This little function seems useless but it enables better idiomatic Clojure. not-empty on a collection returns nil when the collection is empty. As we know, Clojure collection emptiness does not equal nil, that is (= nil []) is false. But (= nil (not-empty [])) is true. Why would you need that? To enable when-let forms on collections. If a function needs to create/process a collection first thing and only proceed if there is at least one element in the collection (maybe doing expensive stuff) (when-let [mycoll (not-empty (fetch-elements))]) only evaluates when there is something in the collection.

<DT><A HREF="https://github.com/arrdem/oxcart" ADD_DATE="1401954139" PRIVATE="0" TOREAD="0" TAGS="clojure,internals,compiler,optimisation,performances,speed">arrdem/oxcart</A>
<DD>Oxcart is another (GSoC) attempt to speed-up Clojure at the price of a reduced or removed dynamicity. It is a Clojure rewrite of the reader, analyzer, emitter triad that compared to the tools.* approach doesn't seek Clojure compliance (other than the pure runtime). Compared instead to Alexander Yakushev's Skummet or the Rich' fastload branch, this is written in Clojure while the formers are taking it from the current Java implementation. Several interesting ideas in this project, but mainly the compilation of functiond belonging to the same namespace to a single class (instead of a class per function) or the entire program to a single class, thus allowing drastic optimisations once the entire requirements in term of bytecode are all collected in the same place.

<DT><A HREF="https://github.com/Chouser/clojure-classes/blob/master/graph-w-legend.png" ADD_DATE="1401900446" PRIVATE="0" TOREAD="0" TAGS="clojure,classes,diagram,reference,legend,history">clojure-classes/graph-w-legend.png at master · Chouser/clojure-classes</A>
<DD>Another great class diagram by CHouser. It's from 2009 but it's still a great &quot;getting-around&quot; reference considering the amount of classes and their relationship in Clojure core.

<DT><A HREF="https://github.com/clojure/clojure/commits/fastload" ADD_DATE="1401799029" PRIVATE="0" TOREAD="0" TAGS="clojure,internals,speed,fastload,bootstrap">fastload Branch Commits · clojure/clojure</A>
<DD>Glad to see Rich is back working on speedup of Clojure. There are many people at the moment working on improving Clojure bootstrap. Maybe the trigger for this is that as the Clojure projects grow in size it is more and more difficult to deal with a fast feedback loop, even with a REPL and components frameworks. Another big demand is coming from mobile, where Clojure can be a compelling language to work with.

<DT><A HREF="http://jafingerhut.github.io/cheatsheet-clj-1.3/cheatsheet-tiptip-cdocs-summary.html" ADD_DATE="1401726756" PRIVATE="0" TOREAD="0" TAGS="clojure,learning,cheatsheet,std,lib,summary,functions">Clojure Cheat Sheet (Clojure 1.3 - 1.6, sheet v13)</A>
<DD>An enhanced version of the official clojure.org/cheatsheet with added popup tooltip and search box! The cheatsheet is quite useful to have a glance of the standard library functions grouped by functionality type. With this one you just hover over a function to see the docs and typing in the search box will filter down the list. Thanks Andy Fingerhut for posting this in the group list.

<DT><A HREF="http://clojuredocs.org/clojure_core/clojure.core/vector-of" ADD_DATE="1401723377" PRIVATE="0" TOREAD="0" TAGS="clojure,vector-of,vector,persistent,transient,primitives,performance,std,lib">ClojureDocs - clojure.core/vector-of</A>
<DD>Vector-of creates a Vector, one of the Clojure data structures we are used to with [] that is using primitive types underneath. I couldn't find compelling examples or decent documentation so I've opened up the sources. gvec.clj is offering a PersistentVector behaviour implemented on top of native Java arrays, when PersistentVector.java is using Object[] as a node instead. In that sense gvec is a translation of PersistentVector.java to Clojure, with primitive types as leaves (of the trie). When to use? Performances. Use vector-of when a persistent data structure is still important (because if not, you could just go transient or even int-array and friends). Of course you need to be sure you'll never store anything else than a primitive type in it, that now that I think about it, it happens quite often to me.

<DT><A HREF="http://clojuredocs.org/clojure_core/clojure.core/pmap" ADD_DATE="1401720093" PRIVATE="0" TOREAD="0" TAGS="clojure,parallel,map,pmap,threads,future">ClojureDocs - clojure.core/pmap</A>
<DD>pmap is a dead easy way to parallelise a map operation in Clojure. It comes with trade-offs you really want to be aware of, before it's too late. The model assigns each element of the map to a future, where the map operation will take place. Pmap is not a good idea for big collections and fast map operations, since at that point any possible speed gain will be overtaken by the creation of threads. For more big data things, reducers are a better solution.

<DT><A HREF="http://clojuredocs.org/clojure_core/clojure.core/with-meta" ADD_DATE="1401458104" PRIVATE="0" TOREAD="0" TAGS="clojure,metadata,reader,logic,use">ClojureDocs - clojure.core/with-meta</A>
<DD>Metadata in the form of a map can be attached to symbols or collections. Metadata are mainly designed to pass semantic information down to the compiler phases, so there is a list of them with a special meaning that is used by the clojure internals. Metadata can also be used by library or framework providers, to mark functions (symbol-Var pairs pointing to functions) for example for testing. Of course more creative use is possible, but implementing business logic as metadata is possibly a bad idea (ask yourself why that information needs to be hidden instead of being part of the code contract). With-meta is the extended form, but the reader macro ^{:doc &quot;How obj works!&quot;} is what you'll probably most often see.

<DT><A HREF="http://clojuredocs.org/clojure_core/clojure.core/symbol" ADD_DATE="1401440679" PRIVATE="0" TOREAD="0" TAGS="clojure,symbol,equality,namespace,name,lookup">ClojureDocs - clojure.core/symbol</A>
<DD>The symbol fn takes a name or a ns name pair and return a new instance of clojure.lang.Symbol .There is no global table of created Symbols like what happens for Keywords instead, so every time you invoke (symbol &quot;blah&quot;) you always get a different (in the Java sense of object reference) symbol instance. If we are talking about equality instead, they just need to have same name and namespace, so: (= (symbol &quot;asdf&quot;) 'asdf (clojure.lang.Symbol/intern &quot;asdf&quot;)) are all equivalent ways to express equivalent symbols. Symbol main purpose in Clojure is to pair up a name and a namespace and be used to lookup &quot;things&quot; like Vars. You can even invoke them! ('+ #{'+ '- '* '/}) will lookup itself in the set.

<DT><A HREF="http://www.jsoftware.com/papers/eem/life.htm" ADD_DATE="1401438184" PRIVATE="0" TOREAD="0" TAGS="clojure,APL,gameoflife,golf,expressiveness">Life: Nasty, Brutish, and Short</A>
<DD>I know, couldn't resist. No clojure up here, but this is where you can get with APL on a typical matrix-based problem like the Game of Life. I don't understand a line, but the explanation is fascinating nonetheless. The article explores APL solution to the Game of Like from the 1970 onward, with the goal of finding the shortest. A golf-programming exercise at the end, but an entertaining one. The final version is 9 tokens.

<DT><A HREF="http://www.functionalgeekery.com/episode-9-william-e-byrd/" ADD_DATE="1401380684" PRIVATE="0" TOREAD="0" TAGS="clojure,logic,podcast,datalog,core.logic,minikanren">Functional Geekery Episode 9 – William E. Byrd</A>
<DD>Enjoyed listening to this episode of the Functional Geekery podcast (and all the others by the way). I had the pleasure to attend a couple of pair-talks by Wll Byrd and Daniel Friedman and appreciated their style presenting dense topics with a bit of humour. I'm fascinated by logic programming and what you can achieve declaratively. I think the big jump from FP to logic happens when you stop thinking about input and output as two different things. In logic programming you can very well feed the output of a function (or the output evaluation of a compiler) back as input and generate a set of all the solutions that can produce that output. William also remembers us that despite not conquering the entire world, logic programming has found specific niches where it has no rivals, like embedded query engines like the datalog engine in Datomic.

<DT><A HREF="https://medium.com/erlang-lisp-and-haskell/session-1a12997a5f70" ADD_DATE="1401377348" PRIVATE="0" TOREAD="0" TAGS="clojure,editor,repl,lighttable,evaluation,datomic,om,library">Session — Erlang, Lisp and Haskell — Medium</A>
<DD>Session is a REPL on steroids, an all-evaluable Clojure scratchpad that remembers LightTable but also allow for graphics and other fancy output, not just text. It is backed by a Datomic database, so sessions are persistent and stored. It uses some other fancy new tech like Om and designed to be extensible and modular (such as, replace the rendering engine if you need to). One application that comes into mind is creating custom editors for specific DSL, replacing the need of editing configuration files for example.

<DT><A HREF="http://www.deepbluelambda.org/programming/clojure/how-clojure-works-a-simple-namespace" ADD_DATE="1401376627" PRIVATE="0" TOREAD="0" TAGS="clojure,internals,classloader,namespace,bytecode">How Clojure works: a simple namespace : Deep Blue Lambda</A>
<DD>This is probably the best article so far of the series &quot;clojure internals&quot;. It explains what happens in case of a bare bone new namespace declaration. One of the most interesting facts is that a new namespace always trigger first thing a push of a new class loader into the thread bound table of Vars. Translated it means that from that moment on, all the functions declaration that will follow in the namespace will be loaded by a new instance of DynamicClassLoader custom class loader. I suppose this is a wise decision, since the dynamicity of Clojure will allow me to redefine functions at anytime in that namespace, resulting in a class being thrown away and a new class being generated and loaded. The DynamicClassLoader contains a weak reference cache that makes this process easier. Not sure about all the details yet, but very interesting stuff.

<DT><A HREF="https://github.com/MailOnline/s-metric" ADD_DATE="1401298569" PRIVATE="0" TOREAD="0" TAGS="clojure,string,match,score,algorithms">MailOnline/s-metric</A>
<DD>Quick and hopefully useful self-promotion. This little library implements a couple of easy algorithms for string matching and scoring. The typical use case is to compare a first string to another one and see how visually similar they are. For this the &quot;naive&quot; implementation presented here can be sufficient. But string matching theory is way more complicated than this :) so other interesting algos will be added soon. Clojure here shines for quick implementation of fairly complex recursive behaviour. If you need to push performances to the next level though, it takes some more Java knowledge and pre-processing with useful data structures.

<DT><A HREF="https://www.assembla.com/spaces/clojure/wiki" ADD_DATE="1401294146" PRIVATE="0" TOREAD="0" TAGS="clojure,history,wiki,design">Getting Started with Textmate | Clojure Project | Assembla</A>
<DD>Linking here another piece of abandoned Clojure history. The Assembla wiki was adopted some point in 2009 and then abandoned to move under the clojure.org umbrella. There is not a lot there, except a few design scratch pad about some of the Clojure features built at that point. The page about the clojure compiler in clojure is a summary about some of the desired features of a a new compiler, nowadays tools.analyzer and friends.

<DT><A HREF="http://clojuredocs.org/clojure_core/clojure.core/take-while" ADD_DATE="1401287951" PRIVATE="0" TOREAD="0" TAGS="clojure,stdlib,take-while,lazy,for,loop">ClojureDocs - clojure.core/take-while</A>
<DD>take-while is often the answer to the question &quot;how do I cut short a loop&quot; for people coming from a Java background. The lazy way to &quot;cut short&quot; can be implemented with a take-while that stops a sequence the first time the given predicate becomes true. It can be used perfectly fine with the for comprehension (which is just another way to create a lazy sequence) without the need for a &quot;break&quot; construct.

<DT><A HREF="https://github.com/galdolber/clojure-core-java" ADD_DATE="1401197376" PRIVATE="0" TOREAD="0" TAGS="clojure,internals,bytecode,generation,generated,decompiled,decompile">galdolber/clojure-core-java</A>
<DD>Quite an interesting investigation project from the same author of clojure-objc. This is what happens if you take a very simple Clojure hello world, even just a namespace declaration and AOT compile it. You'll see a bunch of classes are generated. This project is the correponding Java source for the byte code that Clojure generates. By no mean this should be used, but it gives an impression of what is going on under the hood. You can obtain similar results by decompiling Clojure, but this is already done for you if you need a quick glance.

<DT><A HREF="https://github.com/xach/linj" ADD_DATE="1400585462" PRIVATE="0" TOREAD="0" TAGS="clojure,history,link,jfli,generation,lisp,cl">xach/linj</A>
<DD>Let's add LinJ to the series of the forgotten Lisp2Java experiments that thanks to Github have now found a place to live for the eternity. LinJ is what Clojure was at some very early point in life, a Java source generator. This approach has a lot of practical downsides, above all the double compilation step that kills any REPL-like interactivity. On the good side instead, the fact that what is generated can be easily inspected, something that in Clojure is possible but difficult (through decompilation). LinJ also tried to imitate CL as much as possible, something that Clojure did not, proving that what is important is the Lisp philosophy, not necessarily the list-everywhere syntax. Lot of lessons coming from the past, it's good to remember.

<DT><A HREF="http://yobriefca.se/blog/2014/05/19/the-weird-and-wonderful-characters-of-clojure/" ADD_DATE="1400582660" PRIVATE="0" TOREAD="0" TAGS="clojure,reader,macros,google,search,characters">The Weird and Wonderful Characters of Clojure</A>
<DD>Ha! Indeed, I struggled to google for some of the un-googeable clojurisms found in this page. Mostly reader macros, but also unquote-quote, splicing, deref and many others are part of the Clojure Reader power tools that make our life easier, but when it comes to search for them it is sometimes a pain, especially if you don't know/remember their english name.

<DT><A HREF="http://clojuredocs.org/clojure_core/clojure.core/select-keys" ADD_DATE="1400574337" PRIVATE="0" TOREAD="0" TAGS="clojure,stdlib,keys,hashmap,filter,select">ClojureDocs - clojure.core/select-keys</A>
<DD>Just when you were considering rolling your own reduce, here's a quick helper when you need to consider just some keys of a bigger hash map. Always good to remember what's available.

<DT><A HREF="http://stackoverflow.com/questions/9638271/update-the-values-of-multiple-keys" ADD_DATE="1400519630" PRIVATE="0" TOREAD="0" TAGS="clojure,stdlib,update-in,map,reduce,keys,update">clojure - Update the values of multiple keys - Stack Overflow</A>
<DD>On the other hand (see link above), there is no std lib function to achieve this. Reduce to the rescue! Reduce can be used in a non-reducing way every time a sequence-able collection needs multiple updates at once, for example a map. In this case multiple values need to be sent for update. Reduce allows the partial updates to be gradually accumulated and sent over to the next element in the sequence until the final result.

<DT><A HREF="http://xahlee.info/UnixResource_dir/writ/tailrecursion.html" ADD_DATE="1400486681" PRIVATE="0" TOREAD="0" TAGS="clojure,tco,tail,crecursion,optimisation,sicp,iterative">Why You Should Avoid the Jargon Tail Recursion</A>
<DD>Nice short summary of the meaning of tail recursion and the danger of using the term in a semi-religious way. First of all the mandatory SICP reference. Looping constructs are described there as a patch for &quot;bogus&quot; compilers unable to optimise iterative recursion (recursion with proper tail call). The article suggests that we should stop using a TCO because of its too many confusing meanings. There is no direct reference to Clojure in this post, but I've heard the argument many times that Clojure doesn't have TCO so it's not a Good Language™. Of course having to loop-recur is tedious but as a trade-off is not too bad. There is some discussing about Java 9 to finally support TCO, let's hope that's the case.

<DT><A HREF="http://www.loper-os.org/?p=42" ADD_DATE="1400142187" PRIVATE="0" TOREAD="0" TAGS="clojure,lisp,negative,review,design,language">Loper OS - Thumbs Down for Clojure</A>
<DD>This is quite a popular post, one that articulates well what are the main Clojure design flaws, although what is defined as design flaw here is a design goal in Clojure: pragmatisms. Unfortunately the argumentation is not accepting the trade-off, dismissing Clojure as &quot;revolting&quot;. As of why this post is still popular these days is pretty clear: it is one of the few completely negative review of Clojure while the rest of the world, maybe with some reservations, is accepting it as innovative and useful. I think we should still read it in a constructive way: can we &quot;patch&quot; the Java compromise? Can we push more of the Lisp purity in Clojure and draw a clear demarcation line between its surface and its internal implementation details? Can we fix the nasty stack traces (that is, translate the Java nature of Clojure back into Lisp when things go wrong?)

<DT><A HREF="https://groups.google.com/forum/#!forum/comp.lang.lisp" ADD_DATE="1400141273" PRIVATE="0" TOREAD="0" TAGS="clojure,lisp,ml,group,learning">Google Groups - comp.lang.lisp</A>
<DD>Let's not forget about an important aspect (if not predominant) of Clojure. comp.lang.lisp is the venerable Lisp list, where universals have been discussed at least twice along with all of the most important functional concepts. I think it's a good idea if you're serious about Clojure to make some room to learn Lisp and follow the discussions going on here.

<DT><A HREF="https://github.com/gtrak/no.disassemble/" ADD_DATE="1399968672" PRIVATE="0" TOREAD="0" TAGS="clojure,bytecode,disassemble,reverse,compile,source">gtrak/no.disassemble</A>
<DD>For all of you uber-geeking with Clojure, this little lein plugin and library will let you dump out at the REPL the decompiled version of the byte code that Clojure is generating on the fly when you create a function (and other Clojure snippets). It needs to plug an agent into the JVM bootstrap sequence to intercept byte code loading related to Clojure on the fly, which should not get in your way in other way, unless you are already using another agent. But this is mainly a dev tool to be used temporary.

<DT><A HREF="https://groups.google.com/forum/#!msg/clojure/FfBGPZbY9PA/XRR_PZO61OwJ" ADD_DATE="1399622308" PRIVATE="0" TOREAD="0" TAGS="clojure,lazy,lazyness,sequences,outofmemory,heap,caching,languages,design">Running out of memory when using filter? - Google Groups</A>
<DD>This is an old thread that contains some wisdom toward the end about why lazy sequences are not a silver bullet. The problem highlighted in this thread is solved now, but I also had the assumption (before reading this message from Rich) that using lazy sequences the &quot;correct&quot; way and never realise them in full prevent out of memory errors completely. &quot;Completely&quot; is not always true, even in case of careful laziness usage. They do make working with data bigger than memory almost always transparent but that's not their intent. There are also performance considerations involved, like how much to cache during processing so there is always a design tradeoff that can break under specific circumstances (and throw the dreaded out of memory). It is the responsibility of the language implementor to find the good balance between laziness, performances and the typical usage expected for a language, that in the case of Clojure is very likely to be a translation between an imperative-built collection (Java) and the purely functional world.

<DT><A HREF="https://github.com/papers-we-love/papers-we-love" ADD_DATE="1399584903" PRIVATE="0" TOREAD="0" TAGS="clojure,papers,academia,ideas,meetup,cs">papers-we-love/papers-we-love</A>
<DD>Oh, this is neat neat idea. Papers we love is a Github repo to collect CS papers and an initiative to organise meet-ups to discuss them. Papers are a great source of inspiration. They often are the common ground where academia meets industry. Many ideas in Clojure are coming from academic work and relevant papers are often linked in the mailing list or by Rich at conferences. Have a look at the Clojure and functional programming folders to start with. The related London meet-up already started if you want to join.

<DT><A HREF="http://jafingerhut.github.io/clojure-benchmarks-results/Clojure-expression-benchmark-graphs.html" ADD_DATE="1399038187" PRIVATE="0" TOREAD="0" TAGS="clojure,benchmark,versions,release,speed">Clojure expression benchmarks for Clojure versions up thru 1.6.0</A>
<DD>Quite interesting benchmark that Andy Fingerhut put together on this page that was posted to clojure-dev. JDK 8 is not particularly changing the game although in a couple of cases is doing significantly better. Maybe what should be important to look at is what Clojure is doing through versions and being sure the lines don't tend to go up toward the right. There are a few charts showing degraded performances toward the bottom, presumably related to the new hashing algorithms.

<DT><A HREF="http://stackoverflow.com/questions/5181367/is-defn-thread-safe/5182407#5182407" ADD_DATE="1398960588" PRIVATE="0" TOREAD="0" TAGS="clojure,stdlib,var,def,defn,ns,intern,symbol">clojure - Is defn thread-safe? - Stack Overflow</A>
<DD>Here's another good example that highlights how Vars, Namespaces and Interning work together. You might think that the function result that didn't change inside the vector is a surprising result, but is not. What was added to the vector is the value of the Var my-func not the Var itself. Defn are just def followed by a (fn) function definition. When defn is invoked the following happens: a java class implementing IFn is defined in the current class loader with the body executing the content of the function. A Var instance is also created if not extent already that is pointing at the instance of the function. The Var is added to a table of definitions for the current namespace (interning). All the Vars defined for the a ns can be seen with (ns-interns ns). When the vector is created and passed the Var my-func the Var is dereferenced and the IFn instance is taken. When the Var is defined again, replacing its root binding, the initial function instance is still referenced by the vector. If you really wanted the Var to enter the vector then you should have done [#'my-func]. As of thread safety, the map of all the Vars for a Namespace is kept inside a PersistenArray wrapped by an AtomicReference, so all updates are re-tried until success with compareAndSet.

<DT><A HREF="http://queue.acm.org/detail.cfm?ref=rss&id=2611829" ADD_DATE="1398847284" PRIVATE="0" TOREAD="0" TAGS="clojure,C#,FP,OO,monads,state,concurrency,meijer">The Curse of the Excluded Middle - ACM Queue</A>
<DD>tl;dr no true functional programming is achievable without monads (or similar state wrapping). This essay by Erik Meijer is quite extreme in its conclusions, describing why an hybrid approach cannot work. Erik considers OO languages with added closures doomed to fail because state creeps in unexpected ways: interleaving of operations due to laziness, catch clauses not operating correctly, with examples in C#. I think Clojure demonstrates that a default approach based on immutability with a strong API around state is a winner even without enforcing a monadic approach. Too bad the article is not mentioning it.

<DT><A HREF="http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/tree-seq" ADD_DATE="1398776887" PRIVATE="0" TOREAD="0" TAGS="clojure,tree,traversing,depth-first,file,sequence,lazy">tree-seq - Clojure v1.6 API documentation</A>
<DD>Tree-seq is a generic depth-first walk function for tree-like structures that returns a lazy sequence of all the nodes in a tree. It takes two fns and a start-root. The two fns are all that is needed to walk any kind of tree. branch? is a function that takes a node and return false when this is a leaf. children is a function that given a node is expecting the list of other nodes down that path. An already implemented use in the std lib is file-seq, which is returning a list of all the nodes when iterating java.io.File types.

<DT><A HREF="http://lfe.github.io/" ADD_DATE="1398758288" PRIVATE="0" TOREAD="0" TAGS="clojure,lfe,erlang,vm,lisp,cl,languages">Lisp Flavored Erlang</A>
<DD>LFE (not to be confused with left fold enumerators) is a lisp implemented on top of the Erlang VM. It is not strictly related to Clojure except that I believe they share some of the difficulties in parsing and adapting a Lisp to run on a VM specifically designed for another language (Java or Erlang in this case). LFE is closer to Common Lisp than Clojure (which deliberately is trying to improve Lisp and drastically enhancing its syntax). Trivia: LFE is a lisp-2 (Clojure is a lisp-1). I don't think LFE achieved the same popularity that Clojure did and my guess is that who wanted to leverage the Erlang VM did that in Erlang directly (that despite the syntax oddities is still a great functional language).

<DT><A HREF="http://clojure.org/space/stats/overview" ADD_DATE="1398670885" PRIVATE="0" TOREAD="0" TAGS="clojure,stats,history,charts,views,popularity">Clojure - Statistics Overview</A>
<DD>If you ever wonder how much interest Clojure is generating around, here are the clojure.org web stats. This is not definitive answer, it just gives an idea about popularity based on page views and a break down by country, not much more. The average uniques are steadily increasing, now about 3500-5000 per day. There was a huge spike 6th January 2013, wondering what that was.

<DT><A HREF="https://github.com/tonsky/datascript" ADD_DATE="1398410793" PRIVATE="0" TOREAD="0" TAGS="clojure,clojurescript,datalog,database,in-memory">tonsky/datascript</A>
<DD>Interesting ClojureScript idea, implementing a Datalog query engine on top of Clojure immutable data structures. It is meant to run in the browser with a lifecycle starting at page load and ending the next page load. It is technically an in-memory database in the browser. When to use? When some widgetry on the page requires some more structured data (thinking about complex questionaries, single page apps processing data and so on). If &quot;searching&quot; through those data requires some constant array loop it could be a nice idea to put datalog on top instead.

<DT><A HREF="http://lispy.wordpress.com/2008/10/22/lisp50-notes-part-i-johnl-recalls-how-sussman-revealed-nature-of-intelligence/" ADD_DATE="1398331325" PRIVATE="0" TOREAD="0" TAGS="clojure,lisp,history,conference,lisp50,writeup">Lisp50</A>
<DD>Lisp50 was a once in a lifetime event for many (but I should be able to attend Lisp100!) It was a co-conference with OOPSLA 2008 collecting for the first time in many years all the brilliant minds in the Lisp community, including McCarthy (by phone), Guy Steele and many more. This series of 5 article is a write-up of what happened there and is full of wisdom. Rich Hickey was last talking there. We should not forget that Clojure main goal was not just to imitate but to be a better Lisp, an attempt that has been made so many times without success. Previous presenters before Rich created a sort pessimistic atmosphere, looking at Lisp big ideas in the distant past without an opportunity of redemption for the present. You can imagine what happened when Rich introduced Clojure to that mix of bearded Lisp hackers and a few younger nostalgic fellows! Clojure is really the only re-incarnation of Lisp nowadays that is getting traction. Kudos to Rich for solving decades of Lisp problems with simple and pragmatic choices.

<DT><A HREF="http://sourceforge.net/p/jfli/mailman/jfli-users/thread/558A2169-9CDC-46F6-BA1B-7D7D75880F9A@richhickey.com/" ADD_DATE="1398326385" PRIVATE="0" TOREAD="0" TAGS="clojure,history,lisp,ml,group,jfli,announce">jfli / Mailing Lists</A>
<DD>Another bit of Clojure history. Clojure was announced to the public on October 17th 2007, after a couple of years of stealth development, on the jfli mailing list (another RH's project). The google groups was created at that time and about one year later in 2008 was already counting 700+ users and Rich was already invited at several important conferences (notably, Lisp50 celebrating 50 years of Lisp). Also about one year later the release 1.0 was very close, with AOT compilation as its main big new feature.

<DT><A HREF="http://stackoverflow.com/questions/5734435/put-an-element-to-the-tail-of-a-collection" ADD_DATE="1398270481" PRIVATE="0" TOREAD="0" TAGS="clojure,list,vector,arrays,sequences,collection">clojure - Put an element to the tail of a collection - Stack Overflow</A>
<DD>Why there is no such a function in Clojure that just *append at the end*? The official answer seems to be that you need to know your stuff, that is the implications of modifying a sequence implemented as a list or as a vector. So based on that information you're going to use conj or cons, for example. Lately, I started to avoid vectors when I don't need/know about the specific performance I need. What I like about sequences in general is that they are and stay lazy if you pay attention at not realising them, a nice feature that allows a lot of processing in code before actually processing the sequence for real. But it all depends: is the collection going to be accessed sequentially or not? Is it going to be sorted often? And so on.

<DT><A HREF="http://stackoverflow.com/questions/12048151/what-does-the-leading-arrow-in-a-name-mean-in-clojure" ADD_DATE="1398265932" PRIVATE="0" TOREAD="0" TAGS="clojure,refrecord,interop,macro,constructor">What does the leading arrow in a name mean in clojure - Stack Overflow</A>
<DD>Ah, got it. I was wondering from where that arrow was coming from, considering a defrecord could always be created with a post-fixed dot as for Java interop (since what is created is actually a Java class). So the defrecord macro is responsible for creating a function -&gt;name-of-the-record that invokes the constructor of the record. The macro spits out a lot of other magic that is not easy to read, including hashCode and equals implementations and map like behaviour.

<DT><A HREF="http://david.heinemeierhansson.com/2014/tdd-is-dead-long-live-testing.html" ADD_DATE="1398258745" PRIVATE="0" TOREAD="0" TAGS="clojure,tdd,ruby,rails,dhh,programming">TDD is dead. Long live testing. (DHH)</A>
<DD>Not strictly Clojure related, but the discussions about TDD vs REPL driven development is still hot in Clojure-land. DHH here is publicly declaring that TDD is dead. I saw the tweets coming from the keynote at RailsConf and I'm looking forward to the Rails community reaction. DHH was never a fan of TDD but he was sort of doing it in the past, without realising exactly what was wrong with that approach. This blog post explains why he now thinks that TDD is just like  learning wheels (oh, I so wait for Uncle Bob's write up!). What's my take on this? I still start test first, I can't resist, but I'm much less strict than the past. I quickly abandon it as soon as third party services are invoked, or some piece of infrastructure that requires a lot of stubbing is required (like a rest endpoint for example). This is when I abandon TDD and use the REPL to play with the app. Mind that I'm also using the REPL throughout development, to create the implementation that makes my tests green. Still happy with that, it helps me think and focus, exactly like this weekly writing.

<DT><A HREF="https://groups.google.com/forum/m/#!msg/clojure/CqV6smX3R0o/3Xs_OEuHAQ0J" ADD_DATE="1398257502" PRIVATE="0" TOREAD="0" TAGS="clojure,keyword,parameters,defnk">keyword parameters? - Google Groups</A>
<DD>Old but interesting discussion about named parameters for functions. I already talked about defnk in the past and it was abandoned after migrating out from clojure contrib. Still it is an interesting little exercise to see how simply the feature can be added to the language (something that happened for Ruby properly in 2.0). Rich is showing the code in the last email. With this macro you can define functions that declares parameters with a name and a default. If the last two parameters in the example are not given (or others are given), it takes the default. The only way to change that default is to prefix the keyword to the parameter. The only caveat, at least in this simple implementation, is that the named params need to be at the end.

<DT><A HREF="http://blog.guillermowinkler.com/blog/2014/04/13/decompiling-clojure-i/" ADD_DATE="1398187414" PRIVATE="0" TOREAD="0" TAGS="clojure,bytecode,compiler,code,core,jvm">Decompiling Clojure I - Interrupted</A>
<DD>This is the start of a very interesting and well written series of article about Clojure internals, the relationship with Java and the produced byte code. It doesn't assume previous knowledge of any of the above which is very good if you never decompiled a class file. The last part explains the additional information that the compiler can add to the byte code to help the JVM during debugging (for example). Next instalment will be about the compiler and reader and I'm looking forward to it.

<DT><A HREF="http://clojuredocs.org/clojure_core/clojure.core/or" ADD_DATE="1398186276" PRIVATE="0" TOREAD="0" TAGS="clojure,idiom,or,nil,check,default,stdlib">ClojureDocs - clojure.core/or</A>
<DD>&quot;or&quot; can be used the standard way as in many other languages. But since nil is false in predicates, &quot;or&quot; can be also used to handle those frequent cases where some parameter can be nil and a default can be provided. (or mime &quot;application/html&quot;) for example could be used to accept a given mime variable or use an application/html default when mime is nil. That is equivalent to the more verbose (if mime mime &quot;application/html&quot;) which is not as nice to read.

<DT><A HREF="http://blog.oxfordknight.com/?p=269" ADD_DATE="1397628625" PRIVATE="0" TOREAD="0" TAGS="clojure,jobs,recruitment,banks,fp,adoption">The rise of functional programming in Banks | Oxford Knight Blog</A>
<DD>An interesting non-technical point of view from a recruitment firm that is investing a lot in the field of functional programs. The post sates that the raise of FP especially in banks since 2006 can be related to the fact that it models concurrency better, it models math better and that skills learned on the JVM (of course Scala and Clojure only) can be easily sold to other OO-based businesses. The last part reports back on teams adopting the main five FP languages: scala, clojure, haskell, ocaml and F#. No mentions for Erlang (always talking about banks, hedge funds and investment banks in general).

<DT><A HREF="http://www.infoq.com/presentations/clojure-reducers" ADD_DATE="1397582759" PRIVATE="0" TOREAD="0" TAGS="clojure,reducers,talks,video,info">Dissecting Clojure Reducers</A>
<DD>This talk I gave at Strangeloop 2013 is finally up on InfoQ. I'm still convinced live coding sessions are possible (and will take again the risk in the future if necessary), but this is an example of screwing up and being unable to recover :( The entire working REPL session is published here https://github.com/reborg/talk-strangeloop2013/blob/master/src/strloop2013/core.clj if you want to see how it was expected to finish!

<DT><A HREF="http://www.cognitect.com/podcast" ADD_DATE="1397548426" PRIVATE="0" TOREAD="0" TAGS="clojure,clojurescript,om,immutable,speed,identity">Cognicast :: Podcast</A>
<DD>I've managed to listen to only half of it, but it's already dense enough to deserve attention. React maintains a virtual DOM representation. Components change the DOM without direct manipulation. Changes are propagated down to the virtual DOM and when it's time to synch a diff is calculated and the real DOM is updated. OM implements a similar mechanism but since it is using the ClojureScript immutable data structures, it can check equality on identity of objects instead of values, with immediate speedup as a result.

<DT><A HREF="http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/mapv" ADD_DATE="1397478218" PRIVATE="0" TOREAD="0" TAGS="clojure,idiomatic,map,mapv,transients">clojure.core - Clojure v1.6 API documentation</A>
<DD>mapv has the same semantic of map but it returns a vector instead of a seq. It resolves to into for all cases where the inputs are more than one. But possibly the most common case is mapv over a single collection. In this case instead of plain into [] an optimised version makes use of transients. Click on &quot;source&quot; to see it in core.clj. Basically: reduce over coll starting from a transient seed, updating in place the results with the transformation and go back to persistent data structures at the end. The creation of the final vector happens outside a persistent data structure, when you can safely assume it is safe to mutate. This is a lesson from std-lib: idiomatic clojure often paysoff in several ways.

<DT><A HREF="https://github.com/weavejester/lein-generate" ADD_DATE="1397202748" PRIVATE="0" TOREAD="0" TAGS="clojure,tools,automation,template,generate">weavejester/lein-generate</A>
<DD>This is brilliant. I'm constantly repeating action like: create a namespace/test pair files from existent ones, change ns names to the new one, require the ns from the test blah blah. If you TDD you know what I mean :) But the plugin offers extendibility as a feature. I'm pretty sure I'll come up with other repetitive project actions that can be incorporated.

<DT><A HREF="http://clojuredocs.org/clojure_core/clojure.core/dorun" ADD_DATE="1397134868" PRIVATE="0" TOREAD="0" TAGS="clojure,lazy,seq,sequences,dorun,doseq,doall">ClojureDocs - clojure.core/dorun</A>
<DD>doall, doseq and dorun all provide a way to realise lazy sequences, but there are quite important differences. If the only goal is to realise the sequence for side effects, dorun is the preferred, because it does not retain the collection in memory. For some additional degree of sophistication, doseq also offers bindings and destructuring like for and still not return (hence retain) the collection in memory. doall should be used only when the collection should fully realise before leaving some &quot;connection&quot; context, because the element in it are dependent on that. doall often happens on result sets from 3rd party services that need to release the connection before being used.

<DT><A HREF="http://clojuredocs.org/clojure_core/clojure.core/format" ADD_DATE="1397044095" PRIVATE="0" TOREAD="0" TAGS="clojure,format,printf,padding,formatting,utils,core,stdlib">ClojureDocs - clojure.core/format</A>
<DD>Format is quite powerful printing function. You can use it with positional args with %s, but I was unaware of other interesting features like padding capabilities. This is one of those things that when you don't know you end up rolling your own string padding feature (and that can be a 2 hours Yak shaving task).

<DT><A HREF="https://github.com/zcaudate/lein-repack" ADD_DATE="1397030585" PRIVATE="0" TOREAD="0" TAGS="clojure,library,tools,reuse,dependencies,namespace">zcaudate/lein-repack · GitHub</A>
<DD>Interesting idea. The goal: avoid copy paste for functional re-use. The background: we all seem to have an clj-util library, where we store functional bits across projects that are generic enough to be reused elsewhere. At the same time this clj-utils is &quot;personal&quot; and when I find someone else snippet I'd like to use I don't want to have a dependency just for that. So, copy paste into my clj-utils! (with attribution). What if instead there was a &quot;function&quot; repository? What if the granularity of re-use was the require of a single function from another library? While we are thinking about it, lein-repack takes that a step further by treating namespaces in a project as separate deployable entities (that is, producing a separated set of libraries). With a little bit of namespace design, lein-repack makes it possible to require just a namespace of what used to be an entire project require. Still a project.clj line in dependencies, but a step further into a better re-use.

<DT><A HREF="http://norvig.com/luv-slides.ps" ADD_DATE="1397030031" PRIVATE="0" TOREAD="0" TAGS="clojure,lisp,stlyle,abstraction,fp,functional,design,conciseness">Tutorial on Good Lisp Programming Style - Peter Norvig</A>
<DD>Very lispy indeed. But tips on functional abstraction applies to Clojure as well. It is also a must read in terms of principles of good style in programming, expressing intention and good functional engineering in general. The format is also very readable, a mix between a slide-based presentation and a full paper. The bit I enjoyed the most is the rule of english translation for functional decomposition: 1. start with a sudo-code english description of the algorithm 2. translate to working code 3. translate code back into english 4. compare 3 to 1. If 3 is much more articulated than 1, you're missing functional abstractions (i.e. extract function). 1 should read as 3 with all complexity extracted into helper functions.

<DT><A HREF="http://martintrojer.github.io/clojure/2014/04/05/the-clojure-repl-a-blessing-and-a-curse/" ADD_DATE="1396943940" PRIVATE="0" TOREAD="0" TAGS="clojure,performance,REPL,boostrap,component,reloaded">The Clojure REPL; a blessing and a curse</A>
<DD>This article by Martin Trojer really resonates with me. I'm very happy to have a component-based lifecycle for my Clojure projects. At the same time, when I first heard about Stuart Sierra Clojure reloaded workflow, I thought that the effort wasn't entirely justified. The component workflow to keep the REPL alive at all costs doesn't seem to be scaling over a certain level and maybe it is time to re-design the Clojure static initialisation context in a different, more lazy, way. Keep in mind that the problem is not Clojure at all, it's a fairly fast and close to Java performance env. The main problem seems to be the development lifecycle.

<DT><A HREF="http://nicholaskariniemi.github.io/2014/02/25/clojure-bootstrapping.html" ADD_DATE="1396943175" PRIVATE="0" TOREAD="0" TAGS="clojure,performances,bootstrap,vars,core,fn,static,clinit">Why is Clojure bootstrapping so slow?</A>
<DD>This article is a fairly detailed analysis of the Clojure bootstrap time. Clojure projects are reaching a &quot;critical&quot; size in live environments, where bootstrapping with all the dependencies can take up to a minute or more (I'm not talking about the hello world used as an example in this article). Clojure component-based workflows are helping mitigate the problem, but restarting the REPL for development is still a frequent operation. So what is the problem exactly? Clojure bootstrap is basically a giant Java static initialisation context. All Symbols to hold values or functions are first defined (metadata included) and then Vars are initialised so they point to the specific symbol (function or value). This happens for each var declaration in clojure.core plus a few helper namespaces that are loaded on a side. Each namespace results in a Java class byte code (loaded at runtime or AOT compiled), its long static initialiser and one inner class for each fn. The main take away of this analysis is that what is not used should be loaded lazily.

<DT><A HREF="https://github.com/clojure/clojure-clr" ADD_DATE="1396471143" PRIVATE="0" TOREAD="0" TAGS="clojure,clr,.net,csharp,microsoft,C#">clojure/clojure-clr · GitHub</A>
<DD>The Clojure repo targeting the CLR and written in C# is far from being dormant. And despite the Java brother is getting all the of the attention, this is a remarkable achievement. The .NET version of Clojure started side by side with the Java version in 2006 then kept in sync, starting a few years ago, apparently by Dave Miller alone! Dave is also porting all the other important contrib libraries like core.async. A dedicated mailing list was recently started.

<DT><A HREF="http://clojuredocs.org/clojure_core/clojure.core/destructure" ADD_DATE="1396051914" PRIVATE="0" TOREAD="0" TAGS="clojure,destructure,eval,destructuring">ClojureDocs - clojure.core/destructure</A>
<DD>Destructure is not well documented. Maybe Rich has reasons for that, like an unstable interface, but it's widely used in the Clojure codebase. I think it is useful to try out destructuring without the need to setup a let form for it. You can see if it's doing what you expect at the repl quite easily. Destructure returns a vector of symbols unevaluated-forms pairs. The pair can be actually executed by internalising the symbol using the eval of the form as the value.

<DT><A HREF="http://swannodette.github.io/2013/12/17/the-future-of-javascript-mvcs/" ADD_DATE="1395996858" PRIVATE="0" TOREAD="0" TAGS="clojure,clojurescript,immutable,react,facebook,javascript,dom">The Future of JavaScript MVC Frameworks</A>
<DD>Took the time to read through the OM rationale blog post. I still need to understand all the implications of dom rendering and manipulation, but the net effect seems to be when immutable data structures can be always analysed top to bottom in logN time. Facebook React offers the idea, that only sub-trees of the DOM should be processed to reflect changes but does that ineffectively using mutable JS objects. Om ads ClojureScript immutable data structures on top of that increasing speed, simplicity and evolvability. Present here are is also the speed gain you get if instead of plain react Om is used. It just seems the perfect use case for real functional data structures.

<DT><A HREF="http://juliangamble.com/blog/2012/07/13/amazing-lisp-books-living-again-in-clojure/" ADD_DATE="1395936123" PRIVATE="0" TOREAD="0" TAGS="clojure,books,learning,schemer,lisp">Amazing LISP Books living again in Clojure | Cool Pacific</A>
<DD>Nice list of &quot;lambda-books&quot; re-written or narrated again with examples in Clojure. I have my copy of Practical Common Lisp that I read sometimes to clarify functional concept. I'm also constantly working on SICP and I sometimes experiment with them in Clojure. I didn't know Stuart Halloway did a series of blog post porting it to Clojure, good to know. Also didn't know about the little Schemer in Clojure, I'm curious to read the Y-Combinator chapter 9.

<DT><A HREF="http://stackoverflow.com/questions/10986293/how-to-set-a-dynamic-var-in-another-namespace" ADD_DATE="1395856360" PRIVATE="0" TOREAD="0" TAGS="clojure,dynamic,binding,var,thread">clojure - How to set a dynamic var in another namespace - Stack Overflow</A>
<DD>This little answer by Chris Houser summarises pretty much everything you need to know when using dynamic vars. alter-var-root works for dynamic vars as well and when used it changes the root for all the references to the var across all threads. There are very few cases in which this could be useful, for example if you store your config in memory and you suddenly need to change it for all the running threads at once.

<DT><A HREF="https://www.youtube.com/playlist?list=PLZdCLR02grLp__wRg5OTavVj4wefg69hM&feature=c4-feed-u" ADD_DATE="1395836085" PRIVATE="0" TOREAD="0" TAGS="clojure,videos,clojure/west,west,2014,conference">Clojure/West 2014 - YouTube</A>
<DD>Huge list of all the latest and the greatest Clojure/West 2014 available on youtube. Looking forward to watch a few of them: Daniel Solano about Clojure internals, David Nolen (curious to understand the buzz around Om) Timothy Baldrige about the clojure AST rendering, David Greenberg on interactive Datomic tooling, and much more. Wondering who did the final keynote. (BTW: interested in watching while commuting offline? Look at http://rg3.github.io/youtube-dl)

<DT><A HREF="http://clojuredocs.org/clojure_core/1.3.0/clojure.core/proxy" ADD_DATE="1395832816" PRIVATE="0" TOREAD="0" TAGS="clojure,proxy,class,generation,extend,asm,byte,code">ClojureDocs - clojure.core/proxy</A>
<DD>Proxy is a function that lets you generate a Java class on the fly. If you ever heard of DynamicProxy in Java this is similar with a twist, considering it also allows to extend concrete classes (thanks to ASM I suppose). For example: (def my (proxy [Exception] [&quot;custom message&quot;])) generates a new instance of a class extending exception and invoking super constructor with a custom message. You can now (throw my) as excepted. More complicated stuff is possible, for example implementing methods from an interface and so on.

<DT><A HREF="https://groups.google.com/forum/#!topic/clojure/pArFVr0fJ0w" ADD_DATE="1395827897" PRIVATE="0" TOREAD="0" TAGS="clojure,release,1.6,some?,hashing">[ANN] Clojure 1.6 - Google Groups</A>
<DD>It is a major version release, the list of changes is impressive, but still it doesn't sound like a ground breaking Clojure release like 1.5 was for example. To note: the new hashing algorithm are going to improve performance in some areas, especially where collections are used as keys in maps. A consolidated Java interface is out (that is, what as a Java programmer you're supposed to use to invoke Clojure). Many more bug fixes, performance improvements (I noticed a 2011 ML thread related to a System.currentTimeMillis() left in the code unused and finally landed into the main branch :)

<DT><A HREF="http://www.lambdassociates.org/blog/bipolar.htm" ADD_DATE="1395786801" PRIVATE="0" TOREAD="0" TAGS="clojure,lisp,history,success,ideas">The Bipolar Lisp Programmer</A>
<DD>Interesting discussion about what ultimately determined Lisp limited success. Mark Tarver describes the negative attitude, a typical behaviour of creative people, to burst into high productive periods followed by deep lack of interest (the bipolar aspect of it). Lisp attracted this kind of people because it was extremely easy to put together a throw-away design and at the same time it was very easy to abandon an idea without making it &quot;world-ready&quot;. Lispers originated many of the ideas that we take for granted today: windowing, personal computing, garbage collection and much more. But those ideas weren't executed carefully enough to survive the industrial world, forcing managers in the industry to prefer easily interchengeable generic developers instead of bipolar lisp programmers. There is also an interesting social aspect of the bipolar programmer: complexity generated by C-based languages and their verbosity tends to produce more communicative teams (literally to search for help).

<DT><A HREF="https://github.com/scgilardi/slingshot" ADD_DATE="1395737021" PRIVATE="0" TOREAD="0" TAGS="clojure,throwable,catch,try,error,exception">scgilardi/slingshot</A>
<DD>Slingshot enhances Clojure error handling through a simple addition (that I never thought about, but it really makes sense). With Slingshot you are able to throw any (Clojure-Java) object, not just those inheriting from Throwable. It makes sense because many times to give more context to an exception I find myself composing a formatted string with all the information I need to send to the Exception constructor. Superpowers come using try+ and throw+ to enable throwing for example a Clojure map. Too bad this is not part of Clojure core: having to import that lib seems a little too much overhead.

<DT><A HREF="http://clojure-log.n01se.net/date/2008-04-28.html" ADD_DATE="1395663836" PRIVATE="0" TOREAD="0" TAGS="clojure,repl,namespace,methods,functions,ruby,inspect,interface,public">#clojure log - Apr 28 2008</A>
<DD>For the oldies but goodies section this week, I found this little snippet browsing an old #clojure IRC log (and BTW this link is a very useful sever that saves the entire chat history for posterity).  Rich replying in the chat how to inspect a namespace for public functions that can be easily enhanced to filter by regex: (filter #(re-matches #&quot;.*print.*&quot; (str %)) (keys (ns-publics (find-ns 'clojure.core)))) will find all the function containing &quot;print&quot; in the core namespace. Use it when autocompletion is not enough!

<DT><A HREF="http://n01se.net/paste/yVa" ADD_DATE="1395352977" PRIVATE="0" TOREAD="0" TAGS="clojure,java,diagram,uml,hierarchy,classes,history">Clojure class inheritance diagram</A>
<DD>This class diagram is old, when Clojure was still released as a timestamped zip file. Many of those classes and interfaces are still present today. The interesting bit is the fact that Clojure at its core was modelled through careful object orientation. More precisely, this diagram shows how the concepts of the Lisp language were modelled through OO: Symbols, Keywords, Namespaces a Callable AFn and so on. Is like teaching Java how to be a Lisp :)

<DT><A HREF="https://github.com/technomancy/leiningen/issues/871" ADD_DATE="1395329786" PRIVATE="0" TOREAD="0" TAGS="clojure,lein,leiningen,profiles,distribute">~/.lein/profiles.d profiles in Leiningen</A>
<DD>Couldn't find a decent explanation of this on the Leiningen readme (where it is just generally saying these profiles will be merged with the main profile). There are many places where you can define a profile in Leiningen: you have your project.clj, /etc/leiningen/profiles.clj, ~/.lein/profiles.clj and also ~/.lein/profiles.d/&lt;younameit&gt;.clj Got my answer on the issue that generated the feature. It is just the only way of all the specified place above where you don't need to explain how to open a file to alter profiles definition if you want to distribute a profile as part of your Clojure app.

<DT><A HREF="http://dev.clojure.org/jira/browse/CLJ-1323" ADD_DATE="1395305819" PRIVATE="0" TOREAD="0" TAGS="clojure,jdk8,asm,reflector,bug">AsmReflector throws exceptions on JDK8 - Clojure JIRA</A>
<DD>The JDK 8 is out. I'm curious to know how that affects Clojure but still have to try myself. Apparently the only minor annoyance around seems to be on the ASMReflector, an util class used to manipulate the Java classes at runtime through reflection. But as far as I can see, the ASM Reflector is not the default and the new version of ASM 5 seems to solve the problem. Another question I have is if from the point of view of the byte code manipulation and generation, there is any advantage with the introduction of the new java closures. I mean, do we have now an alternative to compile clojure functions down to classes or is there now a different way to do it? Not sure.

<DT><A HREF="https://github.com/cursiveclojure" ADD_DATE="1395227050" PRIVATE="0" TOREAD="0" TAGS="clojure,ide,intellij,debug,plugin,editor">cursive clojure</A>
<DD>Cursive is yet another Clojure IDE (in a good sense). At the moment it replaces La Clojure as the reference Clojure plugin for IntelliJ 13.x Not sure if it will be also an independent executable. It works flawlessly in IntelliJ despite its alpha status, where I mostly use it on 3rd parties project exploration, since debugging is still a much better experience outside vim/emacs these days. Installation requires to add a new repo to the System-&gt;plugins settings and after that you just import existing projects by pointing at project.clj. To run an app, create a running config, optionally ticking &quot;running in the REPL&quot; (where you can interact with the running app in debug mode). Sweet.

<DT><A HREF="http://missingfaktor.blogspot.com/2014/03/dead-simple-threading-with-functions-in.html" ADD_DATE="1395152052" PRIVATE="0" TOREAD="0" TAGS="clojure,threading,macros,functions,-&gt;&gt;,-&gt;">Dead-simple threading with functions, in Clojure</A>
<DD>This is an interesting point of view and also a warning (imho). Threading functions have limitations and several libraries around are offering more powerful alternatives. At the same time threading functions were designed with simplicity in mind, to replace a difficult to read &quot;nesting&quot; into a linear invocation. They are great at that and if you find that you're constantly fighting with limitations like the position of the threaded collection (for -&gt;&gt;) or item (for -&gt;) it's maybe just the case to avoid threading. This article shows how threading can be replaced effectively with higher order functions instead of using a 3rd party library.

<DT><A HREF="https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/EdnReader.java" ADD_DATE="1395151690" PRIVATE="0" TOREAD="0" TAGS="clojure,sources,edn,reader,compiler,interpreter">EdnReader.java at master · clojure/clojure</A>
<DD>For our weekly exploration into Clojure sources, this time I'm linking here the EdnReader. In many ways this is similar to the bigger bro, the Clojure compiler. Recognized forms are static declarations at the top, each one handled by an inner class that knows how to parse a specific end form given a reader. Inner classes are AFn extensions, an abstraction on top of some behaviour that can be invoked (pervasive in Clojure). The core is the &quot;read&quot; method that goes through all chars in the input stream analysing them one by one and invoking specific behaviours when a special form-init tag is found. The output is the interpreted Clojure equivalent.

<DT><A HREF="https://github.com/cemerick/friend" ADD_DATE="1395142244" PRIVATE="0" TOREAD="0" TAGS="clojure,security,web,app,authentication,authorisation">cemerick/friend</A>
<DD>An authorisation/authentication framework for Ring based Clojure web app. Friend has a terse API which is quite easy to understand and yet is as powerful as other full-fledged security frameworks. You can attach roles to user and use the same roles when defining routes. Routes and their HTTP verbs are effectively unique ids for an action and with Friend you decide what roles can perform the action (i.e. /docs is accessible to ::guest but /private only to ::admin). Friend also contains other DSL-ish APIs to indicate protected channels (routes that should be redirected if accessed with the wrong protocol) and supports b-crypt encryption.

<DT><A HREF="http://clojuredocs.org/clojure_core/clojure.core/rand-nth" ADD_DATE="1394720694" PRIVATE="0" TOREAD="0" TAGS="clojure,random,rand,rand-nth">ClojureDocs - clojure.core/rand-nth</A>
<DD>Hopefully I'm here again to prevent you another waste of time :) I did the very first time, inventing my own how to access a collection by a random index kind of thing. Sorry, the std-lib got that already and is called rand-nth. That delegates to the old faithful java Math.Random()

<DT><A HREF="https://github.com/clojure/clojure/blob/master/src/clj/clojure/core.clj#L1721" ADD_DATE="1394717930" PRIVATE="0" TOREAD="0" TAGS="clojure,macros,expand,quote,arity,arities">core.clj if-let multiple arities macros</A>
<DD>The interwebs are plenty of Clojure macro tutorials but I couldn't find an example of a macro with multiple arities and how one arity could call another. Well, of course I should have had a look at core.clj. When an &quot;else&quot; part is not present if-let just invokes another arity of the macro passing nil for the :else block. The invocation is actually a syntax quote &quot;back tick&quot; that is that the expansion happens in place with the if-let macro invoked with nil, that then expands again into the final macro form.

<DT><A HREF="http://cfp.euroclojure.com/the_process" ADD_DATE="1394646436" PRIVATE="0" TOREAD="0" TAGS="clojure,conference,euroclojure,cfp,talk">EuroClojure CFP</A>
<DD>EuroClojure will be in Krakow this year and the CFP just opened. The process this year will ensure talks proposal gets better over time and is open for collective (and anonymous) feedback. Please take sometime to review the proposed talks, give feedback and help the biggest european Clojure conference getting even better!

<DT><A HREF="http://avout.io/#avout-atoms-refs" ADD_DATE="1394626066" PRIVATE="0" TOREAD="0" TAGS="clojure,transactions,STM,distributed,netowkring,locks">Avout: Distributed State in Clojure</A>
<DD>Avout is a distributed STM implementation. It promises to maintain the same properties of the locally implemented STM on Clojure data structures with the option of crossing boundaries and persist on different &quot;memories&quot; like zookeeper or Mongo. A couple of use cases are provided, such as distributed Atoms (shared memory) or distributed locks. Since I know that the Clojure STM relies heavily on re-tries to enable consistent sequential state, I wonder how this situation is handled if a network is in between. When the transaction is in memory, even with loads of transaction aborts and restarts, the delay is not really noticeable. Plus what happens when I pull the network cable? How Avout knows that the other side was a commit?

<DT><A HREF="http://www.pitheringabout.com/?p=1018" ADD_DATE="1394543421" PRIVATE="0" TOREAD="0" TAGS="clojure,daily,pither,production,live,experience">Clojure at a Newspaper | Pithering About</A>
<DD>Here's some shameless self-promotion disguised as a Clojure success story. Jon is reporting back after one year of Clojure production experience at the DailyMail and he is now moving on to a new and exciting Juxt adventure. But great news for me, I just joined the Daily to keep the Clojure tradition alive and kicking (along with the great team here). The fun has just started, read the Weekly (and the Daily) to know more :)

<DT><A HREF="http://stackoverflow.com/questions/7354814/using-clojure-symbol-function-to-make-indirect-function-call" ADD_DATE="1394211211" PRIVATE="0" TOREAD="0" TAGS="clojure,symbol,var,reference,deref,invoke,later">using clojure symbol function to make indirect function call</A>
<DD>This is the recipe to store &quot;function pointers&quot; in Clojure and use them at some later time. For example: (map #(@(resolve %) 2 2) '(+ - =)) maps a collection of functions and applies them to the same operands producing the expected (4 0 true). Once a function is defined and has a name (e.g. with defn) the name of the function is technically a clojure.lang.Symbol that when resolved with resolve returns a clojure.lang.Var Once the var is dereferenced with @ it can finally be invoked with parenthesis.

<DT><A HREF="https://github.com/reborg/jscheme" ADD_DATE="1394191375" PRIVATE="0" TOREAD="0" TAGS="clojure,scheme,java,jvm,interpreter,compiler,runtime,repl,learning">reborg/jscheme Scheme in Java by Peter Norvig</A>
<DD>This code repo is the import of the code Peter Norvig released in 1998, a fully working Scheme REPL written in Java. It is decently written and readable and contains all of the main problems you need to face to build a lisp-like language that targets the JVM. Sounds familiar? In looking at the Clojure compiler and runtime these days, I was searching for a lighter implementation of the same problem. Clojure sources aren't that readable (to me) and I hope that by having a look at how a simpler problem of the same type was solved I can learn the Clojure internal faster.

<DT><A HREF="https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/LispReader.java" ADD_DATE="1394119249" PRIVATE="0" TOREAD="0" TAGS="clojure,internals,compiler,core,development">clojure/src/jvm/clojure/lang/LispReader.java at master · clojure/clojure</A>
<DD>Welcome to the Clojure Java Lisp compiler. Woah, three languages just to describe it! The LispReader is certainly one of the most important part of Clojure, if not its essence by definition. This class takes a stream (likely from a clojure file) and reads it char by char, tokenising the content and interpreting the token returning a specific Symbol. It is likely the place where most of the Clojure startup time is spent, considering the length of clojure/core.clj. Core.clj is one of the first step of the Clojure initialisation sequence. Before that, a few Symbols are programmatically (and statically) added to the Symbol dictionary so that core.clj top part can be interpreted. The top is defining what needs to be defined for the rest of the file to be parsed and so on.

<DT><A HREF="http://dev.clojure.org/display/design/Idea+Hammock" ADD_DATE="1394109979" PRIVATE="0" TOREAD="0" TAGS="clojure,development,core,committers,improvements,compiler">Idea Hammock - Clojure Design - Clojure Development</A>
<DD>Yes indeed, Clojure has a wiki to collect ideas. Simple as that. Here you can see for example that people's WTF? reaction opening Compiler.java is a known fact. Also how to get better error messages has a page and many more, including interesting comments from the Clojure core committers and Rich himself giving directions. Core.async stuff and ClojureScripts ideas are also collected here. Be sure to read carefully what is here before posting your complaints to the mailing list, chances are people already discussed the improvement and what is really needed is some help.

<DT><A HREF="http://clojure-liberator.github.io/liberator/tutorial/all-together.html" ADD_DATE="1394106900" PRIVATE="0" TOREAD="0" TAGS="clojure,rest,api,liberator,server,engine,state,workflow">Liberator - Tutorial - All together now</A>
<DD>I linked liberator a while ago, but as my understanding progresses, I'm making a better job at describing it. Liberator builds on top of Ring and Compojure borrowing from the Erlang WebMachine framework to expose the domain as REST resources. Let me rephrase that in another way. The REST protocol can be represented as a flow chart where nodes are decisions based on request parameters, headers and the URI. Liberator invokes handlers you can optionally provide for each of those decision points finally returning a response. Liberator takes care of many details, including status codes (a valid type of response), caching directives and much more. The page linked here is a comprehensive example of how liberator resources look like.

<DT><A HREF="https://groups.google.com/forum/#!topic/clojure-dev/wS6gPj0NGAk" ADD_DATE="1394013424" PRIVATE="0" TOREAD="0" TAGS="clojure,quickcheck,simplecheck,contrib,process,clojure-dev,ml">simple-check contrib - Google Groups</A>
<DD>The Haskell QuickCheck porting to Clojure is ready to enter the contrib as the new simple-check library. Linked here is the usual process about how to do that: after the reasons why a library should become contrib have been discussed in the mailing list, the authors are invited to give their approval for the license and rights. Following that, the library needs to confirm to the contrib namespace, have a Jenkins build and Jira issue space and that's it. As of simple-check, it is a very nice addition. With this approach to testing, you need to think about &quot;invariants&quot; of a piece of code and the library will automatically generates tests around those invariants to verify they hold true. Maybe this is not the best approach for all situations but definitely rocks when invariants are clear and edge cases are tricky.

<DT><A HREF="http://www.functionalgeekery.com/episode-3-fogus/" ADD_DATE="1394011633" PRIVATE="0" TOREAD="0" TAGS="clojure,podcast,fogus,audio,geekery,fp,logic,imperative,scala">Episode 3 – FogusFunctional Geekery | Functional Geekery</A>
<DD>What I like when I learn about the background of the prominent Clojure community figures is that it puts their way to contribute to Clojure, articles, presentations and github projects back into context. It's the case with Michael Fogus, interviewed by Steven Proctor for the Functional Geekery podcast. He's got some interesting programming background, starting with logic programming, then Lisp then Scala (to the point of having wright access to the sources), JavaScript and Clojure. Interesting comparison between imperative, functional and logic programming: they are in decreasing order of real-intent to boilerplate ratio. That is that with imperative programming, your real-intent (the pure business logic) is scattered across a larger area. With logic programming, a language based on tree-searching, you tend to express the exact facts and rules of your goal with a very small syntactic waste. I also suggest to follow his 10 paper every programmer must read list. All many more in the show footnotes. Happy listening.

<DT><A HREF="http://www.functionalgeekery.com/episode-5-colin-jones/" ADD_DATE="1393941878" PRIVATE="0" TOREAD="0" TAGS="clojure,colin,jones,REPL-y,repl,koans,audio,podcast">Episode 5 – Colin JonesFunctional Geekery | Functional Geekery</A>
<DD>Here's another episode from the Functional Geekery series that I like. A few things I didn't know about Colin Jones: he's the creator of Clojure Koans and REPL-y, the REPL I use every time I type lein repl (that is every day). I think the episode gives you an example of a successful path to &quot;Clojure enlightenment&quot; through some of the craftsmanship principles: Colin (who's not coming from a programming background) used clojure koans as a learning tool as well as providing the rest of the community with a great learning resource. REPL-y is a simple contributions that makes a lot of difference in everyday programming. He did not stop at Clojure: learning other FP languages (like Haskell) will give you part of the background to understand Clojure (Rich Hickey borrowed from Haskell as well as many other interesting languages while designing Clojure). He's working on another great contribution, co-authoring a book on macros for Pragmatic Press. Overall a pleasant listening with many episodes links to follow right after.

<DT><A HREF="https://github.com/ring-clojure" ADD_DATE="1393921545" PRIVATE="0" TOREAD="0" TAGS="clojure,ring,servlet,api,jetty,compojure">Official Ring Repositories</A>
<DD>The ring family contains the core (linked here), a few middleware (inside the ring repo) and the Jetty adapter. But it makes much more sense when you also add the lein-ring plugin (for dev) which in turns uses the ring-server (also for dev) which in turns deploys everything on the embedded jetty-adapter. You just want to add Compojure on top, because without routing macros it could end up in a giant mess. The ring middleware modelling of requests and responses is a simple concept. Less simple is to understand how all of the above small pieces collaborate together. The good news is that you don't need to know (most of the cases). But just in case you are wondering what are we dealing with, I think the Ring family can be described roughly as a Clojure layer on top of the Java Servlet API (and Jetty embedded APIs if you don't deploy a war) that gets translated into a set of Servlet Filters, Servlet mappings and configuration (programmatic or xml). I think the tendency of describing the Clojure web app approach as a set of isolated small pieces derives mainly from how Ring was laid out in the first place.

<DT><A HREF="https://github.com/jpalardy/vim-slime" ADD_DATE="1393605749" PRIVATE="0" TOREAD="0" TAGS="clojure,emacs,vim,plugin,cider,slime">jpalardy/vim-slime</A>
<DD>Here's what happens when you look around other editors and see what you like and what you don't. Emacs Cider better integration prompted some searching about how to evaluate code without copy paste into a proper REPL. I'm used to have a tmux pane opened with a lein repl running, so vim-slime seemed a straightforward choice. Now I can ctrl+c+c to send a paragraph for evaluation to the live REPL hosted in tmux or gnu screen.

<DT><A HREF="http://www.codequarterly.com/2011/rich-hickey/" ADD_DATE="1393578192" PRIVATE="0" TOREAD="0" TAGS="clojure,history,rich,fogus,dotLisp,Foil,Lisplets">Code Quarterly - Rich Hickey interview</A>
<DD>I found this slightly old (2011) but very good in-depth interview on Clojure and its history from Rich The-Man himself interviewed by Michael Fogus. Here you can learn more about Rich learning, thinking and design process. Rich doesn't not &quot;exercise&quot; on programming, but rather puts a lot into thinking about programming ahead of the keyboard (and time not spent programming is used to read relentlessly books or academic papers). The discussion moves on to language families, Clojure influences and OOP Classes that Rich compares to having to write each chapter of a book using a different language. As of the history part, Rich was big on C++ and then discovered the flexibility of Lisp, in particular that with Lisp he's able to write only code that matters achieving great degree of focus. With each of the Clojure predecessor (dotLisp, Foil, and Lisplets), Rich experimented with aspects of writing List targeting an hosting VM.

<DT><A HREF="http://http-kit.org/" ADD_DATE="1393498594" PRIVATE="0" TOREAD="0" TAGS="clojure,http,async,server,performances,core.async">Home | http-kit, high performance HTTP Client/Server for Clojure</A>
<DD>Ever wondered if Java Servlets (a technology from 1997) are making good use of IO primitives?  You need to take that into account when selecting your Clojure web framework. In general, a Java based HTTP server can take two approaches to serve file system resourcest: using the synchronous access or using NIO (aka New IO) a Java standard library introduced with Java 1.4 which makes asynchronous access to external resources. The model is completely different: you need callbacks to receive chunks of bytes whenever they are ready but at least you can re-use the same thread for other work when no chunk are getting processed. HTTP-Kit is a mostly-drop-in replacement for Ring that allows asynchronous processing of resources. The net result is that the amount of HTTP requests that can be served concurrently increase dramatically. No changes for the Ring HTTP protocol handling: a route defines what to invoke and ring middleware can be plugged-in in the chain. It is just the core processing that is changing and is asynchronous and when you do that you're in danger of the so called callback hell (and not far away from the node.js approach). Read below on how to deal with that.

<DT><A HREF="http://martintrojer.github.io/clojure/2013/07/07/coreasync-and-blocking-io/" ADD_DATE="1393498561" PRIVATE="0" TOREAD="0" TAGS="clojure,core.async,core,async,io,http-kit,netty,performances">core.async and Blocking IO</A>
<DD>This is a nice overview by Marting Trojer about using core.async with different asynchronous IO libraries. The main message is that there is no &quot;core.async&quot; that can help if the operation sent down the channel is a synchronous operation. It will just clog the thread pool core.async is using to deal with requests. Where core.async really shines is where an asynchronous operation (thus requiring some form of callback mechanism) is sent down the pipe. It includes examples with Netty and HTTP-Kit.

<DT><A HREF="http://www.pitheringabout.com/?p=1030" ADD_DATE="1393497459" PRIVATE="0" TOREAD="0" TAGS="clojure,repl,nrepl,emacs,vim,cider,tool,plugin">Managing Multiple REPLs with Emacs Cider – Screencast | Pithering About</A>
<DD>Cider is an indispensable add-on for Clojure emacs users. The list of features is impressive (as it is the list of keyboard shortcut you'll have to learn) and it is very well integrated with Emacs. Integrated means that everything that you're working on in an editor window can be subject to Cider evaluation and functionalities. In VIM there is something similar but without that level of integration (vim-fireplace calls it a quasi-REPL). In general VIM is less effective embedding outside functionalities in a window pane. In this screencast Jon Pither shows how to work with multiple nREPL connected at the same time.

<DT><A HREF="http://www.functionalgeekery.com/episode-1-robert-c-martin/" ADD_DATE="1393496758" PRIVATE="0" TOREAD="0" TAGS="clojure,podcast,audio,unclebob,fp,oop,solid,tdd,rdd">Episode 1 – Robert C. Martin | Functional Geekery</A>
<DD>I'm Impressed by the quality of all the episodes of the new Functional Geekery podcast and today I'm reviewing the first of the series. Uncle Bob is the usual entertaining speaker this time talking about the relation between FP and other paradigms. A little review of SICP and teaching programming. FP can be easier to teach when you don't have to explain that x = x + 1 is perfectly fine in an imperative language (and of course is counter intuitive that x is equal to x + 1, &quot;no is not!&quot;). SICP does a great job at introducing all modern computer science topics at a terrific speed and treating assignment and concurrency as element of &quot;corruption&quot; in the theory. Just to stress that again: REPL driven development is not a replacement for TDD. TDD is like double book-keeping, stating your things twice to make sure you get them right and driving the implementation after stating your goals. FP also gives some more evidence to the Transformation Priority Premise, verifying that in general avoiding assignment and using recursion head toward better implementations. FP tends to insinuate that you need to develop bottom up, so higher abstraction functions can call lower level ones. But with FP you can mock at the function level, something that in OO was unheard of (mock is at the object level), making top-down outside-in approaches pretty possible (see Midje). Many of the SOLID principles still hold true in FP and others are generalizable by looking at the underlining principles. Liskov substitution for example doesn't work on polymorphism anymore in FP, but it still works at dispatching functions during runtime. A must listen in terms of clarity of explanation of such complicated concepts.

<DT><A HREF="http://stackoverflow.com/questions/18381052/why-clojurescript-macros-cant-be-written-in-clojurescript" ADD_DATE="1393352424" PRIVATE="0" TOREAD="0" TAGS="clojure,clojurescript,macros,require">clojure - Why clojurescript macros can't be written in clojurescript? - Stack Overflow</A>
<DD>This is the answer if you ever wondered why there is a special require-macros namespace directive in ClojureScript. Essentially, ClojureScript is interpreted by Clojure code, not the reader of the Clojure compiler. This Clojure ClojureScript compiler was not enhanced to deal with macros, task that is delegated to the normal Clojure compiler. For this reason macros needs to be read from Clojure code and expanded in the produced JavaScript.

<DT><A HREF="http://galdolber.tumblr.com/post/77153377251/clojure-intrinsics" ADD_DATE="1392816425" PRIVATE="0" TOREAD="0" TAGS="clojure,performances,hint,types">(shuffle thoughts) — (clojure intrinsics)</A>
<DD>Again on some Clojure performance tuning. Whenever you search for raw speed and you know your types (and your operations won't generate overflow) you should never read in you Clojure code the plain operators: +, -, *, / and so on. Those are checked operations that add the additional semantic of throwing an exc on overflow. You should always type hinting when possible, like this article is showing. With the type hint Clojure can select the right function from the list of intrinsics functions avoiding the unnecessary overhead.

<DT><A HREF="http://www.functionalgeekery.com/" ADD_DATE="1392803999" PRIVATE="0" TOREAD="0" TAGS="clojure,audio,podcast,functional,iTunes">Functional Geekery</A>
<DD>Signalling a new podcasts (5 episodes at the moment) from the 8thlight guys. They are featuring functional programming in general, but from their work with Clojure I suspect is going to be heavy on that. First guests seem to confirm it: Uncle Bob, Fogus, Colin Jones and other usual suspects from the Clojure community. Looking forward to hear the episodes, you should do it too!

<DT><A HREF="http://clojuredocs.org/clojure_core/clojure.core/declare" ADD_DATE="1392802674" PRIVATE="0" TOREAD="0" TAGS="clojure,declare,forward,declaration">ClojureDocs - clojure.core/declare</A>
<DD>I rarely had the need for something like this, but it's useful to remember that also in Clojure (like other multiple-pass languages compilers) you can have forward declarations, that is the possibility to use a symbol before it is defined. Not having this &quot;feature&quot; by default makes it so your code is organised with the low-level functions at the top and the public interface at the bottom of the namespace, which is overall a nice convention. In those rare cases where you need to use forward declare (mocking? double recursion?) declare is there for you. Also a simple def will do, but declare is more explicit in this sense.

<DT><A HREF="https://groups.google.com/d/msg/clojure/tseJgAi3HC4/dAH1mORQjAoJ" ADD_DATE="1392654246" PRIVATE="0" TOREAD="0" TAGS="clojure,release,beta,latest,changes,improvements">[ANN] Clojure 1.6.0-beta1 - Google Groups</A>
<DD>Clojure 1.6 beta is out for review. No huge changes but general improvements and bug fixing. A feature generating some discussion is another flavour of (some?) that only checks for nil-ness but has different semantic compared to the already editing (some). Another noticeable improvement is on hash functions that are now less prone to surprises in case of certain use cases (there was a long and interesting discussion about this in the mailing list).

<DT><A HREF="http://charsequence.blogspot.in/2012/04/scripting-clojure-with-leiningen-2.html" ADD_DATE="1392384158" PRIVATE="0" TOREAD="0" TAGS="clojure,devops,scripting,executable,configuration">Scripting Clojure with lein-exec</A>
<DD>With a shebang on top, optional Pomegranade dependencies and unix pipe support, this lein plugin can be insanely useful. It's not far away from java -jar clojure.jar of some clojure file after all, but having the specific Clojure version handled by leiningen (including the easy install) it's a win. An example scenario would be to script the startup of another more complicated Clojure app, preparing files and the system environment. More in general, it is a quick and effective way to do system scripting directly in Clojure.

<DT><A HREF="http://www.elmindreda.org/emacs.html" ADD_DATE="1392218615" PRIVATE="0" TOREAD="0" TAGS="clojure,emacs,vi,comparison">Emacs for vi users</A>
<DD>As soon as you have an emacs environment ready to accept some code, the next step is to exercise to gain speed. One way to orientate coming from vi, is to find first the editing steps you're used to. This quick comparison between emacs and vi editing shortcuts (from the vi perspective) should make you feel home quickly.

<DT><A HREF="http://clojure-doc.org/articles/tutorials/emacs.html" ADD_DATE="1392218459" PRIVATE="0" TOREAD="0" TAGS="clojure,emacs,vi,editor,tools,learning">Clojure with Emacs | Clojure Documentation | Clojure Docs</A>
<DD>Probably the best getting started guide out there to getting started from zero emacs to basic work in a Clojure project. Why would you want to switch to emacs when you're already proficient with vi? First of all, this is the wrong question. Moving from vi to emacs or vice-versa is about learning another tool, not switching. The goal is to train your brain and finger memory to quickly switch between the two. So the right question: why learning vi and emacs? First: learn how similar problems were solved starting from a different perspective and cross-pollinate other editors with it. Second: the freedom to make other people comfortably working with you. The second aspect is more fascinating for me: I don't care what language you speak, I can speak yours.

<DT><A HREF="https://github.com/stuartsierra/class-diagram" ADD_DATE="1391640754" PRIVATE="0" TOREAD="0" TAGS="clojure,diagram,classes,png,image,generate">stuartsierra/class-diagram</A>
<DD>Interesting utility to generate class diagrams from Clojure. The readme already shows important facts about the complexities of the Clojure object system. Wait Wat?!? When functional language is based on Java there will be some classes and interfaces around plus inheritance. The important part is that this is all hidden during normal Clojure development, except of course when you need to extend or reify protocols. At that point a quick diagram visualisation of what's going on is pretty useful.

<DT><A HREF="https://www.youtube.com/user/Misophistful?feature=watch" ADD_DATE="1391640236" PRIVATE="0" TOREAD="0" TAGS="clojure,tdd,videos,screencast">Misophistful - YouTube</A>
<DD>Quick one to signal a series of Clojure screencasts worth watching, especially if you're interested in TDD with Clojure.

<DT><A HREF="http://blog.jayfields.com/2014/01/repl-driven-development.html" ADD_DATE="1391081644" PRIVATE="0" TOREAD="0" TAGS="clojure,tdd,repl,rdd,process">Jay Fields' Thoughts: REPL Driven Development</A>
<DD>Here's Jay's take on REPL driven development, REPL based development, testing first and testing after. It is a spot on explanation of what REPL driven development is with included screencast. I'm happy to see that I'm not the only one to think that REPL driven development does not replace TDD, as many Clojure developers tend to believe. You heard that right, REPL driven development is not the next excuse to avoid TDD! It is instead a complementary option to TDD (and you might still decide not to TDD based on your background and project context)and instead do some test after to cover regressions). Well said.

<DT><A HREF="https://github.com/galdolber/clojure-objc" ADD_DATE="1390976708" PRIVATE="0" TOREAD="0" TAGS="clojure,objectiveC,objc,bridge,translation,iOS">galdolber/clojure-objc · GitHub</A>
<DD>Although in alpha state, this is quite an interesting project. The target is not to write entire iOS apps, but more library-like code in Clojure that can then be used from a full fledged iOS app. It is a &quot;double hop&quot;: it uses java interop to talk to J2ObjC that then translates into Objective C. I think it's an interesting approach for all those mobile apps that have some core algorithmic feature that makes sense to be written functionally, as well as concurrent code that benefits from STM.

<DT><A HREF="https://github.com/prismatic/hiphip" ADD_DATE="1390917534" PRIVATE="0" TOREAD="0" TAGS="clojure,java,arrays,performance,idiomatic,algorithm">Prismatic/hiphip</A>
<DD>As soon as you are starting writing fast algorithms in Clojure you will sure encounter the need of manipulating native arrays. This is already 100 times better than the Java counterpart, but Clojure arrays manipulation is not properly idiomatic (how could it be!) and missing one reflection warning can make things way slow. This little lib is bridging the gap between the need of manipulating array natively in Clojure and a nicer and more idiomatic interface. It also includes all of the standard optimizations needed to make it faster.

<DT><A HREF="http://rubyrogues.com/137-rr-book-club-functional-programming-for-the-object-oriented-programmer-with-brian-marick/" ADD_DATE="1389800498" PRIVATE="0" TOREAD="0" TAGS="clojure,rogues,podcast,audio,marick,fp,hashes">137 RR Book Club – Functional Programming for the Object-Oriented Programmer with Brian Marick</A>
<DD>Entertaining interview with Brian Marick on this RR episode. Brian is author of Functional Programming for the Object-Oriented Programmer, a book specifically created for developer coming from an OO background and interested in learning FP (as well as the Midje test framework). Some interesting discussion about the flexibility to use hashes as generic containers that flow in the application and are enriched or filtered of their data as part of the processing. Having a good test suite is important for Brian to scale the approach up. Some discussion about naming conventions (the typical example of the entry point without accumulator that invokes the recurring function with accumulation). The recipe to scale up Clojure projects and keep them organized is in Brian's opinion, the same as how to scale agile teams up: don't. I also experienced the same, as the project grows above a few namespaces, it's extremely cheap to just create another project and let them talk some serialization language (Edn for example). More in the book, which I have and I started but never managed to finish.

<DT><A HREF="https://github.com/xfeep/nginx-clojure" ADD_DATE="1389797619" PRIVATE="0" TOREAD="0" TAGS="clojure,nginx,webapp,ring,deploy">xfeep/nginx-clojure</A>
<DD>This is a new addition to the Clojure sphere to deploy ring based web apps directly into Nginx. Normally, you would point some Nginx proxy pass to an instance of your already running ring application and let Nginx handle static resources for example. There is even another approach using uWSGI, where Nginx can be instructed to talk a specific protocol to the JVM hosting the Clojure webapp. nginx-clojure is even more radical, it run the JVM directly as an Nginx worker removing any socket communication from the equation. It is very new but worth a look.

<DT><A HREF="https://github.com/stuartsierra/component" ADD_DATE="1389722549" PRIVATE="0" TOREAD="0" TAGS="clojure,di,dependency,injection,approach,system,reload">stuartsierra/component</A>
<DD>Dependency injection is getting momentum in Clojure. I remember that happening for Ruby too at some point but getting nowhere. It could be or not the case for Clojure, but definitely solves an organizational issue when parts of the code are clearly related to some state (databases, 3rd party APIs or an in memory cache). Component framework by Stuart Sierra includes a convention for dependencies and handling of state. I'm still struggling to see the value for this, including the live-lifecycle approach to keep the REPL alive at all costs. It's very likely I never built large enough Clojure systems.

<DT><A HREF="https://github.com/reborg/binpack" ADD_DATE="1389636935" PRIVATE="0" TOREAD="0" TAGS="clojure,algorithms,binpack,knapsack">reborg/binpack</A>
<DD>Ever wondered how to pack stuff for your next expedition so that they fit inside the containers you have available? Look no further and give a look at this solution of the bin packing problem I recently have some fun developing. Nothing incredibly complicated, but there is also a small fit functions attempting configuration automatically and returning the best fit.

<DT><A HREF="http://www.infoq.com/articles/real-world-ocaml-interview" ADD_DATE="1389359608" PRIVATE="0" TOREAD="0" TAGS="clojure,ocaml,functional,static,typed,gil,gc">Book Review and Interview: Real World OCaml</A>
<DD>It's always good to compare good languages. Clojure explicitly borrows from many (thinking at core.async inspiration coming from Go, or just the fact that Clojure is a Lisp on steroids). This is a quick interview with two of the major developer of nowadays industrial OCaml. OCaml distinguishes itself from other static typed functional languages mainly for its performant GC, lightweight but powerful type system and pluggable syntax extensions. Unfortunately it has a GIL (global interpreter lock) that prevents true multithreading, but OCaml makes good use of processes and message passing for concurrency. Good list of resources at the end of the article.

<DT><A HREF="http://stackoverflow.com/questions/12575161/destructure-parameter-of-a-clojure-function-while-keeping-the-original-value" ADD_DATE="1389289777" PRIVATE="0" TOREAD="0" TAGS="clojure,destructuring,collection,first,rest,recur">destructuring - Destructure parameter of a Clojure function while keeping the original value. - Stack Overflow</A>
<DD>Destructuring is a small pattern matching language inside Clojure. Too bad it can only be used in a few places (it's not pervasive as say, in Erlang). But what you can do with it in Clojure is pretty slick. Probably one foundamental usage is when passing collections to functions where their main use inside is about checking the first element and process the rest. All of that can be done at parameters declaration with (defn blah [c1 &amp; crest :as coll])  and here you go: you can now use c1 (the first element of the collection) crest (maybe to recur on the rest of the collection) and coll if you need the entire thing.

<DT><A HREF="http://chrisdone.com/posts/dijkstra-haskell-java" ADD_DATE="1389200480" PRIVATE="0" TOREAD="0" TAGS="clojure,functional,imperative,djkstra,teaching,java,haskell">Dijkstra on Haskell and Java</A>
<DD>Interesting reading on HackerNews today (with an expected ending). Prof. Dijkstra is writing to the member of the Budget Council to ask that Haskell is not replaced by Java as the introductory course base language for the CS course. Reasons are the mediocrity of Java compared to the Haskell design, a language that for prof. Dijkstra is &quot;salesmanship driven&quot;. The thread on HackerNews offers also another way of looking at it (other than comparing imperative and functional programming). Another approach is from the bottom up, where people introduce to the art of programming are working on something that is as close as possible to the bare metal (C, Assembly) and then build powerful abstraction later in the curriculum.

<DT><A HREF="https://groups.google.com/forum/#!msg/clojure/4oFhZAk2QC8/dfDlfHXoRpUJ" ADD_DATE="1388771340" PRIVATE="0" TOREAD="0" TAGS="clojure,design,philosophy,tradeoff,bad,good">In your opinion, what's the best, and what's the worst aspects of using Clojure? - Google Groups</A>
<DD>I heard this question many times already, but since the language evolves it's good to keep the reasoning up to date. A part from the ever-green Clojure bad error reporting, I liked James Reeves answers which is what I want to remember here. Error reporting, slow startup times or lacking of continuations or tail call optimization are all part of the compromise to run on the JVM. At the same time this is one of the strength of Clojure. So if we'll ever be able to bootstrap Clojure in Clojure there will be also some hard time replicating all the good tooling of the Java ecosystem.

<DT><A HREF="https://github.com/Netflix/PigPen" ADD_DATE="1388766353" PRIVATE="0" TOREAD="0" TAGS="clojure,pigpen,pig,hadoop,mapreduce,cascalog">Netflix/PigPen</A>
<DD>A few months ago I saw PigPen mentioned in a slide deck released by someone at Netflix, including the intention at some point to release it open source. Here we go! PigPen is a pig-scripts generator written in Clojure. You write query logic in Clojure and PigPen generates pig scripting ready to be submitted to the Hadoop cluster. The generated script is not meant for human consumption. The overall idea is to take advantage of the Pig query optimizer without re-inventing the wheel but at the same time to write map-reduce jobs in a full fledge language. PigPen is direct competitor of Cascalog and removes the need to learn the Datalog way of querying and some trouble with ordering of parameters with implicit joins.

<DT><A HREF="https://github.com/technomancy/leiningen/commit/39732d5b649dedb70b14e88fe561dfc9ddb31611" ADD_DATE="1386868622" PRIVATE="0" TOREAD="0" TAGS="clojure,leiningen,naming,names,funny">Enough is enough. · 39732d5 · technomancy/leiningen</A>
<DD>Have you named some of your Clojure project something like &quot;conjure&quot;, &quot;perjure&quot;, &quot;torjure&quot; etc? Well, don't try to create something ***jure in the future with Leiningen because it's not allowed anymore, by design! LOL

<DT><A HREF="http://blog.cloudera.com/blog/2013/12/write-mapreduce-jobs-in-idiomatic-clojure-with-parkour/" ADD_DATE="1386365385" PRIVATE="0" TOREAD="0" TAGS="clojure,mapreduce,bigdata,map,reduce,damballa">Write MapReduce Jobs in Idiomatic Clojure with Parkour | Cloudera Developer Blog</A>
<DD>Here's another version of Apache Map-Reduce under Clojure control. Parkour is a thin layer that wraps the Map-Reduce Java API. As the article explains you can do exactly the same things with a fraction of the code. Notably, map or reduce jobs are written as function instead of having to create a class scaffolding.

<DT><A HREF="https://docs.google.com/presentation/d/15-7qFy6URdE7Owi2LitkQI_OHBu1AFWPUwHxgBc-O4E/preview?usp=sharing&pli=1&sle=true#slide=id.g177bd4cb5_0229" ADD_DATE="1385728314" PRIVATE="0" TOREAD="0" TAGS="clojure,intro,basic,presentation,slide,misconceptions">Clojure: the JFDI language</A>
<DD>I like to keep track of good introductory presentation to Clojure, especially like this one when they are straight to the point and humorous. Probably the central part is the list of common Clojure misconception and the explanation why those arguments aren't really worth discussing. GoogleDoc -  Slide based format.

<DT><A HREF="http://swannodette.github.io/2013/11/07/clojurescript-101/" ADD_DATE="1385559529" PRIVATE="0" TOREAD="0" TAGS="clojure,clojurescript,core.async,tutorial">ClojureScript 101</A>
<DD>A simple and clear tutorial that explains the impact of core.async for clojurescript development. Clicking on a button generated an event you have to listen to to act upon, providing a function that should execute when that button is pressed. Since the place in the code where the callback is declared is not the same context in which some action should be taken on the event, what used to happen was that you had to pass down the callback some piece of global visible state. The click event is instead placed on a channel without any knowledge about what happens on the other side. Responding to an event looks sequential when instead it is not. No state flying around required. Much more difficult to explain than to go through this tutorial (30 mins).

<DT><A HREF="http://hadihariri.com/2013/11/24/refactoring-to-functionalwhy-class/" ADD_DATE="1385383136" PRIVATE="0" TOREAD="0" TAGS="clojure,oo,fp,object,oriented,functional,paradigm,parody">Refactoring to Functional–Why Class? | Hadi Hariri's Blog</A>
<DD>This is a parody of a refactoring where an OO model is transformed gradually toward a mere container of functions without a state. Indeed this is the case for many scenarios we attempted to constraint business logic in the past using one paradigm only. Also have a look at the related discussion on HackerNews https://news.ycombinator.com/item?id=6790392 were the argument is made that there are very good cases for OO as well as for FP. As usually, best tool for the job FTW.

<DT><A HREF="https://github.com/sdegutis/clojuredocs/wiki/clojure.core-map-indexed" ADD_DATE="1384515517" PRIVATE="0" TOREAD="0" TAGS="clojure,stdlib,core,string,indexes">clojure.core map-indexed · sdegutis/clojuredocs Wiki</A>
<DD>map-indexed is totally useful when you need to act on a specific repeating item on a list. When the item repeats in the collection, but the processing you need to do is not trivial (ie is not on all of the same items or not the first occurence of the item) map-indexed offers you a way to know all the indexes in which something occurs in a collection. Use on string as sequences, you can use map-indexed to process the last char occurrence on a string or other non trivial occurrences in the list.

<DT><A HREF="http://let-caribou.in/" ADD_DATE="1384353033" PRIVATE="0" TOREAD="0" TAGS="clojure,framework,caribou,rails,crud">let-caribou-in - Powered By Caribou</A>
<DD>Another interesting web framework called Caribou. But this time we are midway between a CMS, CRUD model editor and a web framework which makes it compelling in all those situation where you need to open a &quot;window&quot; to your data in a somehow automatic way. Creation of a project thanks to lein and migrations seem to be Rails inspired, as well as the overall project structure. Will give it a go.

<DT><A HREF="https://groups.google.com/forum/#!msg/midje/kJzGsCYfKrc/6Qbz_egi0g0J" ADD_DATE="1383934533" PRIVATE="0" TOREAD="0" TAGS="clojure,midje,refactoring,repetition,duplication,custom,checkers">Parametrize fact? - Midje</A>
<DD>Here's a clear example of an old-school mindset (me) thinking that something like a parametrized fact should be something difficult to achieve, maybe with a macro or some obscure Midje extension. Let me back up a second: this is the problem where one of your fact contains many checkers and the list is growing long and full of repetition. Wouldn't be nice to have some syntax sugar on top of =&gt; to remove part of the duplication? Can I &quot;override&quot; =&gt; in Midje? It is much simpler than that. I never realized that what's coming after =&gt; in a Midje fact is a function taking what is on the left of the arrow and returning a boolean! So anything in the form of &quot;response =&gt; 200&quot; can be also written as &quot;response =&gt; ok&quot; with (defn ok [response] (= 200 response)). Do you need the custom checker to take a param? Use defchecker macro.

<DT><A HREF="http://cemerick.com/2013/11/05/2013-state-of-clojure-clojurescript-survey/" ADD_DATE="1383664690" PRIVATE="0" TOREAD="0" TAGS="clojure,survey,chas,emerick,adoption,community">2013 State of Clojure &amp; ClojureScript Survey | cemerick</A>
<DD>Please take a minute or two to complete the annual Clojure survey Chas has put together for this year. Results are helping the Clojure core steering committee to understand what area of Clojure should receive more attention, plus interesting statistics about the Clojure community and the language adoption. I remember I commented on last year results, I hope to see improvements in all the relevant areas.

<DT><A HREF="http://www.infoq.com/presentations/machine-learning" ADD_DATE="1383659368" PRIVATE="0" TOREAD="0" TAGS="clojure,prismatic,real,world,scenario,usecase,use,case">Machine Learning for Relevance and Serendipity</A>
<DD>Strangeloop 2013 videos are starting to appear on InfoQ. This is the opening Keynote by Prismatic chief architect, Jenny Finkel. Prismatic is making good use of Clojure for machine learning and data processing. The talk is not a lot about Clojure, but more about a typical use case for it. Machine learning algorithm that tries to identify and evolve a classifier of what is interesting based on user behavior. What is interesting is that creating the classifier, the first step, is just the tip of the iceberg. The classifier needs almost constant evolution to become better and flexible in real-world scenarios. Prismatic technology is at the end a team of 5/6 tech people, it's amazing to see what they achieved.

<DT><A HREF="http://www.exampler.com/blog/2010/09/01/editing-trees-in-clojure-with-clojurezip/" ADD_DATE="1383658967" PRIVATE="0" TOREAD="0" TAGS="clojure,tree,zipper,idiomatic,path,location">Editing trees in Clojure with clojure.zip</A>
<DD>If you never heard of Clojure zip (or mistakenly though of a compression library) is because you probably never worked extensively with tree data structures. Zippers are a cursor-like abstraction to express a path to a location in a tree. clojure.zip adds to that some editing features and general tooling. A zipper path in Clojure can idiomatically be expressed like (-&gt; loc z/down z/right) making good use of the thrush operator where loc is a location in a tree and the list of &quot;moves&quot; you need to reach the target leaf. Brian Marick explains in this post how to deep-first traverse and edit a tree, plus other concept related to zippers.

<DT><A HREF="http://thinkrelevance.com/blog/2013/10/08/ambrose-bonnaire-sergeant-cognicast-episode-042" ADD_DATE="1383655996" PRIVATE="0" TOREAD="0" TAGS="clojure,core.typed,static,typing,haskell,ambrose,podcast,audio">Blog | Ambrose Bonnaire-Sergeant - Cognicast Episode 042 | Relevance</A>
<DD>What I like about Ambrose is that he tends to &quot;dismiss&quot; his core.typed work like a half-baked copy of other well formed languages like Haskell. In doing so he describes core.typed and the theory of static typing in very simple terms that anyone can understand. Not only he's doing a great job with core.typed, but he's also contributing to the general understanding of the (complex) matter. Coming from a static typing programming background, I personally never seen the process of adding it on top of a language incrementally. Clojure approach to typing is not invasive and targeted to areas where it clearly makes sense, like the API contract between two applications and design by contract.

<DT><A HREF="https://groups.google.com/forum/#!topic/clojure-dev/lWXYrjaDuIc" ADD_DATE="1383655791" PRIVATE="0" TOREAD="0" TAGS="clojure,hash,performance,hashing,collision">Hashing strategies - Executive summary - Google Groups</A>
<DD>Java hashing strategy is not optimized for collections, set and hash maps (not even for longs). It is sort of okay in the Java world where key for hashmaps (one common use of hash computation) are rarely compound keys, namely HashSet, Vectors or Sets. But in Clojure this case is much more common. The terse syntax in Clojure easily allows for nested structures often used as keys. So if you happen to solve the N-queens problem using board positions as keys inside an hashmap you may encounter the problem where  20M board positions hash to 18K hashes only generating tons of collisions. This thread on the Clojure mailing list is the story of the discovery of the problem and how it could be fixed taking the 10+ hours necessary at the moment down to 12 minutes.

<DT><A HREF="http://www.neo.com/2012/11/20/y-not-adventures-in-functional-programming-part-ii" ADD_DATE="1383155171" PRIVATE="0" TOREAD="0" TAGS="clojure,refactoring,tennent,ruby,lambdas,moves">Neo · Y-Not? - Adventures in Functional Programming (Part II)</A>
<DD>There is a definitive lack of literature about refactoring of homoiconic dynamically typed languages. It goes a little better for statically typed languages like Haskell. The only somehow relevant reference seems to be Jim Weirich's presentation on dissecting the YCombinator. It is a totally awesome talk you should stop now and watch right away, but this is a post containing just a transcription. Anyway it contains four refactoring moves (in Ruby) that are perfectly valid in any language supporting lambdas. This is the closest I could find of refactoring in the Martin Fowler book sense. I'm not sure if idiomatic changes like replacing nested calls with -&gt; are exactly refactorings. That sounds like, indeed, idiomatic use of the syntax provided by a language. I'm searching for catalogs like this one, if you know, please post the link in a comment below.

<DT><A HREF="http://clj-me.cgrand.net/2010/01/19/clojure-refactoring-flattening-reduces/" ADD_DATE="1383154118" PRIVATE="0" TOREAD="0" TAGS="clojure,for,reduce,nested,idiomatic">Clojure and me » Clojure refactoring: flattening reduces</A>
<DD>Just had a quick glance at this code by Christophe Grand and thought that is awesome how a few powerful constructs are exponentially increasing expressiveness when used together. This is the case in many parts of Clojure. When the abstraction at the bottom (homoiconicity) is powerful, building up on top of those basic bricks creates solid building. It also tells you a lot about the fact that the Clojure &quot;for&quot; has nothing to do with the imperative &quot;for&quot;.

<DT><A HREF="https://github.com/sdegutis/clojuredocs/wiki" ADD_DATE="1383116485" PRIVATE="0" TOREAD="0" TAGS="clojure,docs,learning,examples,snippets">Home · sdegutis/clojuredocs Wiki</A>
<DD>Wow, some more work by Steven Degutis (I already linked here http://clojuretip.herokuapp.com). This must have been quite an effort, to cover all the standard library functions on the page with some usage example and explanation. This seems a good replacement for the not so up to date clojuredocs.org, definitely coming back here for more examples pretty soon. Thanks Steve, very useful.

<DT><A HREF="http://clojuretip.herokuapp.com/" ADD_DATE="1383116244" PRIVATE="0" TOREAD="0" TAGS="clojure,learning,dojo,random,tips,doc">ClojureTip</A>
<DD>Neat idea here, a web site that shows random Clojure doc strings every time you load the page. There are many possible uses: your browser homepage, the Clojure quiz night with friends at the Dojo, kill a couple of minutes time while compiling with maven :)

<DT><A HREF="https://dl.dropboxusercontent.com/u/18288740/talks/clojuresmells.pdf" ADD_DATE="1383053547" PRIVATE="0" TOREAD="0" TAGS="clojure,refactoring,smells,design,euroclojure">Clojure Smells (pdf slides)</A>
<DD>Refactorings are triggered (usually) by code smells. These slides by Jen Smith are a great list of several of those, with added examples, from EuroClojure 2013. I suppose the talk will be available as a video pretty soon as well. I agree about the description of many of those. Excessive nesting is for example something I trigger as well by looking at the last set of closing parenthesis: too long is not good. It's very similar to nested (usually conditionals) in disguised procedural code in OO. It also made me think about excessive knowledge of map internal structures (magic keys). Defrecord and Protocols to alleviate that.

<DT><A HREF="http://stackoverflow.com/questions/9717606/how-to-remove-multiple-keys-from-a-map" ADD_DATE="1382961782" PRIVATE="0" TOREAD="0" TAGS="clojure,map,keys,remove,contains,dissoc">clojure - How to remove multiple keys from a map? - Stack Overflow</A>
<DD>Here's another useful one. The goal of this snippet is to remove a list of keys we don't want to process in a map, something that happens often enough during data transformation. The I-don't-want-to-look-at-the-stdlib solution is something like: (remove #(some #{(first %)} [:a :b]) themap) that removes items with key equal :a or :b from the map. But that transformation into a set to use the (some) function isn't exactly intuitive. The better way is described in this Stackoverflow answer and is way more concise, thanks to apply.

<DT><A HREF="http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/butlast" ADD_DATE="1382630483" PRIVATE="0" TOREAD="0" TAGS="clojure,core,stdlib,stripping,csv,comma">clojure.core - butlast</A>
<DD>A tiny, simple, hidden function. But, oh boy, you can spend some unbelievable amount of time to figure out how to strip the last element from a list writing the Clojure yourself. An example use for butlast is having to print the typical csv list from a sequence, ending up with that additional comma that you need to strip out of the final string. No worries: (butlast csv) gives the list except the last element and something like (first (.split (last csv) &quot;,&quot;)) gives you the last element stripped of the comma. Finally (concat (butlast csv) (first (.split (last csv) &quot;,&quot;))) completes the picture.

<DT><A HREF="https://groups.google.com/forum/#!topic/clojure/5vg0T8F7_1w" ADD_DATE="1382608348" PRIVATE="0" TOREAD="0" TAGS="clojure,group,scala,literal,algorithm,translation,compare,performance">Request for help optimising a Clojure program - Google Groups</A>
<DD>This is an interesting thread from the Clojure user group. Somebody created a Scala version of the N-Queen chess problem and translated that to Clojure almost literally. Despite looking exactly the same, the Clojure version was taking 2 order of magnitude more than the Scala version resulting in the program running over night. The analysis that follows (through profiling) indicates that the problem is the presence of a lot of duplicates to be added to a persistenthashset and that is resulting in a lot of hash collisions checking. The main morale of this story is that code in language X cannot be always literally ported into language Y. There are tons of Clojure solutions that are better than the algorithm provided, but the question was why this clojure version of the algorithm is so poor performing. Very interesting.

<DT><A HREF="http://www.lshift.net/blog/2010/09/30/enlive-snippets-for-a-table-of-data" ADD_DATE="1382548235" PRIVATE="0" TOREAD="0" TAGS="clojure,enlive,html,parsing,table,selector">Enlive snippets for a table of data « LShift Ltd.</A>
<DD>Enlive is quite powerful both for html as well as xml parsing, including CSS like selector syntax and support for transformation. Another feature of enlive are snippets, or ways to define a selector over some data, not very different from a function. When the snippet is invokes over data, it will apply and return the corresponding CSS selection. Snippets can be used to isolate and compose selectors. In this post a good example is shown: parsing HTML tables.

<DT><A HREF="https://help.github.com/articles/github-flavored-markdown" ADD_DATE="1382508601" PRIVATE="0" TOREAD="0" TAGS="clojure,github,markdown,quote">GitHub Flavored Markdown · GitHub Help</A>
<DD>If you're a github user, in the sense of producing great projects there, this Github flavored markdown cheat sheet might be useful. Main difference with the classic markdown are listed here. Probably an important one is full text quoting with syntax coloring that you can activate with ```&lt;language&gt; and then newline the code and the closing ``` at the end. Of course it perfectly works for ```clojure so the example in your readme.md will never appear dull again.

<DT><A HREF="http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/deftype" ADD_DATE="1382466968" PRIVATE="0" TOREAD="0" TAGS="clojure,interop,class,deftype">deftype - Clojure v1.5 API documentation</A>
<DD>deftype is the basic lowest level class generation macro in Clojure (defrecord builds on top of that a nicer associative abstraction). But depending on your needs deftype might be what you're looking for to implement a basic data type. So why not something else? deftype allows to define (God forbid) mutable fields with the unsynchronized directive (or volatile if you are so inclined). What you gain is still Java interop to access fields in much more pleasant way than pure Java.

<DT><A HREF="http://www.infoq.com/clojure/" ADD_DATE="1382465568" PRIVATE="0" TOREAD="0" TAGS="clojure,infoq,news,basic,buzz,videos">Clojure Content on InfoQ</A>
<DD>Maybe this is well known link to InfoQ, but just in case you didn't know about it there is quite a good, up to date and rich section about clojure on InfoQ. All major Clojure conferences are posting videos here on regular basis, plus articles, new books and interviews. It is definitely a bookmark of mine, it should be yours as well.

<DT><A HREF="http://teropa.info/blog/2013/10/15/euroclojure-2013-narcissistic-design.html" ADD_DATE="1382012170" PRIVATE="0" TOREAD="0" TAGS="clojure,euroclojure,keynote,halloway,anti-pattern">EuroClojure 2013: Narcissistic Design</A>
<DD>Here's a summary of Stuart Halloway's Nariccistic Design talk. Hopefully there will be a video available at some point (couldn't find one) but the overall sense seems to be that of a parody of what Clojure doesn't do compared against many other corporate languages. As a side effect of not using Clojure you can achieve job security by obfuscation. That implies that if you embrace FP in general and Clojure you'll end up with a decreased complexity that will be easier to evolve and maintain by anyone. At least, I hope this is the sense of it! :) Anti-patterns discussed here: cryptic names, mutable state and setters, pushing language semantic down the wire, create unnecessary abstraction over simple information types, write many unit tests (hum, supposed too much testing or bad testing is bad, disciplined and pragmatic testing is good? Well don't get me started again on this).

<DT><A HREF="http://blog.factual.com/clojure-on-hadoop-a-new-hope" ADD_DATE="1382009993" PRIVATE="0" TOREAD="0" TAGS="clojure,cascalog,pig,tutorial,introduction,example">Clojure on Hadoop: A New Hope - Factual Blog</A>
<DD>Maybe a little too old, but a good straight to the point Cascalog introduction with sample project and how to be productive right away on CSV or JSON sources. Also some interesting comparison regarding why not using Pig kind of arguments. Worth a quick spike.

<DT><A HREF="https://kotka.de/blog/2013/10/A_bitter_taste.html" ADD_DATE="1381995375" PRIVATE="0" TOREAD="0" TAGS="clojure,tdd,emacs,elite,intolerant,rant">A bitter taste</A>
<DD>Holy cow, did this happened for real? I was following the usual tweets over the conference and noticed the usual pro Emacs tweets, which is fun and expected. This could be just a rant, but knowing Kotarak I think his post deserve attention. So do I need to think that Euroclojure was about mocking diversity in a non-constructive manner? I suppose that's not true, but still concerned about somebody leaving the stage with a bitter taste. Is the Clojure community becoming more and more intolerant? (I'm thinking about the other rumor discussions about the supposed uselessness of TDD). Discuss.

<DT><A HREF="http://codeofrob.com/entries/on-testing-and-the-repl-in-clojure.html" ADD_DATE="1381920028" PRIVATE="0" TOREAD="0" TAGS="clojure,tdd,testing,euroclojure">On Testing and the REPL in Clojure</A>
<DD>Sorry for my persisting on the TDD subject, but it really makes me sad whenever the &quot;clojure community&quot; thinks they've found a language that fixes the problem with TDD. This post reports about some informal chatting at Euroclojure 2013, so it is possibly one point of view. At the same time, I also experienced the same talking with fellow Clojurians. The problem with TDD as described here is not a problem with TDD, because the definition of TDD given here is as a tool for problem space exploration, something you use to acquire enough knowledge about a tool, library, API or framework to actually implement the solution you need. Never heard of that as TDD and of course those &quot;tests&quot; get in your way and you'd better use the REPL for that. All totally fine if you want to create a few tests after the fact to cover for regressions. But please, don't call that a fix for TDD, call it a fix for the need of exploratory code that doesn't fit very well in unit tests.

<DT><A HREF="http://clojurefun.wordpress.com/2013/01/05/towards-core-matrix-for-clojure/" ADD_DATE="1381917319" PRIVATE="0" TOREAD="0" TAGS="clojure,matrix,clatrix,ndarray">Towards core.matrix for Clojure? | Creative Clojure</A>
<DD>I'm looking into the Clojure matrix world for the first time and this post by Mike Anderson aka Mikera illustrates what is the current standardization status. Or maybe I should say what used to be the standardization status because despite core.matrix is not yet accepted contrib, a lot of effort has been put in the right direction. As explained here, there are many robust matrix manipulation libraries with specific focus on one aspect or another. Core.matrix is attempting to unify those under a standard API. It's already using NDArray as the default implementation and optional implementations are available for Clatrix and vector-clj.

<DT><A HREF="http://stackoverflow.com/questions/7140843/how-to-access-static-inner-java-class-via-clojure-interop" ADD_DATE="1381491715" PRIVATE="0" TOREAD="0" TAGS="clojure,java,interop,static,inner,import,require,explicit">How to access static inner Java class via Clojure interop? - Stack Overflow</A>
<DD>This is about the dark side of Java interop, when things go crazy. Clojure is already preventing you (by design) to have wildcard import of an entire package of Java classes. Okay, then you list them all. A side effect of this approach is that you'll have to list static inner classes as explicit imports as well. I agree, this is something that doesn't happen that often but just in case this is what you need to do to import it. Then you need the dollar sign, for example: OuterClass$InnerClass/staticMethod.

<DT><A HREF="http://adambard.com/blog/core-typed-vs-haskell/" ADD_DATE="1381414166" PRIVATE="0" TOREAD="0" TAGS="clojure,core.typed,types,haskell,checking">Clojure's core.typed vs Haskell - Adam Bard and his magical blog</A>
<DD>There is a lot of buzz around core.typed these days, considering the project was able to raise the funding necessary for its main author (Ambrose Bonnaire-Sergeant) to commit full time to it. Core.typed is pretty solid already and this blog post gives a quick overview on how it looks like applied to simple Euler projects and compared to the same implementation using the king of typed functional programming: Haskell. The good part about a macro based typing like Clojure (instead of a full blown typed language) is the fact that you can apply it when you see fit. Contracts are clearly important when exchanging EDN for example, so some type checking around that part of the application could be useful. Another idea is to use them a-la Eiffel for contracts.

<DT><A HREF="https://github.com/framework-one/fw1-clj" ADD_DATE="1381253070" PRIVATE="0" TOREAD="0" TAGS="clojure,web,framework,sinatra">framework-one/fw1-clj</A>
<DD>Framework-one is yet another interesting lightweight web framework written by Sean Corfield. The name just describes the fact that the framework really comes as a single one.clj file and the rest will be part of the specific application to be built. The convention is quite simple: if you invoke user/add a function (add) is invoked on controllers/user.clj and a views/users/add.html will be rendered. Can we call it the Sinatra of Clojure-land?

<DT><A HREF="http://www.pgrs.net/2011/10/30/using-local-jars-with-leiningen/" ADD_DATE="1381092889" PRIVATE="0" TOREAD="0" TAGS="clojure,leiningen,dependencies,jars,libs,interop,java">Using local jars with leiningen » Paul Gross's Blog</A>
<DD>This is an useful trick that you need working with Java interop, leiningen and jars that are not deployed in a public or private repo. It basically consists of creating a local project folder to behave as a local Maven repository, install your jars there and tell Leiningen about the location of the local repo and the dependencies that you need. You are probably going to need https://gist.github.com/stuartsierra/3062743 as well, since you need md5 and sha files to be created as well. You need to do this once and after that you can distribute your project as usual.

<DT><A HREF="https://speakerdeck.com/daveray/clojure-at-netflix" ADD_DATE="1380960640" PRIVATE="0" TOREAD="0" TAGS="clojure,slides,experience,netflix">Clojure at Netflix // Speaker Deck</A>
<DD>A quite good experience report as slides from a team using Clojure in production for part of the Netflix delivery. Many neat ideas (that unfortunately don't seem to be open sourced) like Sabot or Pigpen. The latter is like ClojureScript for Javascripts, it produces Pig scripts (Hadoop mapreduce) from pure Clojure. Delighted at the idea this can be done considering the amount of Pig stuff I'm doing at the moment. As of the conclusions, the experience report seems positive with the usual bad-ugly related to the mental shift required to get into the Clojure mood.

<DT><A HREF="http://www.colourcoding.net/blog/archive/2012/09/29/clojure-macro-defn-curried.aspx" ADD_DATE="1380734058" PRIVATE="0" TOREAD="0" TAGS="clojure,currying,curry,haskell,defcurried,macro">Clojure Macro: defn-curried</A>
<DD>The source of Clojure reducers contains a simple defcurried macro that allows to create a function that behave exactly as written plus, when invoked without the last argument, it returns instead a function awaiting the last param to execute. This is commonly called currying in functional languages. ML languages usually got that for free, just invoke without an argument to obtain automatic currying. In Clojure you need to create your own macro. This post describes how to overcome the limitations of the simple defcurried included with reducers.  You can (defn-curried myf [a b c] (+ a b c)) for example and then invoke it like: (myfn 1 2 3) but also ((myfn 1 2) 3) and also ((myfn 1) 2 3). Why currying? it removes some of the additional code necessary to create multiple arity functions in a general way. That gives you the power to create specialized versions of a function and keep them around with a powerful syntax.

<DT><A HREF="https://github.com/clojure/core.async/blob/master/src/main/clojure/clojure/core/async.clj#L391" ADD_DATE="1380732033" PRIVATE="0" TOREAD="0" TAGS="clojure,core.async,channel,map,reduce">core.async Ops</A>
<DD>Rich Hickey recently committed some work on core.async to allow sequence like operations to channel. map&lt; for example takes a channel and return a channel in which each element has been applied the given function. Same for filter&lt;, reduce&lt; and others. The interesting part is that a core.async channel is seen as a collection where elements can pushed or popped following the channel semantic. So the map&lt; will block or not depending on the presence of a buffer and so on.

<DT><A HREF="https://groups.google.com/forum/#!topic/leiningen/t8G6Et1_j8w" ADD_DATE="1380288440" PRIVATE="0" TOREAD="0" TAGS="clojure,leiningen,quote,eval,code,java,property">Leiningen Setting system properties - Google Groups</A>
<DD>Googling to remember what I need to add in Leiningen project.clj to pass a Java property in, I've found this post on the Leiningen mailing list that shows how that can be done and also how you can have Clojure executed directly there, in your project.clj. In this case, the list of key value pairs to be added as -D properties can be written as a map and assembled on the spot. Quite readable if you have one of those longs -D property lists.

<DT><A HREF="https://gist.github.com/reborg/6713575" ADD_DATE="1380199579" PRIVATE="0" TOREAD="0" TAGS="clojure,performance,optimizations,speed,native">clj-array-perf.clj - Clojure performance</A>
<DD>Had some fun recently trying to understand how to speed up a simple clojure reduce. It went from understanding how vectors work, how reflection is used in Clojure and how checked operators affect performances. The result of using all the optimizations at once is not that bad, considering how ugly the for loop would be in Java anyway. See if you can make it faster, I'd love to know what else can be done staying in Clojure land.

<DT><A HREF="http://stackoverflow.com/questions/2588227/is-there-an-equivalent-for-the-zip-function-in-clojure-core-or-contrib" ADD_DATE="1380043185" PRIVATE="0" TOREAD="0" TAGS="clojure,zip,ruby,permutate,vertical,traverse">Is there an equivalent for the Zip function in Clojure Core or Contrib? - Stack Overflow</A>
<DD>I keep forgetting that collection functions like map takes multiple collections not just one. So things that require some lines of code in high ceremony languages, take a one liner in clojure: (map + [1 2 3] [1 2 3]) does exactly what you'd expect: (2 4 6). The reason I was searching this as &quot;zip&quot; belongs to my ruby background :)

<DT><A HREF="http://piplin.org/" ADD_DATE="1380033873" PRIVATE="0" TOREAD="0" TAGS="clojure,verilog,hardware,synthesis">Piplin</A>
<DD>Piplin is quite a cool use case for Clojure. It describes hardware that can be simulated and synthesized ready to be physically casted at the gate level on silicon. To have an idea of what you can do, have a look at this z80 processor description https://github.com/dgrnbrg/piplin/blob/master/examples/piplin/z80.clj . The idea is that when you're ready, you can synthesize it or even put it on a generic FPGA. The author highlights the added values of using Clojure instead of Verilog for this task. Clojure is more robust, less error prone and offers high level of composition and testing.

<DT><A HREF="http://clojurecup.com/apps.html" ADD_DATE="1380027613" PRIVATE="0" TOREAD="0" TAGS="clojure,clojurecup,competition,idea">Clojure Cup: Apps</A>
<DD>It's worth having a look at the app submission page for ClojureCup. Some interesting ideas there. One common theme is about coding (code analysis stuff) itself and collaboration in a team (lot of github stuff). One idea I like to see implemented in Clojure is one that analyses articles to predict what you'll be more likely to read next based on your level of understanding. But there is much more. Most voted apps seem to be games and there are a lot of them.

<DT><A HREF="https://github.com/ibdknox" ADD_DATE="1379862285" PRIVATE="0" TOREAD="0" TAGS="clojure,lighttable,aurora,ide,programming,strangeloop">ibdknox (Chris Granger)</A>
<DD>I'm linking here Chris Granger's github page for two reasons. You should keep an eye on his work on LightTable and Korma and the rest of his projects and second because his Strangeloop 2013 talk attempted to give answers to the very difficult question about what is programming and what makes programming hard. Essentially: it is unobservable, indirect, and incidentally complex (you really need to watch this talk as soon as it is available on infoQ). His observations on principles resulted in a new project that he's working on, I think called &quot;Aurora&quot;, that he showcased during the talk. Essentially what I saw was a visual language where mouse clicks and drag and drop were an essential part of it, that was dynamically updating and always showing the application in its final rendered form. You should probably think at it as a Lighttable on steroids: the code is not just evaluated, but the final application is constantly evaluated. Unfortunately, there is nothing around that I can google to tell me more about Aurora.

<DT><A HREF="http://corfield.org/blog/post.cfm/the-strange-loop-2013" ADD_DATE="1379861471" PRIVATE="0" TOREAD="0" TAGS="clojure,conference,strangeloop,review">The Strange Loop 2013 — An Architect's View</A>
<DD>Here's a good overview about Strangeloop 2013. Another honorable mention goes to http://www.sauria.com/blog/2013/09/21/strange-loop-2013/ if you want to hear from another point of view. I personally enjoyed the conference but I had to skip so many talks I was interested in because of the 4 tracks in parallel. I'd be so happy to see something like Strangeloop as a single track conference! Minor rant though. The Clojure presence at the talk was definitely heavy, with special thanks to the Cognitect crowd for organizing workshops and talks. Also keep an eye on https://github.com/strangeloop/StrangeLoop2013/wiki/Coverage about all the other buzz around Strangeloop.

<DT><A HREF="https://github.com/bodil/BODOL" ADD_DATE="1379859936" PRIVATE="0" TOREAD="0" TAGS="clojure,languages,parser,grammar,core.logic,core.match">bodil/BODOL</A>
<DD>Bodol is an interesting language experiment. It is for the concepts it implements on top of a language that is very &quot;lispy&quot; already and for the implementation details since it is written in Clojure. It contains a work in progress implementation of an http://en.wikipedia.org/wiki/Hindley–Milner inspired type system, pattern matching and an embedded Prolog-like engine. The main inspirations are coming from Clojure, Haskell and Shen. As of the implementation details, it uses Instaparse, core.logic and core.match which are all known clojure libs.

<DT><A HREF="http://cognitect.com/podcast" ADD_DATE="1379591637" PRIVATE="0" TOREAD="0" TAGS="clojure,cognitect,merger,relevance,datomic">Cognicast :: Podcast</A>
<DD>Welcom Cognitect and the new Cognicast, formerly Relevance Podcast. A part from avoiding some confusion to Relevance's customers in terms of Datomic support, I don't think there are other major impacts to the Clojure community from this merger you need to know of. In this podcast you can hear the reasoning behind the new brand from Rich and Justin Gehtland as usually interviewed by Craig. Mmmh, what do you think about the name? Isn't sounding a little bit too &quot;Initech&quot;? :)

<DT><A HREF="http://gershwinlang.org/" ADD_DATE="1379590996" PRIVATE="0" TOREAD="0" TAGS="clojure,concatenative,forth,reader">Gershwin Programming Language</A>
<DD>Gershwin is an interesting experiment on concatenative programming on top of Clojure I learned about at Strangeloop. It is definitely interesting to see how you can fork Clojure and adapt the Reader to digest a completely different language and at the same time take advantage of the STM and data structures.

<DT><A HREF="http://clojuredocs.org/clojure_core/1.3.0/clojure.core/identity" ADD_DATE="1379252023" PRIVATE="0" TOREAD="0" TAGS="clojure,identity,idiomatic,idiom,fnil,conditionals">ClojureDocs - clojure.core/identity</A>
<DD>Identity is a very simple fn returning a fn that returns its argument when invoked. Can such a function be of any interest? There are many idiomatic ways to use identity because of its &quot;conditional&quot; behavior. Consider removing nulls from a collection: (filter identity [:a :b :c nil]) does exactly the same as (filter #(not (= nil %)) coll) in a much readable way. Consider also (((partial fnil identity) &quot;default&quot;) blah) which returns &quot;default&quot; if blah is nil, blah itself otherwise. No conditionals.

<DT><A HREF="http://about.travis-ci.org/docs/user/languages/clojure/" ADD_DATE="1378899931" PRIVATE="0" TOREAD="0" TAGS="clojure,ci,integration,test,tdd,travis,build">Travis CI: Building a Clojure project</A>
<DD>Here's the getting started to take your Clojure project to Travis-CI. Instructions are quite good and should be up and running in minutes. You need to go then to https://travis-ci.org with your github account and setup your project there. The last thing is adding the badge to the project page. Why do you need CI? As soon as your well tested project starts to get used having the tests running on an external machine which is not your local env will help catching issues with dependencies or missing environment properties. It also builds confidence to the potential users of your project.

<DT><A HREF="http://thinkrelevance.com/blog/2013/08/27/alex-miller-podcast-episode-039" ADD_DATE="1378899530" PRIVATE="0" TOREAD="0" TAGS="clojure,podcast,audio,relevance,miller,strangeloop,lambdajam">Blog | Alex Miller - Podcast Episode 039 | Relevance</A>
<DD>Quite an interesting podcast this one from Relevance with Alex Miller. At least it was for me, since I'm speaking at StrangeLoop and you can hear Alex talking about the main goal of the conference compared to Lambda am or another of the many Alex organizes. Toward the end Alex speaks about it's idea to restructure the community around Clojure-core, Jira issues and newbie getting-started options. There was a little bit of slow-down during the past year fixing Clojure and moving forward and Alex would like to change that into a more pro-active attitude.

<DT><A HREF="https://github.com/clojure/tools.cli" ADD_DATE="1378898934" PRIVATE="0" TOREAD="0" TAGS="clojure,stdlib,tool,cli,command,terminal,console">clojure/tools.cli</A>
<DD>tools.cli provides a pretty standard way to deal with parameters from the command line. It supports aliases (like -v --verbose), flags or normal arguments and a pre-made &quot;usage&quot; banner output. It also takes care of a few of the typical corner case in command line argument parsing like trailing spaces.

<DT><A HREF="https://github.com/reborg/pwc" ADD_DATE="1378889439" PRIVATE="0" TOREAD="0" TAGS="clojure,reducers,wc,pwc,tool,count,frequencies">reborg/pwc</A>
<DD>Shameless plug. I wrote this small utility that emulates some of the venerable &quot;wc&quot; Unix command line features adding frequencies as a bonus. It is production ready, in the sense that when you brew install pwc you get it up and running but it's still in alpha for many wc features that are not yet there and performances (it will blow up at the moment if you give it a huge file). pwc is written in Clojure and makes good use of reducers. It's pretty covered by unit/acceptances and is waiting for volunteers to help me out!

<DT><A HREF="https://github.com/devn/codeq-playground/blob/master/src/com/thinkslate/codeq_playground/core.clj" ADD_DATE="1378562698" PRIVATE="0" TOREAD="0" TAGS="clojure,codeq,git,queries,history,statistics">codeq-playground/src/com/thinkslate/codeq_playground/core.clj at master · devn/codeq-playground</A>
<DD>Codeq-playground is a work in progress repo on Github that aggregates a few common queries for codeq, the datomic-based git repository inspector. Git offers unprecedented possibilities to explore git repository history through the datomic query engine. I think a good use case for codeq is when you need to quickly get an understanding of a project history, statistics and evolution. The core.clj linked here contains a few useful queries in that sense.

<DT><A HREF="http://getclojure.com/" ADD_DATE="1378562218" PRIVATE="0" TOREAD="0" TAGS="clojure,documentation,elasticsearch,scraping,cool">GetClojure</A>
<DD>A quick mention for a neat idea. GetClojure scraps several sources in search for s-expressions (in other languages we call them snippets), aggregates them inside elasticsearch and serves them from a browser interface. It works better with well used functions but at the moment returns a list that requires further skimming to be truly useful. It is a work in progress and with some ranking algorithm it might turn out as a decent semi-autonomous documentation source.

<DT><A HREF="http://blog.screen6.io/post/57428073723/introduction-to-testing-cascalog-with-midje" ADD_DATE="1378405511" PRIVATE="0" TOREAD="0" TAGS="clojure,cascalog,test,tdd,midje">Screen6 — Introduction to testing Cascalog with Midje.</A>
<DD>Here's a quick introduction to all you need to test first with Cascalog. Cascalog comes with integrated testing capabilities which makes it very attractive to incrementally design cascalog queries. This post shows you how you can use Midje instead of core test. Sure you can always REPL them but it sounds like having a bit of confidence when you evolve the code and the data is a nice thing to have.

<DT><A HREF="http://yogthos.net/blog/49" ADD_DATE="1378405303" PRIVATE="0" TOREAD="0" TAGS="clojure,design,languages,productivity,beginner,newbie,starting">Why I'm Productive in Clojure</A>
<DD>There are a couple of good points in this post about what differentiate a good language from a not so good one. The final goal while developing is expressing the problem domain into a language that it can then be sent down to hardware. We all now this can be done in assembler or punch cards as well. A good language will let you express the problem domain with minimal effort, without forcing you into unrelated constructs. We normally call those unrelated constructs &quot;boilerplate&quot; because it tends to be repeated everywhere. The other good point is about the richness of tools in a language. A language can offer many ways to solve a problem but the important thing is if there is a common denominator or a guiding principle. If guiding principles permeate the language, then the overhead as a developer to keep in mind all the tools the language offers to solve the problem is minimal.

<DT><A HREF="https://github.com/clojure/tools.trace" ADD_DATE="1378404509" PRIVATE="0" TOREAD="0" TAGS="clojure,tools,debugging,trace,debug,contrib,stdlib">clojure/tools.trace</A>
<DD>tools.trace contains a set of utility for better debugging and tracing of functions. One I specially like is the possibility to replace a &quot;defn&quot; with &quot;deftrace&quot; and the invocation of that function will print input parameters and output results. For recursive invocation will print each invocations with a different identation level. Another interesting macro is &quot;traceform&quot;, which in case of an error with backreferencing let bindings will show the problem as it seen by replacing all bindings. Too difficult to explain, better if you just try it out.

<DT><A HREF="http://www.luminusweb.net/docs" ADD_DATE="1377765910" PRIVATE="0" TOREAD="0" TAGS="clojure,framework,web,rails,luminus,django">Luminus - A Clojure Web Framework</A>
<DD>I recently dicovered Luminus. I had a look at the documentation and tried out quickly building a project. If only I had this when I was working on the https://github.com/reborg/iad server! Luminus is the closest I found so far to Rails. It is heavily opinionated and hence very fast for the kind of applications it is directed to: the classic web interface on top of a database persistence. The author of Luminus is also the author of &quot;Web Development with Clojure&quot; below.

<DT><A HREF="http://pragprog.com/book/dswdcloj/web-development-with-clojure" ADD_DATE="1377763117" PRIVATE="0" TOREAD="0" TAGS="clojure,book,web,ring,compojure">The Pragmatic Bookshelf | Web Development with Clojure</A>
<DD>A new beta book became available at the PragProg.com bookshelf, &quot;Web Development with Clojure&quot; by Dmitri Sotnikov is the first Clojure book dedicated specifically to web development that I know of. Dmitri is author of the Luminus framework and many other Clojure contrib at https://github.com/yogthos/luminus

<DT><A HREF="http://alexott.net/en/clojure/video.html" ADD_DATE="1377594734" PRIVATE="0" TOREAD="0" TAGS="clojure,links,videos,starting,introduction,rich">Video lectures &amp; presentations about Clojure</A>
<DD>Here is an always welcome collection of videos about Clojure. In particular all the historical Clojure talks by Rich are here. I'd probably point Clojure skeptics to a couple of these if necessary, since Rich speaking is the best way to convey the overall Clojure message. Also have a look at the general Clojure section that contains many more links to Clojure stuff other than videos.

<DT><A HREF="http://stackoverflow.com/questions/4815367/evaluation-order-of-function-arguments-in-clojure" ADD_DATE="1377250229" PRIVATE="0" TOREAD="0" TAGS="clojure,order,evaluation,parameters,haskell,lazy">Evaluation order of function arguments in Clojure - Stack Overflow</A>
<DD>You should almost never be interested in the evaluation order of function parameters in a Clojure function. If you are it might be because a function has side effects on another function executing before, which is a bad sign (unless you do really know what's going on). Anyhow, the order is left to right and inside out. If the order is not good for you, then you can just extract the parameter in a let binding of a variable that you can use then for the function invocation, determining that specific parameter to be evaluated first. In general, Clojure is not lazy evaluating parameters like other languages do (notably Haskell).

<DT><A HREF="http://clojuredocs.org/clojure_core/clojure.core/dotimes" ADD_DATE="1377246107" PRIVATE="0" TOREAD="0" TAGS="clojure,stdlib,loop,iterate,for,range,times">ClojureDocs - clojure.core/dotimes</A>
<DD>dotimes is what you need when you need to repeat some side effect actions a certain number of times. You shouldn't find your self using this a lot of times (map and the for list comprehension should be first choice for immutable structures). You could also use for with [x (range 5)] with similar effects, in this case dotimes is an abbreviation removing the need to make the range explicit. Unfortunately for Clojure which is not object oriented, I really miss the immediateness of 10.times {|n| ...} of Ruby.

<DT><A HREF="http://clojure.org/transients" ADD_DATE="1377168561" PRIVATE="0" TOREAD="0" TAGS="clojure,transient,persistent,vector,into,conj!">Clojure - transients</A>
<DD>Transients is the trendy name for the &quot;bad old way&quot; of updating collections in place. Persistent collections are one of the core features of Clojure, but there are corner cases in which you can shave a few milliseconds by giving away persistency in a local and isolated context. It works by asking a collection (only vectors, maps and unordered sets support a Transient counter-part) a transient copy of itself that can then be mass updated e re-transformed in a persistent collection in O(1) constant time. List based sequences are not supported because those are &quot;logical lists&quot; in the LISP sense, while vectors are Java types at the very bottom. You are already using Transients every time you call &quot;into&quot; on a vector. Internally the vector is mutated into the transient copy, updated and returned back as persistent. Mutable transients are not thread safe, so mutations are not allowed by a different thread not holding the initial copy of the transient.

<DT><A HREF="http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/*print-length*" ADD_DATE="1377163455" PRIVATE="0" TOREAD="0" TAGS="clojure,tools,trick,binding,repo">clojure.core - *print-length*</A>
<DD>There are a few globals in Clojure to control the behaviour of the REPL. One of them lets you decide how many elements of a sequence should be printed by the automatic evaluation performed at the REPL. To quickly change that try (set! *print-length&quot; 10) and then (range 100) to test it out. Use this to prevent accidental evaluation while working with big collections.

<DT><A HREF="https://github.com/clojure/clojure/blob/master/src/clj/clojure/main.clj#L268" ADD_DATE="1377161756" PRIVATE="0" TOREAD="0" TAGS="clojure,stdlib,source,repl,eval,loop,bindings">clojure/src/clj/clojure/main.clj</A>
<DD>main.clj from the Clojure sources, contains the main functions to start Clojure and the REPL. The  (defn repl) function is responsible for the Read-Eval-Print Loop (anonymous function defined in the let bindings). All the handy bindings we are used to in the repl (for example *1, *2, *e) are defined in this file as well (with-bindings macro). Line 261 (at the moment) is responsible to (print) what was eval-ed from the user input. Right after that bindings *1, *2, *3 are set in cascade to update their contents. Knowing small and important bits of the standard library here and there is an important exercise to know how to use Clojure at its best.

<DT><A HREF="http://clojure.com/blog/2013/08/21/clojure-community-office-hours.html" ADD_DATE="1377097279" PRIVATE="0" TOREAD="0" TAGS="clojure,community,help,newbie,desk">Clojure/core — Clojure community office hours</A>
<DD>Alex Miller is using some of his (and Relevance) 20% time to answer question on Clojure, specifically people starting with Clojure, the current Jira tickets, or one of the many conferences he organises. You just need to book a 30' slot to have this nice opportunity.

<DT><A HREF="http://vimeo.com/6624203" ADD_DATE="1377013488" PRIVATE="0" TOREAD="0" TAGS="clojure,reducers,lisp,parallel,parallelisation,fold,steele">Organizing Functional Code for Parallel Execution; foldl and foldr Considered Slightly Harmful</A>
<DD>Here's one of those talk that took me quite some time to digest completely (and I'm not sure if I succeeded). Guy Steele is researching (amongst a lot of other things) what organisation of  the code makes it easier to parallelise. The message of the talk is that all the tricks that we are very used to with sequential programming for the past 50 years aren't working anymore if we want to exploit ubiquitous multiple-core machines. We should instead empowering current languages so they take care of parallelism, exactly like giving away direct memory access made possible garbage collection. Guy gives an example of high order operators (map, filter, reduce, sort and so on) on top of a data abstraction based on concatenation and splitting. All of that in lisp. This organisation makes room for parallelisation at the price of more processing and more space required. Clojure reducers took inspiration from this and also a departure, in the sense that they give for granted that processing at the leaf is sequential reduce. Guy Steele also suggest that at the end of the talk as a possibility. Why fold is harmful? Because processing based on accumulation doesn't work well for parallel code.

<DT><A HREF="http://ragnard.github.io/2013/08/12/datomic-in-the-browser.html" ADD_DATE="1377012889" PRIVATE="0" TOREAD="0" TAGS="clojure,torch,codeq,clojurescript,core.async,forward">Ragnar Dahlén - Datomic in the Browser</A>
<DD>I like the idea presented in this blog post. I don't think what it is interesting is the technical part, although it brings together a few neat things. What I think is most interesting is the idea to release a tool (torch in this case) that given a whatever Clojure codebase sitting on github, it can create a browser based inspector of your code thanks to codeq.  As of the technical stuff, this article explain how you can make a datomic call from ClojureScript and make it asynchronous with core.async which is also quite interesting example.

<DT><A HREF="https://groups.google.com/forum/#!topic/clojure/_c_VEXLFj-4" ADD_DATE="1376926577" PRIVATE="0" TOREAD="0" TAGS="clojure,idiomatic,hashmap,consolidation,stdlib">vec to map with consolidated vals - Google Groups</A>
<DD>Of all the many and valuable posts in the Clojure mailing list, I wanted to point out a discussion that stress out the refinement process to find the best idiomatic Clojure. The problem is the usual (at least, this happens regularly to me) problem of transforming pair in a sequence into a map with value consolidation for multiple pairs with the same key in the initial sequence. You can go totally crazy if you don't know those 2 or 3 functions from the standard library which make your code readable and easy. Also notice that the name given to the function is clearly speaking about what the function is going to do. A good name is worht a page of documentation. On another note, welcome David to the Clojure community, I used to know him very well from my Chicago-Ruby-RSpec days.

<DT><A HREF="http://clojurecup.com/rules.html" ADD_DATE="1376816796" PRIVATE="0" TOREAD="0" TAGS="clojure,cup,competition,rails,rumble,2013,hacking,48">Clojure Cup - Rules</A>
<DD>I bookmarked this in the past already, but I just wanted to mention that rules for the first ClojureCup 2013 are now published. Nothing surprising in them, you have to hack your thing in 48 hours, you can design the ideas as much as you want before. ClojureCup is a Clojure based hacking competition on the model of Rails Rumble. You have time until Sept the 7th to decide if you want to participate and organise your team. Happy hacking.

<DT><A HREF="http://www.enrico-franchi.org/2012/02/clojure-writing-tail-recursive.html" ADD_DATE="1375877287" PRIVATE="0" TOREAD="0" TAGS="clojure,recur,tail,recursion">RiK0 Tech Temple: Clojure: writing tail recursive functions without using recur</A>
<DD>Was wondering today how the recur tail-optimisation work in Clojure. Recur is technically not a macro, it is defined at the Compiler.java level and not core.clj. Looking at Compiler.java wasn't really helpful, it is not clear on a first read what Recur is emitting. Then I found this blog post that maybe is not reflecting how Clojure is creating the tail-recursion magic, but at least it gives a functional explanation of how to obtain tail-recursion recur without recur. The trick involves state (arrgh...) and essentially invokes the body of the function as many times as required, storing partial results on the way and combining them back for the result.

<DT><A HREF="http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/*'" ADD_DATE="1375540294" PRIVATE="0" TOREAD="0" TAGS="clojure,stdlib,overflow,operators,promotion">clojure.core - Clojure v1.5 API documentation</A>
<DD>Clojure provides operators like +, *, inc and dec and their auto-promoting counterparts called +' *' inc' dec'. The postfixed apostrophe version allows the operation to auto-promote to BigInt or BigDecimal on overflow. You should probably use the auto-promoting version if your operations usually stay in the long/float range with occasional spikes into higher precision requirements.

<DT><A HREF="http://stackoverflow.com/questions/10767305/what-is-fn-and-how-does-clojure-bootstrap" ADD_DATE="1375538653" PRIVATE="0" TOREAD="0" TAGS="clojure,internals,core,fn,fn*,bootstrap">What is fn* and how does Clojure bootstrap? - Stack Overflow</A>
<DD>Very good question indeed. Core.clj main Clojure namespace uses (fn*) in the definition of the macro (fn) itself. fn* is hence a compiler &quot;primitive&quot; which is indeed defined in Compiler.java. fn* is the most basic form of function definition and as specified in a comment in core.clj (around line 30) at the very beginning of the Clojure bootstrapping there is no destructuring for let, loop or fn. Fn with destructuring will be defined later on. So the approach taken by Clojure to bootstrap the language (that is, to allow you to do development the way you're used to) is to incrementally refine the primitives of the language instead for example of delegating that part to the Java runtime. It also means that if you &quot;macro expand&quot; a macro, sometimes you'll see (fn*) used instead of (fn) which I suppose is slightly faster (comments on the last sentence are welcome, I'm not sure).

<DT><A HREF="https://github.com/reborg/xrepl" ADD_DATE="1375518907" PRIVATE="0" TOREAD="0" TAGS="clojure,xrepl,repl,tools.namespace,reflection,github,tools">reborg/xrepl</A>
<DD>Tiny bit of self-promotion here. I started to collect the most useful tooling I'm using while developing from the REPL in this project. Not a lot for the moment, but I'll be adding stuff as soon as I find myself using them over and over again on a project. For the moment enjoy (m) to inspect on Java supported methods for a specific Clojure type and (refresh) from toos.namespaces to deep reload dependencies.

<DT><A HREF="http://hueypetersen.com/posts/2013/08/02/the-state-machines-of-core-async/" ADD_DATE="1375480688" PRIVATE="0" TOREAD="0" TAGS="clojure,macro,go,core-async,async,reverse,macroexpand">The State Machines of core.async</A>
<DD>Speaking of the power of macroexpand, here's what happens when you apply it to core-async go blocks. This post is essentially an annotated guide of the reverse engineering of the core-async macro that creates the state machine behind the illusion of thread suspension and asynchronicity at the core of the core-async abstraction. The power and limitation of macros: you can hide very complicated things behind the syntax of the language but at the same time it only works in the specific context of the go block declaration (when the Go-language supports the behaviour at the language level instead).

<DT><A HREF="http://www.amazon.com/Structure-Interpretation-Computer-Programs-Engineering/product-reviews/0262510871/ref=cm_rdp_hist_hdr_cm_cr_acr_txt?ie=UTF8&showViewpoints=1" ADD_DATE="1375434647" PRIVATE="0" TOREAD="0" TAGS="sicp,clojure,lisp,amazon,book,review">Amazon.com: Customer Reviews: Structure and Interpretation of Computer Programs - 2nd Edition (MIT Electrical Engineering and Computer Science)</A>
<DD>SICP reviews on Amazon are a book in themselves. We've got Peter Norvig at the top trying to explain why the book reviews are so extreme (either 5 stars or no stars) and Paul Graham giving his view on it. It seems that what happens is that who is patient and open enough to truly understand the book thinks SICP is amazing. Who instead gave up pretty quickly thinking  about a too slow introduction to computer programs considers SICP a waste of time. The book divides because it is extreme. As all the extremes is worth deep understanding and contextualisation.

<DT><A HREF="https://github.com/ohpauleez/clojure-leap" ADD_DATE="1375275222" PRIVATE="0" TOREAD="0" TAGS="clojure,leapmotion,hardware,3D,sdk">ohpauleez/clojure-leap</A>
<DD>You know that where a Java SDK is provided there is also a Clojure library waiting to be built. If you want to impress your friends look no further: the Leap Motion Controller is a 3D motion detector device that attach to your USB port: https://www.leapmotion.com. This tiny library is a first attempt at managing the thing from Clojure. This project it's a work in progress and a fun way to learn some Clojure.

<DT><A HREF="http://dev.clojure.org/display/community/Developing+Patches" ADD_DATE="1375269213" PRIVATE="0" TOREAD="0" TAGS="clojure,contributing,patches,jira,development">Developing Patches - Clojure Community - Clojure Development</A>
<DD>Ever wondered how to contribute to Clojure? That is an instructive way to learn the language and help the community around it. Joining the dev-mailing list is certainly the first step and it requires some time for the agreement that you need to sign and send to Rich (cool, really, Rich is receiving requests from worldwide aspiring clojure committers directly at his desk). The next step is really grab any of the bugs and requests in http://dev.clojure.org/jira/browse/CLJ and have a look around to see how bugs are discussed in Jira and sometimes on the mailing list. After that, you're good to go and this is a very well detailed guide on how to contribute to Clojure.

<DT><A HREF="http://www.manning.com/marz/" ADD_DATE="1375198222" PRIVATE="0" TOREAD="0" TAGS="clojure,book,functional,lambda,architecture">Manning: Big Data</A>
<DD>Big Data is the new book that Nathan Marz and James Warren are writing to describe an architectural approach to Big Data called Lambda Architecture. It consists of three main layer: a batch layer, a serving layer and a speed layer. The basic principle behind the lambda architecture view of data is that information is immutable (hence the lambda name). Similar to Datomic, changes to data are recorded as logs. The serving layer is constantly updated from data coming from the batch layer and it also contains a first aggregation of data plus indexing that makes querying faster. Since the serving layer is not up to date by definition, the speed layer is there to fill that gap. The speed layer can be truncated every time new views are materialized in the serving layer. This architecture should solve the problem of having query = function(all-data) no matter how big all-data is going to be. The reason behind f(data) is possible is that immutability allow for horizontal scaling.

<DT><A HREF="https://github.com/marick/Midje/wiki/What%27s-new-in-midje-1.6" ADD_DATE="1375082568" PRIVATE="0" TOREAD="0" TAGS="clojure,midje,alpha-3,1.6,autotest">What's new in midje 1.6 · marick/Midje Wiki</A>
<DD>In the latest alpha3 of the coming 1.6 Midje release, several changes have been made to make Midje compatible with standard continuos integration requirements to show output of test suites as part of the CI report. There are also a few other improvements in midje customisation for colors, autotest scope and more.

<DT><A HREF="https://commoncrawl.atlassian.net/wiki/display/CRWL/About+the+Data+Set" ADD_DATE="1374926119" PRIVATE="0" TOREAD="0" TAGS="clojure,dataset,sample,datamining,bigdata">About the Data Set - Common Crawl - Confluence</A>
<DD>Bookmarking this although not strictly clojure related. Clojure is often used to solve big data problems, a business that requires scripting capabilities, raw performance power and a good set of supporting library (I'm thinking at all the s3, EMR, hadoop wrappers out there, plus Cascalog and Storm). Well, if you happen to have a spare 81TB on your laptop drive you can play around with the common crawl dataset, the raw data you can obtain when you request 6 billions web pages, http headers included. The archive is already split into multiple S3 files based on the date of crawling, so it might be a better idea to use and ec2 instance or EMR for your processing. Just saying...

<DT><A HREF="http://clojure.github.io/clojure/clojure.java.io-api.html#clojure.java.io/resource" ADD_DATE="1374924560" PRIVATE="0" TOREAD="0" TAGS="clojure,classloader,resource,load,slurp">clojure.java.io - Clojure v1.5 API documentation</A>
<DD>clojure.java.io resource is a typical swiss army knife that works in many contexts. It returns the URL of a resource that is visible from the root class path (if not specified otherwise). Used with &quot;slurp&quot; for example can be used to bring into memory plain text in a single liner provided the text is available on the classpath.

<DT><A HREF="http://bryangilbert.com/code/2013/07/19/escaping-callback-hell-with-core-async/" ADD_DATE="1374665498" PRIVATE="0" TOREAD="0" TAGS="clojure,clojurescript,core.async,callback">Escaping Callback Hell With Core Async</A>
<DD>This is a simple but quite illuminating example of what kind of problems core.async is supposed to solve. After reading the official doco and doing some example I was still unclear about the best use case to use it (sorry, my bad I'm pretty low at understanding). core.async allows to write what looks like sequential code that is executed asynchronously under the hood. Any scenario requiring a callback is a good candidate for core.async. Second, core.async is not blocking over the callback like with normal threads. In this article it is used for the very common problem of javascript async callbacks. It makes them appearing as sequential but one big difference in a browser JS implementation is that JS is single threaded no matter what. So core.async or not, when your time consuming action is executing the rest of the javascript has to wait.

<DT><A HREF="https://github.com/TheClimateCorporation/lemur" ADD_DATE="1374663909" PRIVATE="0" TOREAD="0" TAGS="clojure,lib,tool,aws,emr">TheClimateCorporation/lemur</A>
<DD>Lemur is basically a configuration tool for EMR, aka Elastic Map Reduce. The command line tool for EMR is not exactly user friendly in terms of how long and complicated the command line can be. Lemur stores part of that complexity in a EDN clojure configuration which is easier to maintain and evolve. Lemur also offers a command line tool to start the computation and other basic tasks. It can be used as the base for EMR automation of jobs including pre and post hooks to trigger other actions (like data import) before the map reduce action.

<DT><A HREF="http://clojuredocs.org/clojure_core/clojure.core/var" ADD_DATE="1374580809" PRIVATE="0" TOREAD="0" TAGS="clojure,var,meta,symbol,interning">ClojureDocs - clojure.core/var</A>
<DD>Var has to do with symbol resolution and is not very frequently used, really. When you create a symbol with (def x) what is happening is that a symbol x is created in the current namespace that is not bound to any specific value. You can still make use of that symbol for example with metadata attached to it, but how to modify metadata for a symbol? If I type x I get Unbound. What I need is to access the symbol and not the value is pointing at. In that case I can use var: (meta (var x)) access metadata about the symbol. The fact of creating a symbol in a namespace is often called &quot;interning&quot; of the symbol. There is also a reader shortcut for that: #'x is the same as (var x).

<DT><A HREF="http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/constantly" ADD_DATE="1374506990" PRIVATE="0" TOREAD="0" TAGS="clojure,stadlib,constantly,identity">clojure.core - Clojure v1.5 API documentation - Constantly</A>
<DD>For this week in the Clojure std-lib we have constantly. Constantly returns a function that can be invoked with any number of arguments and always returns the parameter that was passed in. That is: ((constantly 5) [1 2 3]) =&gt; 5. One possible use of such a boring function is to stub results for another function that is invoking it with a variable number of arguments: (constantly true) for example.

<DT><A HREF="http://blog.theincredibleholk.org/blog/2013/06/17/what-is-macro-hygiene/" ADD_DATE="1374497145" PRIVATE="0" TOREAD="0" TAGS="">What is Macro Hygiene? - Eric Holk</A>
<DD>sometimes is good to remember why a good macro processor is supposed to do or what kind of problems the designers of a macro engine in a language deal with. brian marick tweeted this post which is an easy introduction to the meaning of hygiene in macros. the main problem is the risk of variable hiding after the macro expansion.

<DT><A HREF="http://thinkrelevance.com/blog/2013/07/10/rich-hickey-and-core-async-podcast-episode-035" ADD_DATE="1374071876" PRIVATE="0" TOREAD="0" TAGS="clojure,audio,podcast,core.async">Rich Hickey and core.async - Podcast Episode 035</A>
<DD>Another good episode from the Relevance podcast, this time feature Rich Hickey talking about  one of the latest release of the core team. Rich explains what core.async is and how it works. I was surprised to know how much it was achieved by using macros. After the macro transformation, using core.async is not different from an event-driven framework including the attached callback hell. What's amazing about core.async is that all the plumbing to create state for your invocations and related callbacks are created at compile time through macros, so you don't see actually anything about callbacks with the illusion that the main thread is blocking for a response when instead is just parked in wait state without consuming any resource. The main functions of core.async are also quite expressive, allowing the developer to adapt them to many popular concurrent problems involving blocking queues.

<DT><A HREF="http://richardminerich.com/2013/07/in-retrospect-qcon-nyc-2013-and-a-conversation-with-rich-hickey-on-languages/" ADD_DATE="1374064377" PRIVATE="0" TOREAD="0" TAGS="clojure,rich,hickey,static,dynamic,dinner,discussion">In Retrospect: QCon NYC 2013 (and a conversation with Rich Hickey on languages)</A>
<DD>If you're interested in the sort of discussions you might hear while having dinner with Rich Hickey, this blog post is a quick report exactly about that :) So when the discussion went into static VS dynamic typing I learned another interesting metaphor by Rich, who considers that the glue of a program shouldn’t know anything about what it’s gluing, much like a Fedex truck wasn’t designed with the contents of the boxes it carries in mind. At the end Rich agreed that it's very much a problem of context, although one can have their preferences about one programming school or the other.

<DT><A HREF="http://alandipert.tumblr.com/post/55324450821" ADD_DATE="1373902078" PRIVATE="0" TOREAD="0" TAGS="clojure,java,startup,jvm,bootstrap,share">Faster Clojure Startup with Class Data Sharing</A>
<DD>An interesting trick. It's the first time I hear about the class data sharing -Xshare option of the JVM 1.5+. The shared archive is optimized for better startup times using several techniques and can be used for bootstrap classes as well. This short blog post explains how to use it to cut clojure startup time dramatically. Unfortunately, I don't think this is working on the Mac (but please provide your experience about it) because the java invocation complaints about this feature not being available on the client version of the JVM even when I use the -client flag.

<DT><A HREF="http://clojuredocs.org/clojure_core/clojure.core/seque" ADD_DATE="1373473271" PRIVATE="0" TOREAD="0" TAGS="clojure,stdlib,queue,blocking,consumer,producer">ClojureDocs - clojure.core/seque</A>
<DD>Here we are again with the pearls-in-the-std-lib saga. This little function transform a sequence in a self-regulating blocking queue useful in all those situations where you want a producer and a consumer to agree on a volume of requests to process. It just wraps  functionality offered by the BlockingQueue in Java but as you can see from the example it does that in a much terser way.

<DT><A HREF="http://stackoverflow.com/questions/3208347/how-to-create-default-value-for-function-argument-in-clojure" ADD_DATE="1373470026" PRIVATE="0" TOREAD="0" TAGS="clojure,style,destructuring,parameters,default">How to create default value for function argument in Clojure - Stack Overflow</A>
<DD>There are basically two schools of thinking in Clojure when it comes to handle default values for a function parameter. The simple way is to have  multiple signature calling each other with a default value. Another is to use de-structuring of parameters in a map with an OR option. You might opt for destructing in case the optional parameters are more than one. That makes things less ugly than having too many signatures for a function.

<DT><A HREF="https://github.com/pedestal/app-tutorial" ADD_DATE="1373397596" PRIVATE="0" TOREAD="0" TAGS="clojure,pedestal,tutorial">pedestal/app-tutorial · GitHub</A>
<DD>Quick one to share the news that a comprehensive Pedestal tutorial is now available. The tutorial is very welcome, having tried myself to play with Pedestal and found the documentation lacking a true getting started section. Looking forward to try a little more of Pedestal app writing in my copious spare time.

<DT><A HREF="https://github.com/marick/Midje/wiki/Checkers" ADD_DATE="1373301695" PRIVATE="0" TOREAD="0" TAGS="clojure,midje,checkers,anything,irrelevant,metaconstants">Checkers · marick/Midje Wiki</A>
<DD>There are several useful checkers in Midje. I have use several of them, but never noticed &quot;anything&quot; or &quot;irrelevant&quot; which are totally useful when the specification of parameters is too noisy or not relevant while writing a fact. Metaconstants have a similar goal, but if they are checked in some &quot;provided&quot; function, they need somehow to come from the fact itself.

<DT><A HREF="http://www.leonardoborges.com/writings/2013/07/06/clojure-core-dot-async-lisp-advantage/" ADD_DATE="1373206438" PRIVATE="0" TOREAD="0" TAGS="clojure,async,stdlib,goroutines,csp">Clojure, core.async and the Lisp advantage</A>
<DD>core.async is a new library available on top of Clojure that was recently announced by Rich Hickey (as well as other core contributors). It takes inspiration from the Go language native support for CSP style concurrency, an old but goodie concurrency pattern. What Go &quot;goroutines&quot; and core.asynch allows is Concurrent Sequential Parallelism, where threads based on a thread pool can be orchestrated to provide a sort of &quot;optimistic&quot; approach to manage time consuming calls (often external services). This post by Leonardo Borges summarises this well: a central function coordinating three external service calls is allowed to return after a custom timeout, with partial or full results. The hope is of course that 90% of cases are returning full results allowing good perfromances while you can always retry again for the remaining 10%.

<DT><A HREF="http://stackoverflow.com/questions/5771168/what-is-the-used-for-in-clojure" ADD_DATE="1372957103" PRIVATE="0" TOREAD="0" TAGS="clojure,key,hashmap,namespace,hash,idiom">What is the :: used for in clojure?</A>
<DD>It is possible for code that you don't usually own to provide or require hash maps whose keys have a special meaning. Take for example the abused {:id &quot;some&quot;} key. It is very likely that if I'm a library provider and I use :id for an hash map that the final user needs to manipulate then there could be some sort of clash with a custom-applicative :id key. The double :: lets you specify a namespace for that key, for example ::myna/id so final users of that hash needs to know that namespace if they really want to override my &quot;:id&quot; key.

<DT><A HREF="http://clojuredocs.org/clojure_core/1.2.0/clojure.core/doto" ADD_DATE="1372946133" PRIVATE="0" TOREAD="0" TAGS="clojure,tools,macro,java,interop,stdlib">ClojureDocs - clojure.core/doto</A>
<DD>Doto is an useful macro which shines especially in the case of java interop. The rule is that the first argument is evaluated and all the following functions are then called using the evaluation as the first argument. Of course this is super-useful for creating an instance of an object and pass it down to a series of set/prepare kind of stuff before executing some other operation.

<DT><A HREF="https://github.com/nathanmarz/cascalog/tree/develop/midje-cascalog" ADD_DATE="1372789878" PRIVATE="0" TOREAD="0" TAGS="clojure,cascalog,midje,test,queries,bigdata">cascalog/midje-cascalog at develop · nathanmarz/cascalog</A>
<DD>Midje Cascalog used to be a standalone project on GitHub that now has been deprecated and incorporated into the main Cascalog project. This is already by definition a success! Cascalog is fun to use and probably for this reason it's easy to create complicated queries that become pretty soon difficult to maintain. Consider also that Cascalog errors tend to be difficult to troubleshoot. One strategy is to build complexity incrementally and extract functions with a specific small scope. Midje cascalog helps exactly with that, but with the added bonus of covering each specific piece of behaviour with some tests, incrementally confirming assumptions about the result of subqueries.

<DT><A HREF="http://riemann.io/dashboard.html" ADD_DATE="1372788346" PRIVATE="0" TOREAD="0" TAGS="clojure,monitoring,newrelic,reimann,ganglia,alert,devops">Riemann - Dashboards</A>
<DD>Riemann is a monitoring and event processing framework. The main idea is to handle any sort of application event (logging, performances, exception and so on). Riemann is similar to New Relic although is definitely not that feature complete, multi-platform and cross-language like New Relic is. After all Riemann is a Clojure product with a Clojure DSL so it has a very specific narrow focus. The link is pointing at the out-of-the-box dashboard which comes with Reimann that is probably good for a lot of possible installations.

<DT><A HREF="http://skillsmatter.com/podcast/agile-testing/in-the-brain-of-uncle-brain" ADD_DATE="1371241195" PRIVATE="0" TOREAD="0" TAGS="clojure,fp,oop,unclebob,video,talk,dedsign">Skills Matter : In The Brain of Uncle Bob (Robert C. Martin)</A>
<DD>Fascinating retrrospective of Uncle Bob taalking about the pillars of objectt orientation: encapsulation, inheritance and polymorphism. Uncle Bob claims at the end is that OOP is mostly about enabling easy polymorphism than anything else. he recognizes that concepts like encapsulation or inheritance are possbile in the C language and something like polymorphism aleady existed in assembly language as a technique to avoid expensive release of boards containing a sequential program in a series of 32K eproms. But easiness of polymorphism has a tremendous impact: it enables dependency inversion, one of the most popular techniques to dirrect dependencies in a single direction, which, ultimately, enables maintenability of software. he didn't talk about functional programming in this context so the following arre my thouthgs. encapsulation in FP has a simpler meaning, it means manly cohesion of related function that is achieved with namespaces (clojure) and functors (ML and close derivatives like Scala). Ijnheritance in FP is also possible in terms of relations between namespaces (not involving types). Polymorphism is also heavily present ijn Clojure: multimetods and protoclols are the enabling techniques. Polymorphism in FP has the same result, it can be used to invert pendencies and increase maintenability. That is maybe why FP is an equially powerful paradigm for modern programming.

<DT><A HREF="https://github.com/clojure-cookbook/clojure-cookbook/blob/master/CONTRIBUTING.md" ADD_DATE="1371111130" PRIVATE="0" TOREAD="0" TAGS="clojure,book,recipes">clojure-cookbook/CONTRIBUTING.md at master · clojure-cookbook/clojure-cookbook · GitHub</A>
<DD>this is a neat idea. A cook-book format is always welcome in my book collection whatever the language. Having one for Clojure is definitely good news. In this case the idea is even better and recipes are contributed by the community for the community. The current list of proposed chapters doesn't contain &quot;executing code in parallel&quot; but that might change in the future (I've got a few ideas about it). Looking forward to the final book!

<DT><A HREF="https://github.com/dgrnbrg/spyscope" ADD_DATE="1371052155" PRIVATE="0" TOREAD="0" TAGS="clojure,tools,log,spy,debug,development">dgrnbrg/spyscope · GitHub</A>
<DD>Spyscope takes tools.logging &quot;spy&quot; function to the next level. Spyscope allows to pretty print partial results of a computation like a normal logging tool does, but it can be injected at the reader level and put into your lein profile. At that point #spy reader macros are available in development mode on all your projects and repl sessions.

<DT><A HREF="https://github.com/fogus/marginalia" ADD_DATE="1371030730" PRIVATE="0" TOREAD="0" TAGS="clojure,marginalia,documentation,docs">fogus/marginalia · GitHub</A>
<DD>Marginalia is the documentation generation tool behind so many beautiful &quot;read docs&quot; links on Clojure projects. It is normally better used as leon marg using the corresponding leiningen plugin and it generates a &quot;docs&quot; folder with a ready to read html inside. Documentation is generated starting from normal Clojure block comments on namespaces or functions. The layout put the documentation just beside the source code in the final document.

<DT><A HREF="https://github.com/kumarshantanu/lein-sub" ADD_DATE="1371029873" PRIVATE="0" TOREAD="0" TAGS="clojure,build,leiningen,tools,plugin,sub,projects">kumarshantanu/lein-sub · GitHub</A>
<DD>I was looking into Pedestal and I noticed the use of lein sub. The lein sub plugin is useful when your project is getting bigger and you need sub-projects to keep it clean. The concept is similar to Maven submodules but more &quot;functional&quot;: lein sub will apply the command you pass in (the &quot;function&quot;) to the collection of submodules.

<DT><A HREF="https://gist.github.com/reborg/5749484" ADD_DATE="1370936859" PRIVATE="0" TOREAD="0" TAGS="clojure,repl,fireplace,vimclojure,tmux">Handy tmux.sh to add to your new Clojure project</A>
<DD>I'm finally moving my old vimclojure setup to the new shiny vim-fireplace. I think fireplace is more robust and generally more modern than the venerable and ground-breaking vimclojure, but I was missing the possibility to open up a vim pane with a REPL. With tmux and some scripting you can make it a default setup, including running Midje autotesting interactively (that is you can still use the REPL). The other neat thing is that vimclojure is connected to the same REPL session, so all changes are reflected both sides.

<DT><A HREF="http://clojure.github.io/clojure/clojure.repl-api.html#clojure.repl/apropos" ADD_DATE="1370852527" PRIVATE="0" TOREAD="0" TAGS="clojure,tools,apropos,find-doc,doc,repo">clojure.repl - Clojure v1.5 API documentation</A>
<DD>Wow, how it comes I never noticed this little function in the Repl-tools! You probably notices that a (find-doc &quot;searchme&quot;) can return quite a big number of results that are difficult to navigate. But sometimes you just need to see the name of that function that you now don't remember instead of reading pages of documentation. In that case (apropos &quot;searchmenow&quot;) just shows the list of matching function and offers the possibility to open one by typing its number. Handy.

<DT><A HREF="http://ecmendenhall.github.io/blog/blog/2013/05/25/network-closures-in-clojure/" ADD_DATE="1369948178" PRIVATE="0" TOREAD="0" TAGS="">Network closures in Clojure</A>
<DD>WIP

<DT><A HREF="http://2013.flatmap.no/" ADD_DATE="1369817032" PRIVATE="0" TOREAD="0" TAGS="clojure,scala,video,presentation,conference,flatmap">flatMap(Oslo)</A>
<DD>Just a quick one to signal that most of the FlatMap Oslo videos are now available. There is quite a good selection of presentation, both Scala and Clojure plus other topics.

<DT><A HREF="http://lispinsummerprojects.org/welcome" ADD_DATE="1369816452" PRIVATE="0" TOREAD="0" TAGS="clojure,competition,hacking,railsrumble,clojurecup">Lisp in Summer Projects - welcome</A>
<DD>Here's a different style of competition where Clojure is welcome. In comparison with clojurecup.com which is more a sprint inspired by railsrumble.com, Lisp summer of code allows much more time to complete, more similar to Google summer of code. Even ClojureScript is welcome or anything else homoiconic. If you're interested signup opens 1st of June and development the 24th. Happy hacking!

<DT><A HREF="http://sicpinclojure.com/" ADD_DATE="1369815621" PRIVATE="0" TOREAD="0" TAGS="clojure,scheme,sicp,book,porting">SICP in Clojure</A>
<DD>SICP in Clojure website is the ambitious project to create a version of SICP in Clojure. There are countless github sicp clojure ports of exercises and chapters, but the goal of this website seems to be to provide an online form of the entire book where snippets of Scheme are replaced by Clojure. In theory I don't see why this shouldn't be possible. At the moment only formatting and syntax highlighting is working, but the book is still total Scheme. Keeping an eye on it for future reference while I'm doing my exercises in Clojure on the SICP.

<DT><A HREF="http://blog.8thlight.com/micah-martin/2013/05/28/performing-code-katas.html" ADD_DATE="1369814384" PRIVATE="0" TOREAD="0" TAGS="clojure,kata,fizzbuzz,vim,tmux,tdd,bdd,midje">Performing Code Katas | 8th Light</A>
<DD>Katas in software development are short sessions of programming completely dedicated at the refinement of a technique or exploration of a theme. The goal of performing the kata is to abstract away from the usual business problems to concentrate on how to improve understanding and execution of common programming routines. More or less in the middle of this article FizzBuzz is performed in Clojure (http://vimeo.com/65902219) using a possible top-down approach, where you comment out outer levels of expectations until you reach the bottom and start developing your way up again. Although I understand the process, I don't like commenting out pieces of acceptance criteria that in much more complicated situations could be potentially checked in. I prefer the Midje approach of marking as unfinished what stays one level below and use &quot;provided&quot; to stub out results. I have a question for Micah though: how katas fit into the company process? Is your 20% spent on that? Or is it more like testing where you don't ask customers for permission, but just use it as a tool to provide quality code?

<DT><A HREF="http://www.thoughtworks.com/radar" ADD_DATE="1369332282" PRIVATE="0" TOREAD="0" TAGS="">Technology Radar May 2013 | ThoughtWorks</A>
<DD>It is worth mentioning that in the last issue of the ThoughtWorks technology radar, languages like Clojure or Scala entered the &quot;adopt&quot; section. Very innovative databases like Datomic are still considered young technology and thus going into the &quot;assess&quot; section. I'd probably say, no big surprises here!

<DT><A HREF="https://groups.google.com/forum/#!msg/london-clojurians/7QBut2czNDg/3sGA3eJwjmEJ" ADD_DATE="1369212784" PRIVATE="0" TOREAD="0" TAGS="clojure,tdd,process,repo,programming">Test-driven to REPL-driven development - Google Groups</A>
<DD>Sorry to quote myself, but I'm trying to understand all the fuss about REPL driven development I'm hearing in the Clojure community. Dear Clojure weekly reader, consider to comment below to point me to the right direction. Unfortunately, I don't have enough experience pairing with somebody who practice the process to understand exactly what's going on, so I'm searching for something like the bowling kata step by step explanation to see what exactly happens at the REPL console, how that replaces the red-green-refactor TDD microcycle and how that drives the design. This discussion from the London Clojurians Google group highlight some of the aspect of it but fails (at least for me) to completely explain in which way the new process is better than the old.

<DT><A HREF="http://clojurls.com/" ADD_DATE="1369210154" PRIVATE="0" TOREAD="0" TAGS="clojure,news,aggregator,blog,groups">Clojurls - news and bits about Clojure</A>
<DD>I'd like to signal another Clojure news aggregator. Compared to PlanetClojure, Clojurls also aggregates other source of information that I personally check often: stackoverflow, google groups, blogs and twitter, all related to Clojure stuff. Added to my newsfeed.

<DT><A HREF="http://shop.oreilly.com/product/0636920030409.do" ADD_DATE="1369209932" PRIVATE="0" TOREAD="0" TAGS="clojure,video,lesson,halloway,course,workshop">Clojure Inside Out - O'Reilly Media</A>
<DD>A great series of video lectures on Clojure by Neal Ford and Stuart Halloway. I still have to go through all of them (5h+ of material) but the beginning seems quite promising. Watching this videos is like attending an half a day workshop on Clojure in glorious HD quality. Actually it is like they've been recorded during some sort of workshop for real. It comes at a price tag of 70$ so it is something you want to ponder a bit before buying. Promo videos are available also on youtube http://www.youtube.com/watch?v=EVzv5kMkOfo.

<DT><A HREF="https://github.com/clojure/tools.nrepl" ADD_DATE="1368814588" PRIVATE="0" TOREAD="0" TAGS="clojure,nrepl,repl,evaluation,swank,vim,fireplace">clojure/tools.nrepl · GitHub</A>
<DD>nREPL is service build on top of Clojure evaluation with a set of API that makes it IDE and tools friendly. It somehow replaces the venerable NailGun, a more generic remote Java executor service that was used in the past for similar features. nREPL is more flexible and better designed for this specific purpose, hence why most of the tools today are already using it. If you happen to develop Clojure on a VIM stack, vim-fireplace is what you may want to have a look at for Clojure evaluation under vim, since it connects by default on a running nREPL. Emacs people probably already know about https://github.com/kingtim/nrepl.el

<DT><A HREF="http://squirrel.pl/blog/2013/05/16/getting-started-with-pedestal-on-client-side/" ADD_DATE="1368814393" PRIVATE="0" TOREAD="0" TAGS="clojure">Getting Started with Pedestal on Client Side</A>
<DD>WIP

<DT><A HREF="http://martintrojer.github.io/clojure/2013/03/16/flexible-multi-consumerproducer-pipelines/" ADD_DATE="1368652089" PRIVATE="0" TOREAD="0" TAGS="clojure,queue,pipeline,workflow,orchestration,storm">Flexible multi consumer/producer pipelines</A>
<DD>This is an interesting little lib, something that resembles Storm but running on a single JVM. There are times when the kind of computation workflow naturally maps into a graph, especially when highly computational intensive processes are involved or big-data parallelisation is required. This blog post from the author explains in which cases it can be useful: if your workflow is a like pipeline and steps of the pipeline need orchestration then you might give Pipejine a try.

<DT><A HREF="http://blog.getprismatic.com/blog/2012/10/1/prismatics-graph-at-strange-loop.html" ADD_DATE="1368523329" PRIVATE="0" TOREAD="0" TAGS="clojure,graph,prismatic,library,tool,composition">Prismatic's &quot;Graph&quot; at Strange Loop — Prismatic Blog</A>
<DD>The team at Prismatic is putting a lot of effort in open sourcing their common solution to recurring problems (aka patterns). Graph is part of the Prismatic tool-belt. Basically, it is a way to express a functional composition in terms of a graph based data structure. Instead of a function with a lot of outgoing dependencies to lower level abstraction (and those functions may also be calling into each other) Graph allows to declare what output of which function should be the input into another function. I can see some relevant cases where this can be useful, for example composing chains of responsibilities that otherwise would result in big monster let-blocks at the beginning of a function. At the same time I fail to see how the same problem could not be solved by a better composition and abstraction of functions. I have the impression that if a function is calling into many other functions I might be missing a layer of abstraction and that would be my first attempt at refactoring instead of using graph.

<DT><A HREF="https://github.com/michalmarczyk/flexvec" ADD_DATE="1368221432" PRIVATE="0" TOREAD="0" TAGS="clojure,algorithm,contrib,tree,immutable,relaxed,radix">michalmarczyk/flexvec · GitHub</A>
<DD>Here's an example of how an interesting and efficient algorithm that improves the current 32-way branching tree used in Clojure vectors can make it as a contrib and maybe to core one day. Relaxed radix balanced trees (hence &quot;flex&quot; because the constrain about the branching is relaxed) are an alternative implementation for balanced trees that allows more efficient concatenation in log(n). The pay a small performance price just after the first concatenation for simple addition operation, but if the vector is never concatenated you get exactly the same B-Tree behaviour of the current Clojure implementation. It was discussed initially in clojure-ML http://tinyurl.com/cs6tuyl and quickly after in clojure-dev http://tinyurl.com/bvby85s and finally ended up in contrib. This data structure can be useful in all cases where concatenation of immutable vectors is used heavily: fork-join kind of operations or simple map-reducing operations producing a vector instead of a scalar.

<DT><A HREF="http://build.clojure.org/" ADD_DATE="1368220250" PRIVATE="0" TOREAD="0" TAGS="clojure,development,jenkins,ci">Dashboard [Hudson]</A>
<DD>All of Clojure and Clojure contributions are continuously integrated in a Jenkins instance running at the link above. It is kind of interesting to see when it was last built and when it was last failing. For Clojure for example you need to go way back to see a failure (on an external Ant task). The http://build.clojure.org/job/clojure-test-matrix/ job tests Clojure on several JDK versions and you can see that JDK 1.5 was lost in February and seems unrecoverable.

<DT><A HREF="https://github.com/jaycfields/jry" ADD_DATE="1368210027" PRIVATE="0" TOREAD="0" TAGS="clojure,tools,library,helper,hayfields">jaycfields/jry · GitHub</A>
<DD>Jry is a library of helper functions. I trust the source of them (Jav Fields) so I'm going to keep an eye on the functions there for the future. There are a few things I had to copy paste from snippets from somewhere else present here (like update-values in a map or keys) plus some ideas for names I never thought about like -&gt; to denote transform-this-&gt;to-that.

<DT><A HREF="http://blog.datomic.com/2013/05/excision.html" ADD_DATE="1368209478" PRIVATE="0" TOREAD="0" TAGS="clojure,datomic,events,excision,transaction">Excision | Datomic</A>
<DD>Datomic is designed following the principle that information is a stream of events that happen and events are never really removed from history. But there are some cases where data are explicit required to not exist anymore, for privacy reasons or other non-technical related requirements. For this reason Datomic can be requested to forget about data using the excise attribute on a specific ID in a transaction. Excision can be based on a specific time window as well. The funny part is that Datomic can't forget that you asked to forget. So the excision attribute allows to track what was excised but it can't be excised itself.

<DT><A HREF="http://confreaks.com/videos/2296-bigruby2013-keynote" ADD_DATE="1367925291" PRIVATE="0" TOREAD="0" TAGS="clojure,multithreading,actors,erlang,stm,ruby,talk,video,keynote">Keynote - Jim Weirich - Big Ruby 2013</A>
<DD>In this talk by Jim Weirich you'll find a nice cross language comparison between concurrency frameworks, like the single-thread event-based programming with NodeJs, or the Erlang inspired Celluloid framework written in Ruby, or the Clojure STM. All of that to build a Drone management console application for a customer (hey Jim, please let us know your clients, we want to create applications for them too!). Overall I enjoyed the analysis of single VS multithreaded approached to concurrency and the share memory or share-nothing distinction of Erlang actors. Jim clearly states that the Clojure STM is the most elegant of them all but at the same time it is intimately connected to a side-effect free language like Clojure. The Ruby based solution he explained in this talk is not that different although it requires Ruby implementations supporting OS-based threads (JRuby or Rubinius).

<DT><A HREF="https://github.com/Prismatic/dommy" ADD_DATE="1367924464" PRIVATE="0" TOREAD="0" TAGS="clojure,clojurescript,dommy,jquery,wrapper,web,prismatic">Prismatic/dommy · GitHub</A>
<DD>The Prismatic team has just released Dommy, an idiomatic ClojureScript wrapper for jQuery and DOM manipulation library in general. Dommy is one of the first library to explore the power of macros to generate JavaScript and the results are exciting. By controlling the  compilation step, macros allow for optimised direct access to the relevant DOM api to select elements instead of the corresponding runtime jQuery selector. Dommy provides several other enhancements over jQuery by making use of Clojure syntactic sugar, like sequence manipulation or Protocols. Have a look at the end of this blog post http://tinyurl.com/dxczqkm for more examples.

<DT><A HREF="http://www.pitheringabout.com/?p=937" ADD_DATE="1367642231" PRIVATE="0" TOREAD="0" TAGS="clojure,repl,dev,team">REPL bootstrap pimpage</A>
<DD>Welcome to the Clojure REPL world! The Ruby community which is definitely older than the Clojure community, already developed a culture of IRB extensions and tricks. Clojure is following with similar enhancements to the REPL that makes developer life easier. Here's a list of things you can add to your REPL from Jon Pither's team ready for copy and paste or reuse.

<DT><A HREF="http://blog.paralleluniverse.co/post/49445260575" ADD_DATE="1367640032" PRIVATE="0" TOREAD="0" TAGS="clojure,erlang,actors,continuations,fibers">Erlang (and Go) in Clojure (and Java)</A>
<DD>This article is quite a technological ride and full of wisdom. Continuations style programming is possible in java using bytecode instrumentation. The solution is not elegant or flexible, but it is one key ingredient for the actor-like solution in Clojure described in this post. It's also an experiment in bytecode manipulation of clojure generated classes which poses some challenges during the selection of the instrumentation points. Results seem promising with the possibility of implementing &quot;light&quot; threads that can be suspended and resumed. Light threads allow fast context switching and the fork-join scheduler allows for scheduling of tasks off a queue, resulting in a fast jvm-based actor framework. As the author said, Clojure is more suitable for a local actor-like implementation in the small while Erlang implements that better in larger systems.

<DT><A HREF="https://groups.google.com/forum/#!msg/clojure-dev/uAFM0Ti4AcQ/GmnKmphF1BgJ" ADD_DATE="1367231172" PRIVATE="0" TOREAD="0" TAGS="clojure,troubleshooting,leak,bytecode,bug">Bug in locals-clearing in Clojure 1.5? - Clojure 1.5.1 released.</A>
<DD>What happens when a critical bug is found in Clojure? Here's a fascinating example of spot-on  diagnosis and troubleshooting. It appears that a change to allow loop/recur in catch and finally (https://github.com/clojure/clojure/commit/ddc65a96fdb1163b) generated a memory leak that was spotted from the guys at Prismatic updating Clojure to the latest and greatest. Of course, no apparent connection between the commit and the effects until you test that out in the correct context. It is also evident that Clojure can be treated as a chain of generated languages down to the VM byte code: Clojure generates Java that generates byte code. Sometimes it can be useful to understand this and how to do it yourself especially if the problem is a memory leak. So, now you also know what is the reason for releasing 1.5.1.

<DT><A HREF="http://en.wikipedia.org/wiki/Software_transactional_memory" ADD_DATE="1367162677" PRIVATE="0" TOREAD="0" TAGS="clojure,stm,atom,pure,theory">Software transactional memory - Wikipedia, the free encyclopedia</A>
<DD>Clojure implements the elements of STM thanks to the core immutable data structures and concurrency control models like agent atoms or refs. But more in general, STM is an optimistic concurrency model of computation where conflicting changes are handled by re-attempting the same transaction over again. With such a model, locks are not needed. But STM assumes new state is just a function of the past and all the original variations in between are logged and available. Of course this is the definition of pure function in a functional language, so for Clojure (and other FP languages) the STM fits very well. This wikipedia entry explains in a simple way what is STM in general and why in general it can perform better.

<DT><A HREF="https://gist.github.com/thickey/1990327" ADD_DATE="1366982952" PRIVATE="0" TOREAD="0" TAGS="clojure,maven,leiningen,plugin,java,project,hybrid">Convert Maven pom.xml file to Lein project.clj</A>
<DD>A juicy handy GIST to convert a pom.xml to a project.clj ready for leiningen. Uhm why would you need such a thing? Say you have this nice Java project at work and you want to start using some Clojure bits with it. Fine, there are all the maven plugins ready for this and it will just work fine. But say that now that you have some Clojure bit in your maven based Java project you would also like to build it using a *real* building tool like leiningen? Why not, use this converter to create a project.json ready for that.

<DT><A HREF="http://cemerick.com/2010/03/25/why-using-maven-for-clojure-builds-is-a-no-brainer/" ADD_DATE="1366901271" PRIVATE="0" TOREAD="0" TAGS="clojure,maven,plugin,ide,development,java">Why using Maven for Clojure builds is a no-brainer | cemerick</A>
<DD>As the title say, Clojure integrates very well with your existing Maven setup. There are projects were leiningen is not an option (which is bad) but at least you can survive with a Maven setup and maybe have your Clojure files developed from inside an IDE that understands Clojure (all the usual suspects). I think this is a very good way to start using Clojure in a Java environment: bring in the maven plugin, have some Clojure developed and let your current Java project talk with the Clojure side for specialized tasks.

<DT><A HREF="http://defnewsletter.com/" ADD_DATE="1366788597" PRIVATE="0" TOREAD="0" TAGS="clojure,weekly,gazette,newsletter,email">(def newsletter) - A Weekly Clojure Newsletter - Home</A>
<DD>If you enjoy this Clojure Weekly, you might also enjoy another couple of options to receive weekly updates about your favourite language. Today we talk about (def newsletter) that similarly to http://www.clojuregazette.com is promising to &quot;spam&quot; you with good Clojure content every week. Clojure Gazette in particular is different because it has a theme each week around which the links are selected. Thanks to Planet Clojure aka http://clojure.in I enjoy the Gazette anyway. Unfortunately I'm not one of those person who enjoy another email in the mailbox: even if it is great content I just tend to skip them. In that case stick to Clojure Weekly that is delivered to your door through your favourite news reader.

<DT><A HREF="http://blog.guillermowinkler.com/blog/2013/04/20/real-life-clojure-application/" ADD_DATE="1366749566" PRIVATE="0" TOREAD="0" TAGS="clojure,clojurescript,example,app,learning,web">Real Life Clojure Application - Interrupted</A>
<DD>It's always a good exercise to learn from the code of others. Notify Me shows a solid Clojure web stack, with Compujure, Clojurescript and Midje for testing, plus a lot more goodies, to send mass sms or emails. It also includes manuals and installation instructions, something that is definitely required for a project that should be used in real-life.

<DT><A HREF="http://augustl.com/blog/2013/truly_concurrent_user_interfaces" ADD_DATE="1366739870" PRIVATE="0" TOREAD="0" TAGS="clojure,ui,rendering,openGL">Truly concurrent user interfaces</A>
<DD>Concui is an UI library built on top of openGL primitives. What makes Concui maybe unique, is the fact that it operates with pure function at its core, a function that given the state of the UI it renders the the actual graphics raprsenting them. It is different from the majority of UI rendering approaches because there is no graph of object hodling the state of the UI but a gigantic structure that is rendered 60 times a second. If you are interested into functional approaches to UI rendering go checkout this project.

<DT><A HREF="http://blog.iterate.no/2013/04/18/economies-of-scala/" ADD_DATE="1366357160" PRIVATE="0" TOREAD="0" TAGS="clojure,scala,adoption,comparison,survey">Economies of Scala | blog.iterate.no</A>
<DD>This article is a quick analysis of data coming from online sources and specific questions made to the Java development community in Norway. Although it cannot be representative of the world-wide software developers population is still statistically significant. It basically tell us that: 1. If a developer in Norway is asked what languages would you select for work (not because you like them) Java is coming first, with some scripting languages coming next, Scala somewhere in the middle. 2. If a developer in Norway is asked then what languages would you prefer to use (independently from the market request) then Java goes down the list and Scala is first, followed by Clojure and Python. The bad news for us &quot;clojurians&quot; is that wherever I look, I always find the same situation, with more than half of team already looking into or working with Scala and some people with an interest in Clojure. Is the Clojure community fighting a loosing battle?

<DT><A HREF="http://pragprog.com/book/mbfpp/functional-programming-patterns-in-scala-and-clojure" ADD_DATE="1366271897" PRIVATE="0" TOREAD="0" TAGS="clojure,scala,book,patterns,fp">The Pragmatic Bookshelf | Functional Programming Patterns in Scala and Clojure</A>
<DD>I'd like to highlight a new potential addition for your functional bookshelf. The book by Michael Bevilacqua-Linn explores OO patterns translation to the functional world (a parallelism that has been attempted over and over with mixed results, starting from is a non-sensical exercise to you can replace them all in FP with a few simpler ones, see Peter Norvig http://www.norvig.com/design-patterns/) and purely functional pattern, like lazy sequences, tail recursion and memoization. I didn't read the book myself, but I was wondering if the listed patterns are really what I consider functional patterns: many of them are implementable in OO as well. I would like to see explored instead things at a lower level, like introduce binding, wrapping or http://programmers.stackexchange.com/questions/116395/what-is-the-good-explanation-of-tennents-correspondence-principle

<DT><A HREF="http://stuartsierra.com/2013/02/04/affordance-concision" ADD_DATE="1366229492" PRIVATE="0" TOREAD="0" TAGS="clojure,contains,get,core,patch,improvement">Affordance and Concision | Digital Digressions by Stuart Sierra</A>
<DD>Another discussion about the dreaded &quot;contains?&quot; function in Clojure. I've written already about it and I've been bitten several times by expressions like (contains? [1 2 3] 3) =&gt; false. Stuart Sierra had that modified with http://dev.clojure.org/jira/browse/CLJ-932 to throw an exception if the collection is not associative. I second that, the previous behaviour sounded more like an hack for some corner case than a real feature of contains?. Now the same problem happens with get on non associative collections: (get [1 2 3] 3) =&gt; nil. Of course once you know the rule everything sounds simpler, but it definitely generates confusion. Stuart Sierra is proposing to have the same behaviour for get, throwing an exception instead of returning a nil.

<DT><A HREF="http://clojure.org/java_interop#Java Interop-Type Hints" ADD_DATE="1366096854" PRIVATE="0" TOREAD="0" TAGS="clojure,reflection,type,hint,performance,native">Clojure - java_interop - Type Hints</A>
<DD>First rule of type hinting in Clojure is that you should only use it when working on pure performance improvement. That means to have in place acceptance criteria for performances in your application, look at time taken to perform some action, maybe some profiling and then decide that type hinting is going to help you out. Type hinting in Clojure is not that bad, but certainly is not as readable as non-type hinted code. It goes even worse when you use overloaded functions for Java primitive types (such as aget, aset on Java arrays type). Having said that, the Clojure compiler is smart enough to understand a ramification of type hints from an originating one, that is, if you type hint the return of a function, the compiler is going to track usages of the returned values and create overridden internal functions accordingly instead of using Reflection.

<DT><A HREF="http://clojurewerkz.org/" ADD_DATE="1365875433" PRIVATE="0" TOREAD="0" TAGS="clojure,library,tool,utilities">Clojure libraries for MongoDB, Riak, RabbitMQ, validations, Neo4J, ElasticSearch, Memcached, Apache Cassandra, Kestrel and more</A>
<DD>Look no further if you're searching for a Clojure wrapper around a popular service library or utility. It might be already in ClojureWerkz, a toolbox of swiss army knives that is well documented, tested and coded on github. Amongst the others: Langohr (RabbitMQ), Elastisch (AWS Elastic Search), Quartzite (scheduler based on Quartz) and so on.

<DT><A HREF="http://illegalargument.com/illegal-argument-episode-98-typed-clojure" ADD_DATE="1364936764" PRIVATE="0" TOREAD="0" TAGS="clojure,audio,podcast,types,haskell,ambrose">Illegal Argument - Typed Clojure</A>
<DD>I listened to this podcast a couple of times already, but I still have to digest it completely. The topic is maybe controversial, or, how to type Clojure, a work Ambrose Bonnaire Sergeant in his spare time while doing his dissertation. I have to admit that after I attended Simon Peyton Jones talking about funky Haskell typing tricks at the last Functional Programming eXchange I see language typing as yet another programming challenge, not an inviolable rule a language must grow with. Core.typed is one of those challenges, how the Clojure compiler can be decorated with type information that can then be used for performance optimisation and of course static type checking. There is still a lot of work to do and Ambrose does his best at describing what the challenges are in this podcast.

<DT><A HREF="http://nightweb.net/" ADD_DATE="1364929024" PRIVATE="0" TOREAD="0" TAGS="clojure,android,p2p,torrent,project">Nightweb</A>
<DD>Nightweb is a p2p network for Android mostly written in Clojure. It demonstrate some decent level of complexity implementing a Clojure app and also Android interop. There are a few challenges still to run the Clojure runtime on Android, like the startup slowness and memory consumption but it also shows the possibility of Clojure on mobile devices. On the other side, Clojure demonstrates solid server multi-threading capabilities as it should be expected. Also look into this project to drive torrent-based p2p networks.

<DT><A HREF="http://clochure.org/" ADD_DATE="1364834971" PRIVATE="0" TOREAD="0" TAGS="clojure,joke,april,parenthesis">Clochure - A Better Clojure</A>
<DD>It's April 1st in Clojure community, so here's a brand new replacement for Clojure called Clochure that finally solves the number one annoyance in Clojure so far: parenthesis. Try to imagine to program in Clojure without the need to see those tedious parenthesis and imagine instead a world where all that curvilinear non-sense is replaced by square brackets. This is Clochure, give it some love.

<DT><A HREF="http://www.youtube.com/watch?v=Ipjrhue5bXs&feature=share&list=SP055Epbe6d5ZEYjq8K7CA37-1fEST-yWe" ADD_DATE="1364770336" PRIVATE="0" TOREAD="0" TAGS="clojure,video,talk,immutable,data">Strata 2013: Nathan Marz, &quot;Human Fault-tolerance&quot; - YouTube</A>
<DD>Here's Nathan Marz (he was still at Twitter here) with a quick 8 minutes overview about how a system designed to accommodate human failure should work. Immutability should be the &quot;source of truth&quot; of your system, not a mutable database as it has been for the last few decades. Today this is possible (look at Datomic) and advisable. When the source of truth is immutable catastrophic failures can be recovered by playing the same actions over the last snapshot of data. Enjoyed the talk which clearly echoes some of the Rich Hickey's mantras.

<DT><A HREF="http://www.leonardoborges.com/writings/2013/03/25/clojure-and-why-calculating-is-better-than-scheming/" ADD_DATE="1364494591" PRIVATE="0" TOREAD="0" TAGS="clojure,haskell,miranda,wadler,sicp">Clojure and 'Why calculating is better than scheming'</A>
<DD>Leonardo Borges does a good job here at summarising why Clojure can be better than a Lisp (in this case Scheme) starting from a paper that Phil Wadler wrote discussing what Scheme is missing as a teaching language compared to Miranda (that along with KRC is one of the main influences behind Scheme). Scheme is of course the driving language behind SICP, one of the principal books for teaching programming for the last decades. Pattern matching and laziness are amongst them but Clojure does a great job at them with core sequences and macros (kind of compensating for the lack of pattern matching). There are others example like this that makes this an interesting reading.

<DT><A HREF="https://github.com/clojure/clojure/blob/master/src/clj/clojure/core/reducers.clj#L315" ADD_DATE="1364322787" PRIVATE="0" TOREAD="0" TAGS="clojure,monoid,reducers,fold,associative">clojure/src/clj/clojure/core/reducers.clj at master · clojure/clojure · GitHub</A>
<DD>A monoid definition is not as scary as it sounds. It is a set where elements obey three simple rules given an operation that we are going to call &quot;dot&quot;: closure, associativity and identity. It turns out mathematic and computer science are full of such set and if you really want to go deeper, they come with a full blown theory that you can lost years of your life to learn. Clojure call monoid a much simpler concept, a function that creates a function of [op ctor] that when given no arguments invokes (ctor) and with two arguments returns a function of a,b where (op a b) is called. The monoid function is useful to combine back results from a fold in its two argument form and it also works as a custom identity function for reduce.

<DT><A HREF="http://maurits.wordpress.com/2013/03/10/refactoring-java-using-clojure-with-the-eclipse-java-development-tools-jdt/" ADD_DATE="1364309685" PRIVATE="0" TOREAD="0" TAGS="clojure,ast,parsing,java,refactoring">Refactoring Java using Clojure with the Eclipse Java development tools (JDT) | Maurits thinks aloud</A>
<DD>Is refactoring easy to implement by a modern IDE? It's not at all and depending on the grammar you're dealing with it can be a moderate difficult up to a hugely complicated task. This article describes a simplified version of an already very simple refactoring to remove useless parenthesis from a return call. It targets Java and it requires knowledge about how to create an AST and how to manipulate it. The setup and manipulation on top of Java Eclipse ADT framework is done through Clojure, simplifying the thing with some more terse syntax. An interesting experiment.

<DT><A HREF="https://github.com/bbatsov/clojure-style-guide" ADD_DATE="1364257857" PRIVATE="0" TOREAD="0" TAGS="clojure,kata,dojo,style,idiomatic">bbatsov/clojure-style-guide · GitHub</A>
<DD>Got this link from @javame on twitter, a nice collection of dos and donts for clojure. The first part is core style that for me is almost completely covered by tooling in vim-clojure. The second part is a collection of interesting idiomatic clojure tips that is worth reading with care (and exercise as much as possible). Probably worth creating a constrained kata of some sort of them.

<DT><A HREF="http://redmonk.com/dberkholz/2013/03/25/programming-languages-ranked-by-expressiveness/" ADD_DATE="1364249113" PRIVATE="0" TOREAD="0" TAGS="clojure,languages,expressiveness,charts,graph,commits,loc">Programming languages ranked by expressiveness – Donnie Berkholz's Story of Data</A>
<DD>Ranking languages by expressiveness is an hard task. This article should be considered an rough approximation for expressiveness based on a few assumptions: commits are based of unit of completed functionalities, a completed functionality has sort of the same scope in all languages, number of lines of codes is a measure for expressiveness (the more lines to express a functionality the less expressive the language) and finally the less lines of code the better is the maintenance of the sources. And it makes all sort of sense really, maybe this is the reason of the few surprises in the results: Clojure is amongst the most used expressive languages, as is CoffeeScripts. Other very popular languages are in the middle and Java is toward the bottom of the scale. Take this statistics with a grain of salt. Of course.

<DT><A HREF="http://pedestal.io/#about" ADD_DATE="1363689106" PRIVATE="0" TOREAD="0" TAGS="clojure,pedestal,web,compojure,noir,framework">Pedestal Documentation - Build web apps in Clojure</A>
<DD>Potentially the biggest news this week, Relevancers released Pedestal, a brand new web application framework in Clojure. I skimmed through the documentation but couldn't try out, will definitely do the next webapp with it. On the surface it remembered me of Compojure or the now gone Noir. It also sounds it is an integrated environment instead, where what used to be the custom made &quot;ring stack&quot; is now a default choice. Can't say more for now, it is well documented and support on github and google groups. Give it a go if you can, I'm looking forward to it.

<DT><A HREF="https://groups.google.com/forum/?fromgroups=#!searchin/midje/provided/midje/QEgjL_uACRQ/nCtZj6zr9CQJ" ADD_DATE="1363429275" PRIVATE="0" TOREAD="0" TAGS="clojure,midje,tdd,test,bdd,topdown">Separating code from tests: What is the vision? - Midje</A>
<DD>I was reasoning about later stages of development, when sources are already in their own files but at the same time I need to add more features. Since I'm not in the test file anymore, I thought I had to abandon my beloved top-down style, the midje &quot;provided&quot; keyword and the powerful &quot;unfinished&quot; block. Fear no more! This quick reply by Brian just tells you how to use unfinished in the source file and also gives you some reasons why you might even leave it after check-in.

<DT><A HREF="https://github.com/tpope/vim-fireplace" ADD_DATE="1363426948" PRIVATE="0" TOREAD="0" TAGS="clojure,vim,setup,ide,repl,editor">tpope/vim-fireplace · GitHub</A>
<DD>Dear Clojure vim users (I'm not sure, but I have the impression there are just few of us), it seems that the glorious VimClojure life came to an end. VimClojure will be living in several different forms that are converging again to give you the best of the interactive Clojure experience in vim. Fireplace is a nREPL that replace the hg-server nailgun system of VimClojure. Along with it, the static part of VimClojure still lives in https://github.com/guns/vim-clojure-static project. Instructions are provided, I still have to migrate myself (my vim-clojure setup works great at the moment, not sure why I should migrate). If you're starting today with vim and Clojure wait no more and follow the instruction listed on the github project page.

<DT><A HREF="http://clojuredocs.org/clojure_core/1.3.0/clojure.core/every-pred" ADD_DATE="1363412313" PRIVATE="0" TOREAD="0" TAGS="clojure,filter,predicate,stdlib,util">ClojureDocs - clojure.core/every-pred</A>
<DD>every-pred is a powerful filter-chaining tool. Say you have a collection of stuff and you want to alter elements based on a set of filters: number? even? or more complicated ones. (filter even? (filter number? '(1 2 3 :a :b))) holds up to a point if you don't have too many filters. But what if you have a long list of filters? (filter (apply every-pred [number? even?]) '(1 2 3 :a :b)) fixes the problem for an arbitrary long list of predicates.

<DT><A HREF="http://funcall.blogspot.sg/2009/03/not-lisp-again.html" ADD_DATE="1363346504" PRIVATE="0" TOREAD="0" TAGS="clojure,history,lisp,sicp,kit">Not List again...</A>
<DD>I enjoyed this reading about somebody who was there when MIT started teaching the Computer Science course in 1983. Lisp was resurrecting again in the form of Scheme and that course was taught until the last year. Not to mention that a book was extracted from that same course, the SICP. The examples in the book are some extracts from SICP up to chapter 1.3 where higher order functions are introduced.

<DT><A HREF="https://github.com/clojure/algo.generic/blob/master/src/main/clojure/clojure/algo/generic/functor.clj" ADD_DATE="1363215759" PRIVATE="0" TOREAD="0" TAGS="clojure,stdlib,map,values,update">algo.generic/src/main/clojure/clojure/algo/generic/functor.clj at master · clojure/algo.generic · GitHub</A>
<DD>Updating all values in a map sounds like a common operation in Clojure, but there is no dedicated function to it in the standard library. The closest match is update-in that only updates values if they match the given key. What I'm talking about here is global value update for each key. It turns out the solution is pretty straightforward using list comprehension with (into {} (for [[k v] m] [k (f v)]))) where m is the map and f is the updating function, for example inc. A generic update-values called fmap is included in algo.generic.functor, one of the old contrib now moved to the new repo.

<DT><A HREF="http://programming-puzzler.blogspot.co.uk/2013/03/logic-programming-is-overrated.html" ADD_DATE="1362879379" PRIVATE="0" TOREAD="0" TAGS="clojure,core,logic,puzzle,hype">Thoughts on Programming: Logic programming is overrated</A>
<DD>Logic programming is overrated? I don't think this is the case. There is certainly hype about it in the Clojure community at the moment, just because people like the intriguing &quot;new&quot; paradigm and they are experimenting a bit with something they don't know. Is not that different from what is happening in the Ruby community, with people learning about classic OO patterns and trying to apply them. Are they a silver bullet? Of course they aren't. But there are problems which are solved very elegantly with logic programming, so why not use something that is available and ready for Clojure like core.logic? This post describes a Clojure implementation of a logic puzzle that is solvable without logic programming. It is sufficiently elegant, no doubts. Is that best solved with core.logic? Depending on your level of proficiency maybe yes. Should I always use core.logic to solve typical logic puzzles? Of course not.

<DT><A HREF="http://www.lispcast.com/3-things-java-can-steal-from-clojure" ADD_DATE="1362878217" PRIVATE="0" TOREAD="0" TAGS="clojure,java,stdlib,edn,stm">3 Things Java Programmers Can Steal from Clojure | LispCast</A>
<DD>Maybe many don't realise that consistent part of the Clojure standard library are written in Java (and a consistent part is Clojure as well). It should be then possible to include the Clojure jar and import classes in your Java code right? This blog post is talking about three example of uses of Clojure from Java directly. The usage of Clojure classes is not advisable nor elegant, but as an experiment you can see how it works and maybe there are corner cases where you could use this approach. For example, you could use Clojure persistent data structure today in your Java code or maybe EDN (a better exchange format for data).

<DT><A HREF="http://www.ibm.com/developerworks/library/j-jn1/" ADD_DATE="1362821734" PRIVATE="0" TOREAD="0" TAGS="clojure,polyglot,jvm,groovy,scala">Java.next: The Java.next languages</A>
<DD>Neal Ford was talking about polyglot programming in 2006 already. In this series of articles for IBM DeveloperWorks Neal is introducing three of the most prominent languages that run on the JVM and eligible to be the &quot;Java.Next&quot;. Important concepts like static VS dynamic typing or imperative VS functional paradigm are discussed here. Clojure is certainly the language that takes the most extreme approach compared to Groovy or Scala which is also what enables Clojure the most groundbreaking solutions.

<DT><A HREF="http://stackoverflow.com/questions/4522796/how-should-i-make-a-clojure-stm-program-persistent" ADD_DATE="1362611657" PRIVATE="0" TOREAD="0" TAGS="clojure,stm,acid,durability,persistence,dosync,agent">How should I make a clojure STM program persistent? - Stack Overflow</A>
<DD>This StackOverflow answer describes an approach to durability for the STM. The Software Transactional Memory of Clojure is an elegant abstraction on top of Clojure main data structures to handle concurrency of modifications in memory. As it is completely in memory it lacks the &quot;D&quot; of the ACID properties. You can add Durability with a dosync that encloses changes to the local memory and an agent. Agent are STM transaction aware, in the sense that actions enqueued to the Agent are executed once (even in the event of STM retries) and only at the end of all other successful transactions. dosync with agents is especially good for &quot;write-behind&quot; kind of semantic, where some side-effect that includes potentially blocking IO is send asynchronously to the agent to be executed only once if the transaction succeed.

<DT><A HREF="http://beust.com/weblog/2010/08/19/clojure-concurrency-and-silver-bullets/" ADD_DATE="1362610932" PRIVATE="0" TOREAD="0" TAGS="clojure,concurrency,cedric,bullet,actors,agents,STM">Clojure, concurrency and silver bullets « Otaku, Cedric's blog</A>
<DD>Cedric's blog must be one of the most read java-based blog around. I used to follow Cedric in 2005 maybe? It was already a good read. Cedric is an exceptional engineer and his blogs tend to be provocative. And it's not the first time I read some negative comments about a new technology or language on Cedric's blog which is lacking evidence. Cedric thinks that Clojure STM or Agents or Scala's actors are not a silver bullet for concurrent programming. Probably they aren't, but they are definitely a better level of abstraction for many of the concurrency problem (like objects were at describing real world simulations). Stuart Halloway's comment at the bottom probably summarises my thinking the best. At the same time I'm pleased to see sometimes provocative blog posts like this one although they lack evidence. Now 3 years has passed since 2010 (the time this blog post was written). Are we there yet?

<DT><A HREF="http://objectcommando.com/blog/2010/06/10/clojure-futures/" ADD_DATE="1362479013" PRIVATE="0" TOREAD="0" TAGS="clojure,future,delay,concurrency,threads,java">Clojure Futures | Object Commando</A>
<DD>I already introduced Clojure &quot;delays&quot; last week. One main difference between the two concurrent construct is that delay executes their body only when lazily evaluated while futures go executing their stuff as soon as you create them. Futures are basically the Clojure alternative to java native threads, which includes creation of the Runnable and invocation of the run() method but with much more syntactic sugar and features. Futures are a good fit to start some expensive computation while the main thread can detach and do something else. Futures supports a timeout on deref (deref (future...) 1000 :toolong) will print :toolong if the future takes more than 1 second. A difference between a future and a native thread is that futures come from a thread pool which is shared with other potentially blocking actions. You don't get the thread pool by default with native threading in Java.

<DT><A HREF="http://stackoverflow.com/questions/4641964/how-to-use-update-in-in-clojure" ADD_DATE="1362478418" PRIVATE="0" TOREAD="0" TAGS="udpate-in,stdlib,clojure,map,idiomatic">How to use &quot;Update-in&quot; in Clojure? - Stack Overflow</A>
<DD>As many other Clojure standard library functions, update-in was specifically designed to update nested values in a map. Please note the important fact: sometimes by looking at Clojure doc documentation for a function is difficult to understand why it's there and how to use it. This is often because the function is missing the important information about which problem was trying to solve to begin with. The StackOverflow answers exactly the context of update-in usage. Without update-in you need to to read access the map, create the new value, store back into the map. Update-in is the more idiomatic way to do the same operation.

<DT><A HREF="https://bitbucket.org/kotarak/clojurecheck" ADD_DATE="1362473864" PRIVATE="0" TOREAD="0" TAGS="clojure,haskell,test,tdd,property,generative">kotarak / ClojureCheck — Bitbucket</A>
<DD>QuickCheck is a form of generative test framework written in Haskell. QuickCheck works by identifying &quot;properties&quot; which are roughly equivalent to rules governing a feature. So if the feature is called &quot;inverse&quot; and given a list it returns the same list in the opposite order, one fact that is that the (inverse (inverse list)) gives the initial input list. QuickCheck let's you define this property as a function and then it generates random list to verify if the property always holds true. Properties nicely describes a feature illustrating few important facts (or specifications, or scenario). I'm using the term scenario to capture the affinity between QuickCheck properties and Cucumber scenarios. ClojureCheck is a small library implementing QuickCheck concepts for Clojure. The property is expressed in terms of a few variables and their domains and ClojureCheck runs the property several time randomly choosing values from the allowed ranges.

<DT><A HREF="http://mythz.servicestack.net/blog/2013/02/27/the-deep-insights-of-alan-kay/" ADD_DATE="1362047557" PRIVATE="0" TOREAD="0" TAGS="clojure,lisp,smalltalk,kay,oop">The Deep Insights of Alan Kay - mythz blog</A>
<DD>A great collage of excerpts from several papers from Alan Kay, inventor of SmallTalk (one of the best interpretation of OOP so far) and many other &quot;concepts&quot; that ended up in commercial applications. Alan Kay has a deep respect for LISP. In his opinion, the millions LOC necessary for an application like a word processor or a spreadsheet are necessarily a complexity problem that got out of hand. &quot;The web is a joke&quot; compared to TCP/IP, a 20k LOC software that is powering communication between millions of computers today. LISP (in the broader sense of &quot;lispy&quot; languages) handles complexity through expressiveness and conciseness and along with SmallTalk is one of the best languages to implement messaging. A quick personal note: there are countless examples in nature of systems governed by few simple rules that can generate almost infinite complexity: cellular automata, fractals, DNA. It seems that we are still missing that kind of revolution in programming languages.

<DT><A HREF="http://clojuredocs.org/clojure_core/clojure.core/delay" ADD_DATE="1361983157" PRIVATE="0" TOREAD="0" TAGS="clojure,stdlib,delay,threads,cache">ClojureDocs - clojure.core/delay</A>
<DD>A Delay is a construct that encapsulates a function handler that is evaluated only when dereferenced (either with deref, @ or force). It will run only once and if dereferenced multiple times it won't run again. That's because the result will be cached if cacheable, and returned instantly the next time it is dereferenced. Multiple threads will all block waiting for the delay to realize, implementing the behaviour of a mutex. An example of usage of a delay could be to prevent expensive operations to realise until they are actually needed. Let's take an hash containing metadata about a website including the :body attribute for example. If clients do not require the entire page body they can just use the rest of the metadata (like title, mime-type and so on) without ever realizing the http get. If a client wants it, it will be blocked for the network call. All other clients will received the cached version.

<DT><A HREF="http://www.flyingmachinestudios.com/programming/datomic-for-five-year-olds/" ADD_DATE="1361906957" PRIVATE="0" TOREAD="0" TAGS="clojure,datomic,comparison,easy">Datomic for Five Year Olds</A>
<DD>Enjoyable and easy introduction to Datomic concepts. There are comparison tables for relational databases, nosql and datomic, highlighting their differences and strength. Datomic is revolutionary in the sense that brings together concepts that aren't new but were never assembled together in this way. Peer computing, time series, datalog aren't new concept but the way Datomic mix them together make them a powerful abstraction.

<DT><A HREF="http://sdjournal.org/closer-to-clojure/" ADD_DATE="1361906742" PRIVATE="0" TOREAD="0" TAGS="clojure,reducers,sdj,sdjournal,article,teaser">Closer to Clojure – read the teaser now! | News | Magazine for software developers, programmers and designers - Software Developer's Journal</A>
<DD>Sorry for the shameless self promotion here, but I think it's good news. The next SD journal will be entirely dedicated to Clojure. The issue includes an article from yours truly about Reducers. I think I've done my best to explain why they are there, what are their limitations, when you want to use them. You need to pay for the whole number, but the teaser is available for free with a quick registration. Let me know your feedback!

<DT><A HREF="http://blog.zololabs.com/2013/02/22/to-write-tests-or-to-not-write-tests/" ADD_DATE="1361570208" PRIVATE="0" TOREAD="0" TAGS="clojure,test,tdd,testing,banging,guardrail">To write tests or to not write tests… | Zolo Labs</A>
<DD>There some sort argument against TDD in the Clojure community. It seems to boil down to the fact that Rich Hickey doesn't like to test *first* (I saw &quot;main&quot; methods in Clojure sources that confirm he kind of tests after). I also have trouble connecting the &quot;banging into guardrails&quot; argument to TDD. When I write a test first, the test is &quot;banging&quot; but the code it produces is not. It would be the other way around instead if I created the test after: my code would immediately &quot;bang&quot;, the test would verify the banging and the fix would bring the car back into the centre of the street. So as usual for the arguments against TDD, it is always a preference not a rule. There are people who likes to think throughout first and are good at that and there are people like me that struggle to grasp a complex problem with a single look. In any case, I never seen TDD harming in my experience.

<DT><A HREF="https://github.com/cemerick/pomegranate" ADD_DATE="1361302607" PRIVATE="0" TOREAD="0" TAGS="clojure,pomegranate,dependencies,maven,leiningen">cemerick/pomegranate · GitHub</A>
<DD>Pomegranate is a Clojure wrapper on top of eclipse.org/aether, a library for dynamic manipulation of project dependencies. Uhm, why should I need that? Well, if you want to add a dependency to your project and then use some library in your code, the responsibility is split into a pom.xml/project.clj that is resolved at build time and an import into your Java runtime. The real question is why you should have a piece of XML or a special Clojure file at build time to deal with. All that is needed is some mechanism to programatically declare coordinates about the dependencies (which now lives in your code, exactly where it's needed, can be tested and read as documentation). Aether provide that mechanism and Clojure makes it possible with Pomegranate. The only downside I see is the &quot;warm-up&quot; time needed for your app to be sure dependencies are downloaded locally from some remote repository. If can deal with that in several ways, like preloading dependencies before real run.

<DT><A HREF="https://github.com/xmonad/osxmonad" ADD_DATE="1361301924" PRIVATE="0" TOREAD="0" TAGS="clocjure,fp,complex,haskell,monad">xmonad/osxmonad · GitHub</A>
<DD>Sorry, this could be slightly tangential to Clojure. You might have heard of XMonad, a X-Window manager for unix written in Haskell. The main design of XMonad is to make window management from the keyboard possible. The source code of XMonad is strikingly short for the features it provides and it demonstrate what happens when a complex system is written in a functional language. If you have a Mac you can now enjoy the power of the XMonad manager on your machine with this port hosted on GitHub.

<DT><A HREF="http://news.ycombinator.com/item?id=5239673" ADD_DATE="1361301573" PRIVATE="0" TOREAD="0" TAGS="clojure,arc,hackernews,debug,live,REPL">Why HN was down | Hacker News</A>
<DD>With great power comes great responsibility! HackerNews is not written in Clojure, is written in a dialect of LISP called ARC that Paul Graham invented. It shares with Clojure the same philosophy and it contains of course a REPL. When you can access a live system and such an easy way, you should always remember what can happen in case of errors, like this short story about hacker news being down. With other less powerful compiled languages you don't get a REPL and for this reason you're less tempted to do surgery on the live system, hopefully catching problems by doing some local testing first.

<DT><A HREF="http://blog.fogus.me/2013/01/21/enfield-a-programming-language-designed-for-pedagogy/" ADD_DATE="1360731032" PRIVATE="0" TOREAD="0" TAGS="clojure,scheme,languages,teaching,funny,racket">fogus: Enfield: a programming language designed for pedagogy</A>
<DD>What if, designing a brand new language with all the features you always dreamed of, you came up with something very similar to Racket (aka Scheme)? The news should not surprise you that much since what came up from language research in the '60 seems to be unbeatable event with today's computer power. This is fun reading. Enjoy the list of features that a language like Scheme can offer right now, in which way it can mimic other paradigms or add static types. Racket is precisely what I'm using while exercising SICP, after a quick glance at the MIT Scheme I was able to be up and running with Racket in a fraction of a second.

<DT><A HREF="http://vimeo.com/45561411" ADD_DATE="1360053819" PRIVATE="0" TOREAD="0" TAGS="clojure,reducers,fold,fp,pattern,video,talk,rich">Reducers - Rich Hickey on Vimeo</A>
<DD>Here's some hardcore stuff for well-rounded clojurian. Well, Reducers are coming in 1.5 (RC4 at the time of this writing) so you should know how you can use them and for which kind of problems as everything else in the standard library. Rich the-man is going to take you through reducers in this talk from Euroclojure. The content is certainly dense and some background material is recommended at the beginning. On the understandable side, Rich is giving code examples, from the basic form of a reducing transformer to its final form. It is highly recommended you fire up a REPL and follow along, or even better, stop and create a sample project. Reducers are essentially a trick, a combination of reduce over map (or filter) where the mapping operations can be accumulated until reduce will eventually realise. The trick has the nice side effect to remove ordering from standard map operations, making them parallelizable. The new fold function based on reducers doesn't use any parallel-map or parallel-collection specific stuff, an object oriented aberration. Reducers without the fold context aren't that different from monads or combinators: they are functional patterns. Somebody should write a book about it.

<DT><A HREF="http://clojuredocs.org/clojure_core/clojure.core/mapcat" ADD_DATE="1360052755" PRIVATE="0" TOREAD="0" TAGS="clojure,stdlib,map,concat,mapcat">ClojureDocs - clojure.core/mapcat</A>
<DD>Mapcat is somehow an useful shortcut. It is mostly used whenever a map operation returns a collection of collections. This happens when the f passed to map is returning a collection of some sort. To flatten that nested collections, you could use concat over map returned list like (apply concat [[1], [2]]). Or just enter mapcat that does the same thing for you. By using mapcat you agree that the mapping function passed to map is returning collection instead of scalars, otherwise the mapcat operation will just fail.

<DT><A HREF="http://clojure.org/sequences" ADD_DATE="1359913470" PRIVATE="0" TOREAD="0" TAGS="clojure,sequence,collection,iseq,laziness,lazy">Clojure - sequences</A>
<DD>This is one of the those topics somebody looking at Clojure for the first time will probably come across. Sequences are an abstraction on collections which contains their notion of ordering in terms of what is &quot;first&quot; and what comes &quot;next&quot;. You can &quot;first&quot; on a sequence, you can &quot;rest&quot; to access everything after the first element or you can &quot;cons&quot; an item and a sequence to create a new (cell) sequence. There is a reason why they are particularly important: Clojure laziness is build on top of them. Almost all sequences (collections that are seq-able) are also lazy which basically boils down to the way &quot;rest&quot; is implemented: it returns a function which is a recipe on how to realise the rest of the collection instead of a concrete collection.

<DT><A HREF="http://agiletoolkit.libsyn.com/agile-2011-arlo-belshee-extreme-programming-agile-engineering-big-data-and-other-disruptive-behaviors" ADD_DATE="1359468496" PRIVATE="0" TOREAD="0" TAGS="clojure,midje,mocking,oop,fp,tdd,state,marick">Agile Toolkit Podcast - Arlo Belshee</A>
<DD>I've found an interesting take of Arlo Belshee about Midje mocks in this episode of the Agile Toolkit Podcast. It is toward the end, but the podcast is short, I suggest you to listen to the whole thing especially if you don't know Arlo. For state based paradigms like OOP state is what behaviour gravitate around. When mocks are used in OOP you are mostly mocking state, so that you can test the behaviour given a particoular context. But with functional programming, state is spread everywhere and in a sense it is state that is sent around to be handled by behaviour. Arlo doesn't like mocking in OOP preferring state based testing in the Kent Beck sense for this reason, because mocking breaks the design flow. But mocking in FP is really about behaviour: injecting new behaviour to verify how state changes, exactly like state based testing in OOP. This is why Arlo likes it.

<DT><A HREF="http://cafe.elharo.com/programming/java-programming/why-functional-programming-in-java-is-dangerous/" ADD_DATE="1359383469" PRIVATE="0" TOREAD="0" TAGS="clojure,java,paradigms,functional,stackoverflow,lazy">The Cafes » Why Functional Programming in Java is Dangerous</A>
<DD>This short post is about what happens when you blindly apply idioms from one paradigm into another programming language which is based on another paradigm. In this example, Clojure lazy structures into Java. I think the point here is that it's not possible for a language designed for a paradigm to be flexible enough to accept idioms from other paradigms. There are of course hybrid languages like Scala which are designed for that, but definitely this is not the case for Java and in general non-tail recursive compilers that blows up the stack on recursion if you don't pay attention. Anyway, funny reading and comments.

<DT><A HREF="http://clojuredocs.org/clojure_contrib/clojure.contrib.def/defnk" ADD_DATE="1358847040" PRIVATE="0" TOREAD="0" TAGS="clojure,stdlib,defnk,map,parameters">ClojureDocs - clojure.contrib.def/defnk</A>
<DD>There used to be a defnk macro once in Clojure contrib and apparently was never ported to the new contrib modular structure. Plain Clojure already supports destructuring of parameters into key value pairs in function declaration, allowing to invoke a function with a map of key values that &quot;names&quot; each parameter. It is optional, but sometimes naming parameter can be useful to ease the reading of a function. This little macro is basically avoiding the repetition that happens when the key and the value have the same name. Instead of repeating that twice, this is assumed to be true by default. As a comment to this ycombinator thread says http://news.ycombinator.com/item?id=4641465 it is maybe a good idea to bring defnk back, since many projects make good use of it.

<DT><A HREF="http://www.infoq.com/presentations/Clojure-FP" ADD_DATE="1358844890" PRIVATE="0" TOREAD="0" TAGS="clojure,video,talk,comparison,scala,python,experience">Lessons from Functional Programming in Five Languages</A>
<DD>Robert Rees founded a couple of successful startups as a &quot;techie&quot; and played around many languages already. This is his interesting take on why everything in languages he likes seems to converge to Clojure that he defines as a &quot;framework for critical thinking&quot;. Many people approaching clojure have a similar discovery path: Clojure is the language that puts clarity in programming concepts and allow application to evolve to the next level of complexity. There are a few interesting takes on Scala (Robert is now working at the Guardian, a Scala shop) and Python comprehensions, his former language at Wazoku.

<DT><A HREF="http://stackoverflow.com/questions/4725417/difference-between-doseq-and-for-in-clojure" ADD_DATE="1358843633" PRIVATE="0" TOREAD="0" TAGS="clojure,doseq,sequence,loop,for,effects,stdlib">Difference between doseq and for in Clojure - Stack Overflow</A>
<DD>Speaking of the behaviour of doseq, I like this description from Stackoverflow. Doseq is looping macro with the specific idea of producing side effects. This is enforced by the fact that as expression it is not returning anything. Compare that with a &quot;for&quot; macro, which is building a result to return instead. The &quot;effect&quot; of the for loop is intended to happen outside the loop, while with doseq some side effect is expected. Clojure was never designed to be side effect free, but to allow controlled and distinct constructs for side effects. This is one of the many example from the standard lib.

<DT><A HREF="http://blog.fogus.me/2013/01/06/pesto5-a-concatenative-programming-library-in-5-lines-of-clojure/" ADD_DATE="1358792096" PRIVATE="0" TOREAD="0" TAGS="clojure,concatenative,forth,stack,elegant">fogus: pesto5: A concatenative programming library in 5 lines of Clojure</A>
<DD>This little five liner has a few interesting properties. It implements a simple concatenative language on top of Clojure, that is a language that operates on a list of operands and operators by placing them on an implicit stack where operations are performed just by going through the list left to right. For example (1 2 3) creates a &quot;stack&quot; and returns it like [1 2 3]. (1 2 +) returns the stack [3] where 1 was pushed, 2 was pushed, and + was used as binary operator on the two operands on the stack. It's amazing the amount of Clojure needed to obtain quite a complicated behaviour. As simple as it seems, there are languages based on the use of an implicit stack like Forth!

<DT><A HREF="https://github.com/brandonbloom/fipp" ADD_DATE="1358186343" PRIVATE="0" TOREAD="0" TAGS="clojure,tools,pprint,reducers">brandonbloom/fipp · GitHub</A>
<DD>A quick note on this pretty printer. The problem of pretty printing sounds simple at first. But this little utility implements a fast algorithm backed by a few research papers nonetheless. Reducers are required, so you need to use Clojure 1.5-RC1 and in case you are not using the JDK 1.7 you also need to add the jar for the jsr-166 implementation (with [org.codehaus.jsr166-mirror/jsr166y &quot;1.7.0&quot;]). It also provides a nice idiomatic API to write your own pretty printing, with grouping and indentation.

<DT><A HREF="http://clojurewise.blogspot.co.uk/2010/03/using-ctags-with-clojure.html" ADD_DATE="1357923385" PRIVATE="0" TOREAD="0" TAGS="clojure,vim,ctags,editor,navigation">ClojureWise: Using ctags with Clojure</A>
<DD>Using Clojure from an ancient editor like emacs or vim? If you are using Ctags (you should) you can issue the following from the command line and start jumping around: ctags -R --langmap=Lisp:+.clj --sort=yes --exclude=.git --exclude=.svn --exclude=**/target *
This will create the tags file that vim or emacs can use to jump between definitions.

<DT><A HREF="http://www.youtube.com/user/ClojureTV" ADD_DATE="1357841821" PRIVATE="0" TOREAD="0" TAGS="clojure,video,presentations,talks,conference,tv">ClojureTV - YouTube</A>
<DD>Worth pointing out that since the glorious blipTV account was abruptly closed, the new source for Clojure presentations is now on youtube as ClojureTV. Tons of good material is here, including the Rich Hickey's playlist http://www.youtube.com/watch?v=f84n5oFoZBc&amp;list=PLZdCLR02grLrEwKaZv-5QbUzK0zGKOOcr and many other playlists to watch your favourite talks non-stop for hours!

<DT><A HREF="https://github.com/clojure/clojure/blob/master/changes.md" ADD_DATE="1357731814" PRIVATE="0" TOREAD="0" TAGS="clojure,threading,macro,operator,1.5,stdlib">clojure/changes.md Clojure 1.5 - new threading macros</A>
<DD>There are many changes in the new upcoming Clojure 1.5. I already examined reducers, this time I want to highlight the new macros built on top of the old -&gt; -&gt;&gt;. The new threading macros are cond-&gt;, as-&gt; and some-&gt; (with cousins using -&gt;&gt;). They all kind of alter the normal -&gt; flow. Cond-&gt; is altering it by placing a condition before each step of the threading. As-&gt; allows for an embedded new threading macro that takes the result so far and thread that result with a different name in a new sub-threaded flow. Some-&gt; checks for nil before moving on to the next step, and return nil if a any of the steps is returning nil (compare that with the basic -&gt; where the next step will be attempted with a nil as input sometimes with unexpected results). It is very complicated to explain the new threading macros in words, best if you fire up a 1.5 RC REPL and try your self a few example.

<DT><A HREF="http://blog.8thlight.com/uncle-bob/2013/01/07/FPBE3-Do-the-rules-change.html" ADD_DATE="1357727632" PRIVATE="0" TOREAD="0" TAGS="clojure,tdd,midje,paradigm,process,approach,unclebob">FP Basics E3 | 8th Light</A>
<DD>Uncle Bob is here to remember us that functional programming can be written test first exactly like any other programming style. The article also talks about the difference between a solution that applies a series of transofmrations instead of the first proposed solution that uses recursion instead. They are both purely functional but the series of transformation tends to be considered 'more' functional (and visually appearing as a series of nested invocations). They are just two different styles of approaching the same problem and they can be both tested first. Midje is probably the best tool to approach the series of transformations test first, since you can define unfinished functions with stubbed values and create their implementation later on.

<DT><A HREF="https://github.com/konrad-garus/cljs-kickoff" ADD_DATE="1357685215" PRIVATE="0" TOREAD="0" TAGS="clojure,clojurescript,template,leiningen">konrad-garus/cljs-kickoff · GitHub</A>
<DD>cljs-kickoff is a leiningen template to create a development ready clojurescript project. It's probably one of the quickest ways to start experimenting with clojurescript without too much time spent setting up the required libraries and folder structure. It also support an auto compilation mode to see the changes on browser refresh. Leiningen templates are fetched on first use, so the template doesn't require installation.

<DT><A HREF="http://clojuredocs.org/clojure_core/clojure.core/juxt" ADD_DATE="1357683644" PRIVATE="0" TOREAD="0" TAGS="clojure,stdlib,tools,map">ClojureDocs - clojure.core/juxt</A>
<DD>juxt is a simple idea. It takes a list of functions and a parameter and outputs the list of results of applying each function to the parameter. Juxt is useful when you need to do multiple things to the same argument or collection. One common case is the creation of maps starting from a collection. You can pass a function to create the key, one for the value e the starting collection.

<DT><A HREF="https://github.com/bodil/catnip" ADD_DATE="1357565642" PRIVATE="0" TOREAD="0" TAGS="clojure,clojurescript,editor,learning,browser">bodil/catnip · GitHub</A>
<DD>Catnip is an useful Clojure quick start environment in a browser. After you 'lein edit' into the newly created project you are able to edit, save and run tests all within the browser that is started automatically. I tested briefly in Safari without big problems, but Chrome is the preferred browser. It's fully featured, but I would probably not use it as my main environment. Definitely useful for all those quick example and setup where you don't want to waste time setting up emacs, vim or another editor but being able to quickly program some Clojure, for example while learning. If you are into ClojureScript Catnip can also compile cljs files on the fly and the embedded browser frame can show you the results right away.

<DT><A HREF="http://www.flyingmachinestudios.com/programming/the-unofficial-guide-to-rich-hickeys-brain/" ADD_DATE="1356214447" PRIVATE="0" TOREAD="0" TAGS="clojure,principles,design,state,value,identity,hickey">The Unofficial Guide to Rich Hickey's Brain</A>
<DD>The model of state, time and identity that Rich Hickey describes in his talks is what attracted me to Clojure in the first place. As the author says in this funny but profound article, &quot;the man&quot; has the power to put order in your mind. Clojure isn't just a functional language with a lispy syntax running on the JVM, it is more the implementation of a philosophy in a language. The principles behind Clojure are such that they make concurrent programming simple. I reckon that is not intuitive to describe the world around us as a stream of values identified by a label. For this reason I think we still need OOP. But the concept of time other than &quot;now&quot; has its role in programming and OO is not fulfilling the requirement. If all that sounds as a bunch of philosophy fluff, then go ahead and read this article which does a much better job explaining it.

<DT><A HREF="http://www.infoq.com/presentations/Storm" ADD_DATE="1356214379" PRIVATE="0" TOREAD="0" TAGS="clojure,storm,cascalog,video,strangeloop,parallel,analysis">Storm: Distributed and Fault-tolerant Real-time Computation</A>
<DD>Nathan Marz of Cascalog fame introduces the world to Storm, his last creation. Right in the middle of the presentation, Nathan opens up Storm sources on Github officially marking it open source. Storm is an Hadoop for real time computation. Built on top of the concept of stream of tuples, Storm allows to create logical workflows that execute in parallel on a phisical cluster. Storm is like the prolog of programming: you describe the steps of the computation and their order, how much parallelism you want and Storm makes sure to run the computation on a cluster.

<DT><A HREF="http://blog.8thlight.com/uncle-bob/2012/12/19/Three-Paradigms.html" ADD_DATE="1356113966" PRIVATE="0" TOREAD="0" TAGS="clojure,paradigm,functional,oo,fp,declarative,evolution,history">Three Paradigms | 8th Light</A>
<DD>Interesting take from Uncle Bob's about how language evolution seems to be restricting possibilities instead of allowing more. There was structured programming, a way to restrict random jumps between instruction enabled by the harmful GOTO. There was OO programming restricting visibility of pointers to allow polymorphism. Finally we had functional programming, removing assignment to prevent side effects. Many today think that declarative programming is the next step, removing the possibility to order a computer to perform instructions imperatively. Another interesting fact is that the above paradigm evolutions are all 40 years old and it seems that we stopped evolving right after. Is it true that there won't be another paradigm shift in computer programming?

<DT><A HREF="https://github.com/cgrand/enlive" ADD_DATE="1355934250" PRIVATE="0" TOREAD="0" TAGS="clojure,enlive,template,view,noir">cgrand/enlive · GitHub</A>
<DD>Enlive should be categorised as a template language but it works quite differently. With a template language you expect special tags intermingled with the target file for the transformation. Such as Velocity for HTML, or the Rails template language. The view file that will be served using Enlive inside of Noir for example, won't contain any special char. Enlive uses the same CSS principle nicely encapsulated in a DSL-ish Clojure language. So you will have a clojure view file that target a specific html file with matches on the HTML elements that describe the final transformation. The result is &quot;some&quot; html appearing in the clojure code as part of the matching engine but not in the sense of strings containing HTML that are concatenated. Enlive takes a bit to understand but the final solution is perhaps the finest in terms of view/controller logic isolation.

<DT><A HREF="http://www.youtube.com/playlist?list=PL5288D44FC6EA9A5E" ADD_DATE="1355854164" PRIVATE="0" TOREAD="0" TAGS="">Twitter's Storm, March 29, 2012 - YouTube</A>
<DD>WIP, probably delete.

<DT><A HREF="http://vimeo.com/19404746" ADD_DATE="1355643981" PRIVATE="0" TOREAD="0" TAGS="clojure,marick,robozzle,tdd,midje,screencast,video">Clojure TDD demo (Robozzle) on Vimeo</A>
<DD>I keep going back to this Marick's take on top-down TDD with Midje, which is a must see to download offline and practice constantly. This also happened recently when I was frustrated solving apparently simple functions. I'm very suspicious now if I feel a function is too complicated to solve. It should not happen. It's an hint that my functional decomposition is not working at the right level. Working like Brian in this screencast helps me maintaining the complexity low and think the algorithm in terms of nouns and verbs that then translate into other functions. I can't say if this is the best approach, what I know is that most of the time I don't have a real alternative. Starting at the bottom (describing the low level functions) feels too dispersive especially with FP (compared to OO).

<DT><A HREF="http://blog.raynes.me/blog/2012/12/13/moving-away-from-noir/" ADD_DATE="1355641825" PRIVATE="0" TOREAD="0" TAGS="clojure,noir,compojure,web,framework">Moving away from Noir - Noir Deprecated</A>
<DD>Noir is at the moment the framework of choice to create web applications in Clojure. So it must have been an hard decision for the author first and the actual maintainer to abandon it. The fact is, Noir won't be abandoned, it is just that Compojure is going to receive some re-newed love. I think it demonstrates maturity in the Clojure community: Noir was necessary at the time when to avoid to write a lot of boiler plate cod with Compojure alone, but Noir itself is not a lot more than a set of selected dependencies for ring/compojure. For this reason the actual project lead decided to split https://github.com/noir-clojure/lib-noir out of Noir, which is exactly that selection of libraries that you can now use on top of Compojure alone.

<DT><A HREF="https://github.com/clojure-liberator/liberator" ADD_DATE="1355641347" PRIVATE="0" TOREAD="0" TAGS="clojure,rest,compojure,datomic,services,framework">clojure-liberator/liberator · GitHub</A>
<DD>Liberator is a Compojure based framework to create REST services. It contains several abstractions to deal with resources and typical response handlers. Another key component of Liberator are &quot;decisions&quot; described as a way to limit or describe what a resource can do (like which http methods are accepted, which mime types and so on). It comes with an example project and some good recommendation (apparently it's powering Datomic REST APIs).

<DT><A HREF="https://github.com/nathanmarz/storm-deploy" ADD_DATE="1355640211" PRIVATE="0" TOREAD="0" TAGS="clojure,storm,aws,deploy,provisioning,automation,devops">nathanmarz/storm-deploy · GitHub</A>
<DD>Storm-deploy makes dead simple to deploy Storm clusters on Amazon services. It's based on Pallet, which is based on JClouds. A good example of layering of abstractions to achieve the desired result and also an example of the endless freedom to drive existent Java libraries from Clojure. Storm-deploy requires to set a couple of configuration files. It's actually more complicated to understand which AWS are required in the configuration file. If you get lost, this is a good guide: http://alestic.com/2009/11/ec2-credentials. Also, if you're already on Leiningen 2, you need to patch the project.clj to work correctly. There is a pull request for that, so in the meanwhile you can replace project.clj with the conent of https://github.com/travis/storm-deploy/blob/57247084bb69fe0e08db76b23d0e7c6bc30dc031/project.clj

<DT><A HREF="http://brehaut.net/blog/2012/clojure_web_and_the_crud_stack" ADD_DATE="1355394080" PRIVATE="0" TOREAD="0" TAGS="clojure,noir,compojure,web,rails">A Lazy Sequence: The Clojure web stack and the CRUD stack</A>
<DD>I don't necessarily agree that Clojure doesn't need an opinionated and convention-over-config web stack a-la Rails. Rails is also responsible for popularising Ruby and the entire Ruby ecosystem. Why the Clojure community wouldn't want something like that? I do agree that not having a Rails like web stack gives flexibility and brings modularisation in web development, but those are not strong enough reasons not to work toward a common web stack targeted at a specific class of applications. The reason this still needs to happen is that we haven't found our DHH yet.

<DT><A HREF="http://dosync.posterous.com/a-logic-programming-reading-list" ADD_DATE="1355133300" PRIVATE="0" TOREAD="0" TAGS="clojure,core.logic,prolog,declarative,started">A Logic Programming Reading List - dosync</A>
<DD>Instant bookmark for this getting started list of books and resources about logic programming from Ms core.logic in person. The Reasoned Schemer is certainly an important resource but it's not THE starting point. Sorry to disappoint you but to really understand core.logic the best starting point is the &quot;scary&quot; Prolog itself :)

<DT><A HREF="http://skillsmatter.com/event/scala/clojure-exchange-2012" ADD_DATE="1354897105" PRIVATE="0" TOREAD="0" TAGS="clojure,conference,video,exchange,hickey">Skills Matter : Clojure eXchange 2012 06-12-12</A>
<DD>Posting the Clojure Exchange page again, this time so you can access the videos that were taken during the conference and were posted online almost in real-time! Kudos to SkillsMatter for the great organizaton of this event. I attended and learned a lot. I think the talk liked the most (after Rich Hickey at the end) was the one about persistent data structures, very well explained by Philip Potter. Rich instead gave a lightning talk about Java interop with Shims (http://en.wikipedia.org/wiki/Shim_(computing)) and the longer closing keynote about the language of the system. In essence, the language of the system are the missing pieces that coordinates the communication between different processes orchestrating an entire application. Several good architectural takeaways: use queues when possible, code for failure a-la-erlang, think your application as data through a pipeline.

<DT><A HREF="https://github.com/edn-format/edn/wiki/Implementations" ADD_DATE="1354895686" PRIVATE="0" TOREAD="0" TAGS="clojure,edn,json,timestamp,format,transport">Implementations · edn-format/edn Wiki</A>
<DD>EDN or Extensible Data Notation is the equivalent of JSON for Clojure. Well, a little more. Is still a simple readable text-based format, but it adds semantic for the most common data to transport over the wire. For example: how a timestamp should be encoded in JSON? Unfortunately there are many ways (http://markembling.info/2011/07/json-date-time). EDN solves this and similar problems with tags: a tag denoted with a word prefixed with '#' ads semantic to the following value. So an instant in time will be always a #inst &quot;rfc-3339-format&quot;. A plus for clojure application is of course that EDN is very similar to clojure and can be easily evaluated. There are already implementation written for many languages, ruby, python, java, C to name a few.

<DT><A HREF="https://github.com/malcolmsparks/ciao" ADD_DATE="1354817216" PRIVATE="0" TOREAD="0" TAGS="clojure,logic,corelogic,prolog,declarative">malcolmsparks/ciao · GitHub</A>
<DD>Here's a nice example of usage of core.logic to translate/recognize the italian language. A spoken language (once many of the inevitable exceptions are eliminated) can be summarized as a set of rules and those rules can be expressed with core.logic. The example project can be used both ways (as usual with prolog-like languages): you can have the example check for correct grammar or have the project suggest what to use in a certain context.

<DT><A HREF="http://richhickey.github.com/clojure/clojure.walk-api.html" ADD_DATE="1354815795" PRIVATE="0" TOREAD="0" TAGS="clojure,tree,walk,algorithms,stdlib">clojure.walk API reference (Clojure)</A>
<DD>The &quot;walk familiy&quot; for clojure is a set of functions dedicated to traverse trees. The core function is walk but that is not used directly. postwalk and prewalk is what you get to use most of the time (plus variants). Traversing trees is done on almost all sequences. Traversal is recursively going down branches. The post version visits the root of a new nested branch after visiting the enclosing leaves, while pre-walking does that before the leaves. Important thing to take into consideration is exactly that: while traversing, the function you provide is presented with elements that sometimes are collections (branching point) sometimes are simple elements.

<DT><A HREF="http://storm.twitsprout.com/" ADD_DATE="1354663363" PRIVATE="0" TOREAD="0" TAGS="storm,mapreduce,realtime,cascading,screencast,video">Taking the Emmys by Storm</A>
<DD>Interesting run through Storm using the Java api. Storm is a real-time analysis framework to deal with high request/sec rates. Conceptually storm is a chain of steps separated by queues where the topology and level of concurrency can be easily configured. It runs on top of ZooKeeper (for orchestration on a cluster) and uses zeroMQ for queues. Best of all the core of Storm is Clojure (and what else we should expect from Nathan Martz of Cascalog memories?). Storm is the kind of product you may want to use to analyse data that come in quick bursts of very high request per second rates.

<DT><A HREF="http://stackoverflow.com/questions/5082850/whats-the-convention-for-using-an-asterisk-at-the-end-of-a-function-name-in-clo" ADD_DATE="1354644011" PRIVATE="0" TOREAD="0" TAGS="clojure,naming,convention,star,asterisk">coding style - What's the convention for using an asterisk at the end of a function name in Clojure and other Lisp dialects? - Stack Overflow</A>
<DD>Sometimes in Clojure you'll see stars appearing around names of functions or variables. Those are conventions, since is totally fine for a name to contain stars. For the specific case of post-fix star, it means there is an inner function or form, possibly private, that is not meant for direct use. That second function name appears for example in macro expansions and just tell us that the existence of a public wrapper over a private function (and the developer without too much creativity for names). Pre and post-fix stars on a name are local threaded variables, a controlled side-effect in Clojure that is allowed but only in specific cases.

<DT><A HREF="http://www.cs.bu.edu/teaching/cs112/spring-2000/breadth-first/" ADD_DATE="1354615411" PRIVATE="0" TOREAD="0" TAGS="clojure,tree,traversal,algorithm,evaluation,lazy">Breadth-First Traversal of a Tree</A>
<DD>A very well discussed topic in computer science is how to represent algorithms as tree traversal operations. One good case of such a need is in compiler design and the applicative VS normal evaluation order of SICP heritage comes into mind. Breadth first is in opposition to the more natural branch first way of traversing a tree, where you go down searching for leaves top to bottom, left to right. Instead of searching for leaves right away breadth first advocates you accumulate on the tree level by level, top down, without realizing leaves until the end. What clearly distinguish the two walking strategies is when realization of leaves should happen. If you attach to 'realization' the evaluation of function then you can understand that all of this is mapping to evaluation strategies and at the end compiler optimization. I like this article for its simplicity and the clear way it attacks the question why should I need one or the other with examples.

<DT><A HREF="http://confreaks.com/videos/1287-rubyconf2012-y-not-adventures-in-functional-programming" ADD_DATE="1354614960" PRIVATE="0" TOREAD="0" TAGS="clojure,video,talk,tennent,lambda,calculus,church,weirich">Y Not -- Adventures in Functional Programming - Jim Weirich - Ruby Conference 2012</A>
<DD>Alright, I'm about to enter this talk into my personal hall-of-fame. Not only Jim was able to refactor a recursive factorial into the related z-combinator form, but he also explained the refactoring steps used (and re-usable in other contexts), church numerals and all the other functional concepts needed to understand combinators. As he said at the end, the amazing fact about combinators is that in real life you won't feel the need to use one of them (unless you're programming in lambda calculus directly) but completely understanding them means to understand  95% of FP. He was able to touch on everything: lambda calculus, church numerals, the beta reduction process, the meaning of fixed point for a function, Tennent's Correspondence Principle, free variables, introduce binding. Something to watch 5 secs at a time, being sure to completely understand what's involved.

<DT><A HREF="http://clojuredocs.org/clojure_core/clojure.core/interleave" ADD_DATE="1354610634" PRIVATE="0" TOREAD="0" TAGS="clojure,stdlib,map,zipmap,tools,utils">ClojureDocs - clojure.core/interleave</A>
<DD>Here's another cool one from the standard library. Interleave is useful in all those situation where an horizontal structure should be transformed to a vertical structure. Yeah, exactly like that, you need to think spatially, how things layout on paper. Say you organized some partial result into a structure that maps keys into list of values and you need to pick the first item in each list and don't care about the rest. Pick the first item in the list is visually like connecting each first item in the horizontally layout map, actually drawing a vertical line. Interleave can also be used successfully to create maps out of list. It's so useful for that reason that there is a shortcut companion function called zipmap.

<DT><A HREF="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/disj" ADD_DATE="1354607724" PRIVATE="0" TOREAD="0" TAGS="clojure,stdlib,core,set,duplicates">clojure.core - disj</A>
<DD>Disj is this little function that lives with other set functions in the standard library (union and intersection for example). Disj is useful if you have a set of items and a list of keys you don't want in that set. It could be renamed something like remove-from-set in this case, with the following result: (disj #{1 2 3 4} 1 2) =&gt; #{3 4} Disj can be helpful in problems like removing duplicates of something in a list. First create the set of duplicate keys, then subtract them from the originating set.

<DT><A HREF="http://en.wikipedia.org/wiki/Church_numeral" ADD_DATE="1354003849" PRIVATE="0" TOREAD="0" TAGS="clojure,lambda,calculus,church,numerals,fp">Church encoding - Wikipedia, the free encyclopedia</A>
<DD>I'm still amazed by the fact that a language can be made of just anonymous functions. Church numerals defines how to encode numbers (and other primitive types of other languages) into high order function invocations. Counting becomes a matter of how many times a function is invoked over an argument. So λf.λx. f x can be read as the definition of a function that takes two arguments, f and x (the dot is the separation between them) and invokes f on x. We don't care about the name of the function as well we don't care about what happens when f is invoked on x. We care about how many times this is done and we can do all sort of calculations without ever invoking those functions.

<DT><A HREF="http://blog.8thlight.com/myles-megyesi/2012/04/26/polymorphism-in-clojure.html" ADD_DATE="1353968389" PRIVATE="0" TOREAD="0" TAGS="clojure,protocols,multimethods,deftype,extend-protocol">Polymorphism in Clojure | 8th Light</A>
<DD>Nice writeup of possible ways to implement polymorphic behaviour in Clojure. The truth comes at the end in the form of high order function: by passing in the behaviour you achieve the same effect as polymorphism, that is, not changing the calling function when new behaviour needs to be added. The rest of the blog is spent describing ways to mimic object orientation: multimethods, derive, protocol, deftype. It's still useful to handle group of polymorphic functions through protocols, since it makes clear the intent of the group of functions to work on the same data types. The extend-protocol type is used in this example to provide a to-json serialization to all clojure main type.

<DT><A HREF="http://vimeo.com/45130708" ADD_DATE="1353966368" PRIVATE="0" TOREAD="0" TAGS="clojure,experience,bank,report,video,euroclojure">Total Massacre: Reducing the Middle Office - Jon Pither, Håkan Råberg on Vimeo</A>
<DD>Reporting again on Jon Pither and team. This talk actually came before the series of article about clojure at a bank (the last one being http://www.pitheringabout.com/?p=778) I already linked here. The introduction of Clojure at this huge and legacy project at UBS has been done incrementally, starting with apparently innocuous replacement of feature and expanding inside out. The target was a text based rule engine that was creating waste and problems. The optimal target, a fairly isolated sub-system and a functional problem in nature. Then the standalone reporting app with Noir and friends, then Clojure concurrency for back-office re-conciliation and so on. They also prepared for the usual questions: why we shouldn't do that in Java, or is Emacs really necessary. The reason for success to me always look the same: 3-5 devs accept the Clojure challenge and start hacking with it. If they are good and believe in what they do there is no way to stop them.

<DT><A HREF="http://stackoverflow.com/questions/3249334/test-whether-a-list-contains-a-specific-value-in-clojure" ADD_DATE="1353954647" PRIVATE="0" TOREAD="0" TAGS="clojure,contains?,vector,search,library,standard">data structures - Test whether a list contains a specific value in Clojure - Stack Overflow</A>
<DD>It happened to me twice already and more are expected in the future, so let's see if I can remember with this note. The temptation to ask if a vector contains some elements is really too strong hence my surprise when the REPL replies FALSE when I ask (contains? [&quot;a1&quot; &quot;a2&quot;] &quot;a2&quot;). Yeah yeah, the (doc contains?) says it all. But why a standard library full of perls like the Clojure one doesn't contain a method to say if an element is contained in a vector? This stack overflow article summarise my frustration and also give a similar solution to the one I've found myself, that is either use 'some' or 'filter' with an anonymous function.

<DT><A HREF="http://blog.jayfields.com/2010/07/clojure-destructuring.html" ADD_DATE="1353437621" PRIVATE="0" TOREAD="0" TAGS="clojure,destructuring,assignment,let">Jay Fields' Thoughts: Clojure: Destructuring</A>
<DD>It is often referred to clojure destructuring as one of the many mini-language clojure has. Simply put destructuring allows implicit access to a collection, vector or map, to bind its single elements to local definitions. You'll find destructuring used with let form or with function parameters (which are simply a vector). The assignment is positional: based on the position of the required variables to be assigned, destructuring will attempt matching your request in order. It also works for collections of collections and when used consistently removes a lot of boiler plate code. In this article, Jay Fields does a great job explaining how simple that is. The Clojure Programming book also has a few examples about destructring at page 38.

<DT><A HREF="http://stackoverflow.com/questions/2410082/clojure-type-conversion-string-to-symbol" ADD_DATE="1353172966" PRIVATE="0" TOREAD="0" TAGS="clojure,invoke,symbol,resolve,eval">clojure type conversion string to symbol - Stack Overflow</A>
<DD>Every now and then you'll need a way to invoke functions given the function name as string instead of just typing the symbol in parenthesis for the actual invocation. You just need a combination of (symbol) and (resolve) to achieve the desired effect. So say you have a string &quot;println&quot; and you want to invoke the related clojure function: ((resolve (symbol &quot;println&quot;)) &quot;foo&quot;) is what you need!

<DT><A HREF="https://github.com/marick/Midje/wiki/Checkers-for-collections-and-strings" ADD_DATE="1353150023" PRIVATE="0" TOREAD="0" TAGS="clojure,midje,matchers,collection">Checkers for collections and strings · marick/Midje Wiki</A>
<DD>Midje is today a full-fledged feature rich test framework for clojure. I remember that when Brian Marick started the project, Midje was about experimenting with top-down BDD development in Clojure with just the basic features. Thanks to all the love received by the many contributors to the project, today Midje is mature and deserve to dig deeper into the wiki to find how it can make your life easier. This week I want to highlight collection matchers. There is everything you need to do collection matching on outputs and the documentation is organized by collection type.

<DT><A HREF="https://github.com/flatland/drip" ADD_DATE="1353149709" PRIVATE="0" TOREAD="0" TAGS="clojure,jvm,launcher,nailgun,lein">flatland/drip</A>
<DD>Drip is yet another JVM launcher but the difference with nailgun is that drip doesn't try to re-use the same JVM over and over. Drip creates a JVM based on invocation arguments and only in that case it uses it multiple times. You can see how many JVMs are active with drip ps and you can kill one by drip kill. You don't need to kill JVMs your self, drip will automatically dismiss unused JVMs after a timeout. Unfortunately, it still doesn't work properly with leiningen (that uses a specific trampoline configuration each time it is invoked) so you won't notice any performance boost. But for any other Clojure (and JRuby or Java) use you'll see the JVM startup time disappearing after first use. Cool.

<DT><A HREF="http://www.infoq.com/research/functional-language-obstacles" ADD_DATE="1352938268" PRIVATE="0" TOREAD="0" TAGS="clojure,adoption,learning,corporate">Why Are You Not Using Functional Languages?</A>
<DD>A good thread on InfoQ. It starts as a poll but the comments are worth reading because they describe why FP adoption is problematic and a few &quot;guerrilla tactics&quot; to easy the learning curve for strongly OO environments. I'm more and more convinced that FP adoption is mainly a people problem, not a corporate or technological problem. The team in its majority should be relatively happy to be challenged with the adoption of a new paradigm, that is, the team should accept the pain of switching paradigm as a mean to acquire new knowledge. Once again it's all about courage and will power.

<DT><A HREF="http://www.infoq.com/articles/java-8-vs-scala" ADD_DATE="1352937283" PRIVATE="0" TOREAD="0" TAGS="scala,java8,traits,virtual">Java 8 vs Scala: a Feature Comparison</A>
<DD>This infoQ article does a good job at comparing how the new Java 8 features compare to Scala when it comes to make a good use of high order functions. Java 8 does a decent job with list comprehension, while it becomes a little more problematic to solve the problem of wrapping functions around existing behaviour (like the Logger Traits example). In this case Java is missing a way for the inherited trait to access to the instance of the implementing class.

<DT><A HREF="http://www.pitheringabout.com/?p=749" ADD_DATE="1352729713" PRIVATE="0" TOREAD="0" TAGS="clojure,experience,report,bank,team,adoption">Pithering About » Clojure at a Bank – Support</A>
<DD>Another chapter of the Clojure at a Bank saga, an experience report that is really worth reading. Jon Pither is doing a great job at describing what went well and what went not so well. I think again the main takeaway is that when almost the entire team decides to take some technical directions, there are very few things to stop them doing the right job. I like the idea of the POD, a restricted part of the project that you can opt in or out gradually, when you feel ready. Another thing that you need to succeed is freedom from operational constraints, that is, the need to use certain libraries or a certain application server. You can clearly work around it, but it just makes life more complicated. Still in awe of what they've done at that bank, hope I can reproduce something similar at my current job. Working on that direction :)

<DT><A HREF="http://richhickey.github.com/clojure/clojure.core-api.html#clojure.core/re-seq" ADD_DATE="1352711952" PRIVATE="0" TOREAD="0" TAGS="clojure,library,regexp,matching">clojure.core API reference re-seq</A>
<DD>Moving on with the series of standard library functions you may want to know, here is re-seq. RE stands for RegExp and this little function is incredibily useful for pattern matching on strings. Given a regexp in the form of a string and a string returns all the pattern matchers as a sequence. It's a very useful for of iteration on top of regexp matches, like all zip codes in a list, all words starting with capital in a list, and so on. As usual give it a little go on the REPL or online here http://tryclj.com

<DT><A HREF="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/seq" ADD_DATE="1352710438" PRIVATE="0" TOREAD="0" TAGS="clojure,seq,sequence,empty,library">clojure.core - seq</A>
<DD>'seq' is a function that can mutate generic lists into sequences and a little more. When you think that most of the Clojure power is based on sequence manipulation you understand that you should use 'seq' often. Sequences in Clojure are often lazy, persistent and immutable, the basic of functional programming. Many of the provided collections in Clojure implement iSeq and thus they are sequences. 'seq' is also the idiomatic way to ask if a collection is empty, since it returns null for empty sequences. It also works on Java iterables. (seq &quot;&quot;) returns null, because the empty string is an empty iterable of Chars.

<DT><A HREF="http://cemerick.com/2009/12/04/string-interpolation-in-clojure/" ADD_DATE="1352480686" PRIVATE="0" TOREAD="0" TAGS="clojure,string,interpolation,tools,stdlib">String Interpolation in Clojure | cemerick</A>
<DD>It's very simple: (use 'clojure.core.strint) and then (let [name &quot;renzo&quot;] (println (&lt;&lt; &quot;Hello ~(name)&quot;))) will do exactly what you expect. Although is not the same out of the box Ruby interpolation experience, it's easy enough to be used. Funny fact: it's compile time because it's a macro, no CPU time spent at runtime to interpolate the string (other than the final concatenation) that is, the language is not spending time at runtime to parse the interpolation. This tiny extension is part of https://github.com/clojure/core.incubator a place where ideas can be tested before a possible addition to core. There are also another couple of interesting ideas there, like a null-safe threaded operator.

<DT><A HREF="https://coderwall.com/p/ukfesw" ADD_DATE="1352478451" PRIVATE="0" TOREAD="0" TAGS="clojure,intellij,classpath,leiningen">Sergey : Import lein-project as intellij-idea module</A>
<DD>Here's a neat trick to import all lein dependencies into intelliJ in a single import action. This is of course useful if you're using clojure from inside intelliJ but you want lein to manage the project for everything else, dependencies included. The problem is that for all run/debug actions inside intelliJ of tests and source code intelliJ won't be able to see the same classpath that lein sees. By creating a new Maven module like this in intelliJ you're getting the best of both worlds. The only thing you need to remember is that whenever you add a new dep in the project.clj you need to do a lein pom to generate the pom again. Enable auto-import in intelliJ and you don't need anything else. Thanks dude!

<DT><A HREF="http://martinsprogrammingblog.blogspot.co.uk/2012/08/some-more-datalog.html" ADD_DATE="1351185718" PRIVATE="0" TOREAD="0" TAGS="clojure,datomic,datalog,performances">Martin's Programming Blog: Some more Datalog</A>
<DD>An interesting comparison between queries executed in pure contrib.datalog and Datomic. The example query here is very simple and includes an implicit join. I have the impression contrib.datalog was not built with performances in mind, but more as a basic implementation. The scarcity of documentation about contrib.datalog illustrates that fact in my opinion. Anyway, Datomic is an order of magnitude faster. But as Martin Trojer points out, is free, closed source and even if you only care about the datomic datalog query capabilities there are 27 additional jar dependencies that you need to download and distribute in your uberjar. At the same time Datomic is more advanced and flexible, for example by allowing you to switch from the in-memory implementation to the disk implementation is you start running out of memory.

<DT><A HREF="http://blog.datomic.com/2012/10/codeq.html" ADD_DATE="1351169344" PRIVATE="0" TOREAD="0" TAGS="clojure,git,datomic,source,history">codeq | Datomic</A>
<DD>Here's another intriguing idea from Rich. Codeq is basically a datomic database built by on top of your git repo, that offers query capabilities over the source code. But that's not all that it does. The parser process is language based and knows the different language constructs like functions in the case of Clojure. It means that the history of the source code is not file based, but function (or class/package) based. Codeq knows how to query a function for its history in time, attaching all of the information regarding the change that a normal git repository would contain anyway. At the moment it only supports Clojure but the architecture is pluggable with other language aware parser. The hope is of course that many languages will be available soon for tracking and parsing. With Codeq you aren't limited to a single git repo. Codec can parse and analyse many git repos at once, tracking for example how the same function evolved from one repo to another where it was copy pasted.

<DT><A HREF="https://github.com/hraberg/mimir" ADD_DATE="1351168549" PRIVATE="0" TOREAD="0" TAGS="clojure,jess,rule,engine,logic,minikanren">hraberg/mimir</A>
<DD>Mimir is a rule engine written in clojure that takes some inspiration from http://www.jessrules.com/jess/index.shtml. The syntax to write facts and rules is terse and allows for pure clojure to be added to the mix. It offers some advanced feature like pattern matching and an experimental miniKanren implementation.

<DT><A HREF="http://www.pitheringabout.com/?p=693" ADD_DATE="1351167987" PRIVATE="0" TOREAD="0" TAGS="clojure,experience,java,corporate">Pithering About » Clojure at a Bank – Moving from Java</A>
<DD>The best experience report from a team moving from Java to Clojure so far. The decision for a team to move to Clojure (or another language) is really team specific. I can't agree more with Jon Pither on this. Also the results seem consistent with other experience reports I've read: reducing waste in development seems to be the most common effect of moving away from Java to a more modern language. Two key enablers: the team is happy doing the move, the corporate environment supports the team in their decision to try a new solution.

<DT><A HREF="http://blog.conj-labs.eu/post/31355766700/pay-it-back" ADD_DATE="1350824063" PRIVATE="0" TOREAD="0" TAGS="clojure,interoperable,java">Conj Labs: The Blog</A>
<DD>Calling Clojure from Java it's easy and a known fact. But, there are ways you can make Java developers life easier by designing the Clojure API to be better interoperable. Nothing huge: use gen-class to expose functions as static, serialize clojure data structures into stringified version of the same thing, use Java collections when that makes sense. That doesn't mean you should code like Java in Clojure. Just design a part of your module to be better inter-operable by wrapping Clojure specific data structure from the Java perspective. Think of it as a layer sitting on top of the usual pure Clojure code. String-ification means that some Clojure data structure can be written in Clojure as strings for Java with very little changes that you then have to interpret clojure-side.

<DT><A HREF="http://blip.tv/clojure/david-liebke-from-concurrency-to-parallelism-4663526" ADD_DATE="1350540039" PRIVATE="0" TOREAD="0" TAGS="clojure,concurrency,parallelism,pmap,pvmap">Watch David Liebke: &quot;From Concurrency to Parallelism&quot; | Clojure Episodes | Blip</A>
<DD>Here's another oldies but goodies to watch. David Liebke does a great job visualising how paralellism of computation on collections can be achieved and what are the downside for each approach. Pmap is the parallel version of map based on threads. In the example 2 cores are available for computation and 4 futures are created. A future is complete when the closure has been run across that set of input. Two scenarios can happen. First. The consumer takes too long. Then the processed subset sits idle waiting and no new futures can be created. Second. One process takes too long. Same, core is busy processing, only the second core accepts new futures, not actually parallel anymore. Solution, chunk it up. Instead of pmapping on top of the collection, partition the collection to smaller chunks and process inside the pmap with a map. Pvmap is instead applying fork-join computation on normal clojure collections such as vectors. You need to provide a computing and a joining function to pvmap to work properly. Fork-join with dequeue is self-balancing: if an input job takes too long the future can 'borrow' from the dequeue of another thread a short job.

<DT><A HREF="http://en.wikibooks.org/wiki/Clojure_Programming/Getting_Started#Enhancing_the_Environment" ADD_DATE="1350539250" PRIVATE="0" TOREAD="0" TAGS="clojure,repl,tools,rlwrap,clj">Enhancing Clojure REPL with rlwrap</A>
<DD>Of all the possible out-of-the-box repl (Cljr, Dejour, ClojureX) I prefer just the minimum to wrap the core Clojure repl with history and maybe tab completion. JLine is one option while the other is rlwrap. I didn't try JLine (which is written in java) but the instructions given here for rlwrap are straightforward. On mac: brew install rlwrap. Then you need to point the script to your clojure install (mine is 1.4.0) and create the tab completion reference running the related clojure script. Rlwrap also gives you matching parenthesis highlight, which is another bonus on the REPL.

<DT><A HREF="https://github.com/relevance/labrepl" ADD_DATE="1350535741" PRIVATE="0" TOREAD="0" TAGS="clojure,training,tutorial,exercises,lab">relevance/labrepl</A>
<DD>Labrepl is a nice resource for Clojure starters coming from the ThinkRelevance crowd. They have a pretty well known reputation with Clojure and training in general and this little project is exactly what you would expect for driving exercises over a Clojure course. It is still based on lein1, so if happen to be already on lein2 you'll have to patch it like this https://github.com/dfuenzalida/labrepl/commit/6f92d1b911c5be0ce25eedb3fc6f6d9d16eaa375 to have it working and export CLASSPATH=`lein classpath` before running ./script/repl. The tutorial gives you basic Clojure training plus advanced topics like creating an entire browser with compujure. Everything is driven by a wiki-like app available at localhost:8080. Very neat, will try out to train people on Clojure very soon :)

<DT><A HREF="http://blog.jayfields.com/2012/10/clojure-avoiding-anonymous-functions.html" ADD_DATE="1349867384" PRIVATE="0" TOREAD="0" TAGS="clojure,learning,core,functions">Jay Fields' Thoughts: Clojure: Avoiding Anonymous Functions</A>
<DD>Not sure if avoiding anonymous functions is the best way to solve the problem of getting to know what's inside the standard library. It surely serves its goal: you'll be forced to learn alternative ways to solve the problem including core lib functions. But at the same time it seems to introduce a less intuitive way to write clojure code and hence to read it. I would probably take the approach described at the beginning of the article: learn through 4clojure.org or other equivalent &quot;koans&quot; sites. I can also suggest to just read through the functions of the standard library, understand their meaning and try them out on the REPL. I also noticed how informative is to read clojure sources. They contain a lot of what Clojure can offer of course.

<DT><A HREF="https://github.com/nilswloka/lein-cucumber" ADD_DATE="1348563719" PRIVATE="0" TOREAD="0" TAGS="clojure,cucumber,leiningen,plugin">nilswloka/lein-cucumber</A>
<DD>This is the lein cucumber plugin to enable cucumber features execution via cucumber-jvm. You definitely want this plugin if you are planning to BDD with cukes on clojure code bases. It's pretty basic at the moment, offering Before/After scenario settings and the Gherkin syntax.

<DT><A HREF="http://thinkrelevance.com/blog/2012/09/22/clojure-conference-organizers-podcast-episode-015" ADD_DATE="1348563418" PRIVATE="0" TOREAD="0" TAGS="clojure,podcast,audio,conference">Blog | Clojure Conference Organizers - Podcast Episode 015 | Relevance</A>
<DD>Enjoyed this quick intro about organizing Clojure events and what kind of effort it takes to manage a conference. Marco is speaking for EuroClojure first edition, which was a clear success. Alex is the organizer of Strange Loop as well as of Clojure/West and Lynn is behind Clojure/conj.

<DT><A HREF="http://unsupportedoperation.blogspot.co.uk/" ADD_DATE="1348563150" PRIVATE="0" TOREAD="0" TAGS="clojure,java,podcast,audio">Unsupported Operation</A>
<DD>Kudos to this &quot;new&quot; (for me) podcast. This is mainly a Java podcast but with news coming from all the other JVM compatible languages including Clojure. I'm a Java programmer by day so it makes sense to me to keep an eye on what's moving in Java world, also because when I put my Clojure hat on at night, I can always use one of those shiny new libs. At the same time this podcast gives me news about what's happening in Scala, Groovy and new JVM languages which is always a good thing. The format of the podcast is the very welcome &quot;no-fluff-just-stuff&quot; so they go straight to the point, their comments are objective and impartial. Highly recommended iTunes addition.

<DT><A HREF="https://github.com/gga/json-path" ADD_DATE="1348518469" PRIVATE="0" TOREAD="0" TAGS="json,clojure,parser,jsonpath,tool">gga/json-path</A>
<DD>Tiny but working JsonPath implementation for Clojure. It would be nice to find something integrated with Cheshire for example, but you need an additional library to add to your json parser if you need to extract specific JsonPath matches. In memory json is just a map of collections and other maps so you can always create your algorithm to extract keys or values a few levels deep.

<DT><A HREF="http://sunng.info/blog/2012/09/shake-every-program-can-be-a-clojure-function/" ADD_DATE="1348263490" PRIVATE="0" TOREAD="0" TAGS="clojure,exec,bin,wrap,dsl">Here comes the Sun » Shake: Every Program Can Be a Clojure Function</A>
<DD>Here's is a neat idea borrowed from Python's sh (http://amoffat.github.com/sh/index.html) library. If you look at /usr/bin and the other $PATH usual suspects, you can see that it should be pretty straightforward for a dynamically typed language to scan those folders and create wrappers for system binaries on the fly, so there is a 1:1 function mapping in the current namespace. This is exactly what Shake does, it includes system binaries as functions for you to call directly. The result is an interesting DSL driven by what is currently executable on your system and without the need for you to know all the internals on how to properly invoke system functions.

<DT><A HREF="http://vimeo.com/20717301" ADD_DATE="1347739827" PRIVATE="0" TOREAD="0" TAGS="clojure,monads,screencast,video,marick,tutorial,algorithms">Monad Tutorial, Part 1 (Monads as Deciders / Identity Monad) on Vimeo</A>
<DD>This is the Marick version of the Monad tutorial. Absolutely brilliant series of 4 videos dissecting what monads are starting from the simplest possible example. Every step is explained or it shouldn't take more than a few minutes of reasoning to understand what's going on. Still, the complexity grows exponentially. Episode 4 is the core of the treatment, where everything comes together and is not that easy to follow. I still have to watch that last part a few more times to completely understand. Basically Marick is re-implementing https://github.com/clojure/algo.monads step by step to show what those hight level macros like domonad are there for. I should mention that reading the first few chapter of SICP helped me a lot quickly understanding many of the concept present here, for example the let form. Enjoyed every single frame, highly recommended.

<DT><A HREF="http://clojuredocs.org/clojure_core/clojure.core/reductions" ADD_DATE="1347739242" PRIVATE="0" TOREAD="0" TAGS="clojure,stdlib,function,debug">ClojureDocs - clojure.core/reductions</A>
<DD>Here's a nifty trick, useful to debug that reduce single liner you are so proud of. If you don't understand what's going on inside and why a reduce operation returns that odd result, you may want to replace it with reductions and look at each step performed during the reduce.

<DT><A HREF="https://github.com/technomancy/leiningen/blob/master/doc/PLUGINS.md" ADD_DATE="1347738772" PRIVATE="0" TOREAD="0" TAGS="clojure,leiningen,plugins">leiningen/doc/PLUGINS.md at master · technomancy/leiningen · GitHub</A>
<DD>Writing plugins for leiningen is pretty straightforward and well documented. Many of the tools coming with leiningen are plugins as well. That maybe explains the good documentation and debugging hooks. I especially like the .lein-classpath entry so that you can develop the plugin directly from the first project that requires it, without the need for a lein install of the plugin. This wiki page contains everything you need to get started, like &quot;eval-in-project&quot; key function used to evaluate code from the plugin in the context of the project where it runs, giving access to the same classpath as seen by the hosting project. This is a good starting point though, I had to search for plugins to understand how things really work when you need something more complicated. (see lein-midje for a good example).

<DT><A HREF="https://github.com/macourtney/drift" ADD_DATE="1347738231" PRIVATE="0" TOREAD="0" TAGS="clojure,tool,migrations,database">macourtney/drift</A>
<DD>Drift is te closest of the library I've found to mimic Rails migrations for Clojure projects. I'm used to the way Rails handle migrations so started searching around for something like this. I know there is something similar in https://github.com/slagyr/joodo by Micah Martin, a Clojure web framework deeply inspired by Rails but I don't know if it can be extracted without using the rest of the framework. I had less luck searching for something like Machinist or Factory Girl for integrated testing and seed data. For this reason I'm kind of growing my own little lib and lein plugin. Hope they'll be public soon.

<DT><A HREF="https://github.com/Raynes/bultitude" ADD_DATE="1347436618" PRIVATE="0" TOREAD="0" TAGS="clojure,classpath,loadpath,tool,utility">Raynes/bultitude</A>
<DD>The name of this library doesn't speak for itself :( but it is certainly an useful utility as soon as you have to play with the classpath seen by Clojure. Bultitude shows you all available namespaces from the current classpath or inspecting a specific jar or folder. Bultitude is considered an improvement over certain limitations of clojure.tools.namespace (see the readme). clojure.tools.namespace can be found now as https://github.com/clojure/tools.namespace (it was previously a classic clojure contrib).

<DT><A HREF="http://clojuredocs.org/clojure_core/clojure.core/fnil" ADD_DATE="1345842452" PRIVATE="0" TOREAD="0" TAGS="clojure,fnil,default,param">ClojureDocs - clojure.core/fnil</A>
<DD>If you are a Ruby programmer like I am, did you ever wondered what is the corresponding of def method(param=1); end to give param a default value of 1 when it's nil? Enter Clojure fnil. Fnil is plain simple wrapper for functions where passing nil can cause problems. It just wraps a function f returning the same f that can handle the first nil parameter with a default value you provide. It can be useful to wrap 3rd parties function invocation where you can't control what happens on a nil, or just as an elegant way to avoid an if statement. Feel free to abuse it.

<DT><A HREF="http://www.fatvat.co.uk/2009/04/understanding-y-combinator.html" ADD_DATE="1345757561" PRIVATE="0" TOREAD="0" TAGS="clojure,combinators,y-combinator,fp,pattern">Understanding the Y Combinator</A>
<DD>Alright, there are two things I'd want to deeply understand and use. Guess which ones? Combinators and monads. Both of them are functional patterns in the sense of combinations of high order functions that achieve some kind of wanted behaviour. Like patterns in object oriented languages, they have specific fields of application. In other words they don't always make sense. A fixed point combinator in general, is a function 'a' that given another function 'b' returns those values for which function 'b' doesn't changes, i.e. function-b(x) = x. The Y-combinator is a type of combinator that is useful in all situations where is not possible to recur by invoking the recurring function by name. This situation happens when the language does not allow named functions (for example untyped lambda calculus) or when the target function is a function generator, like the next sum function generator described here. This function needs to be invoked several times for each element of the collection and each invocation produces the next function to calculate the sum. Here the fixed point is not a value but one of the generated functions, the only one that gives the wanted result. Combinators are impossible to explain without examples, so go try your self and understand all the steps of the computation. In my case, I'm not yet at the complexity level where my functions generates other functions (a rare case) so I assume I'm still far away from proper application of combinators. We'll see.

<DT><A HREF="http://experthuman.com/programming-with-nothing" ADD_DATE="1345483578" PRIVATE="0" TOREAD="0" TAGS="clojure,ruby,functional,fp,combinators,y-combinator">Programming With Nothing</A>
<DD>Welcome to a wonderful trip through functional programming, from higher order functions to combinators. In RUBY! Yeah, crazy stuff happen when you try to implement fizz-buzz constraining yourself to only use blocks. Blocks are used to implement natural numbers (through the concept of increasing by invoking), booleans (through the presence or absence of block call) and so on, including if statements, modulo operands etc, you know, the usual fizz-buzz mumbo-jumbo. You need your functional skill ready while reading through this, some Ruby is required but it's just the bare minimum. I'm still working my way through combinators at the moment which are part of the exercise toward the end. I'd really like to bring this to the next interview and see what happens :)

<DT><A HREF="https://github.com/clojure/clojure/blob/master/changes.md#211-instant-literals" ADD_DATE="1345137526" PRIVATE="0" TOREAD="0" TAGS="clojure,1.4,inst,macro,reader">Clojure 1.4 instant literals</A>
<DD>Instant literals are reader macros. Clojure reader interprets something like #inst &quot;2012&quot; as a new java.util.Date(&quot;2012&quot;) which is not possible in Java (deprecated a long ago). It makes it blazing fast to manipulate dates in Clojure. In the previous example, all the other common date fields are set with a default, that is #inst &quot;2012&quot; will give the java util date equivalent of &quot;2012-01-01T00:00:00.000-00:00&quot; without the need to set all the additional fields. The mapping to java.util.Date can change to Calendar or Timestamp.

<DT><A HREF="https://github.com/clojure/tools.logging/" ADD_DATE="1345108777" PRIVATE="0" TOREAD="0" TAGS="clojure,logging,library,tool,basics">clojure/tools.logging</A>
<DD>Plain simple logging for Clojure wrapping slf4j to access the usual suspects in the Java logging world: commons-logging, log4j and finally java.util.logging. The way I've used was providing a log4j.properties on the classpath and everything worked as expected. The odd thing about logging in clojure is that you can't abuse it like Java. Logging is just a controlled side effect and in that sense it forces you to introduce (do ) blocks all other. Not very functional nor elegant. So I ended up using it in very specific places and using the (spy) function that prints the result of the expression to the log and return the result. The functional way would be to use a logging monad that carries the state along with the steps of the computation. At the moment though it seems overkill.

<DT><A HREF="https://github.com/clojure/java.jdbc/" ADD_DATE="1345108700" PRIVATE="0" TOREAD="0" TAGS="clojure,jdbc,database,data,library">clojure/java.jdbc</A>
<DD>The former clojure contrib JDBC, is a very simple layer around the Java jdbc APIs. It was interpreted the functional way: you execute operations on the database against a database context that establishes the connection. The resulting resultset is a clojure collection and as such is lazy. The strange thing sometimes is that you need a (doall rs) to render the resultset before leaving the connection context. It offers all the basic to interact with a database without the verbosity of the BBC API and for many tasks this is what you need.

<DT><A HREF="http://rubyrogues.com/065-rr-functional-vs-object-oriented-programming-with-michael-feathers/" ADD_DATE="1345024003" PRIVATE="0" TOREAD="0" TAGS="clojure,fp,oo,paradigms,audio,podcast,feathers">065 RR Functional vs Object Oriented Programming with Michael Feathers</A>
<DD>This time the Rougues are confronting a delicate argument, OO vs FP. Unfortunately I'm not happy about the way they handled it, starting from the fact that didn't invite someone from the FP community to join the talk. There are also the usual common places of OO guys talking about what FP is: use immutable data structures to avoid memory overload and list comprehensions are not the essence of functional programming. BUT, *but*, there is some good point to reason about. OO was not translated properly from the original Alan Key propositions of components sending messages between each other. Today we are talking about &quot;Tell don't ask&quot; to remember our self that objects should be communicating asynchronously. The Actors model of computation is typically an OO pattern that implements message passing. It's strange nowadays to see actors being used as a strong argument to adopt FP instead :) A lot of incidental complexity in OO was introduced over the years. OO gave up reusing in the small. OO ended up reusing architectures and frameworks instead. It's so difficult to tell when FP or OO is more suitable to solve a problem that the best thing is trying to put evidence together. What evidence do we have these days? Michael Feathers' blog post (http://michaelfeathers.typepad.com/michael_feathers_blog/2012/03/tell-above-and-ask-below-hybridizing-oo-and-functional-design.html) describes the situation where FP works at the bottom while it becomes OO rising the abstraction at the top. It seem that OO is great at modeling large systems because we've seen very large OO systems. What are the large FP systems instead? Can we demonstrate the same for FP in handling large systems? Maybe there are no large FP systems because 'data' is large in FP. You take all the data complexity out and put it in an hashmap of some sort. All the complexity in FP seems to move to functions. To summarise: both FP and OO are going to have their in programming but nobody at the moment knows where exactly.

<DT><A HREF="http://blip.tv/clojure/nathan-marz-cascalog-making-data-processing-fun-again-5970118" ADD_DATE="1344964771" PRIVATE="0" TOREAD="0" TAGS="clojure,cascalog,video,martz,twitter">Nathan Marz: &quot;Cascalog: Making Data Processing Fun Again&quot; | Clojure on Blip</A>
<DD>I'm impressed by this presentation of cascalog, although I was overwhelmed by the increasing complexity of the queries half way through. But I don't think that's important. Queries are going to be related to a business domain that requires a bit to grasp. What's important is to see how much SQL you just avoided by comfortable stay inside your beloved Clojure. Declaraive programming allows you to work your query complexity over functional decomposition without the need to become a sql guru (because I suppose you can do most of that in sql as well). Also consider you can test drive cascalog and use your favourite debugging setup. I cannot imagine how to do that in some proprietary sql environment. Something I need to understand better is how everything in cascalog seem to map and reduce. How exactly a query gets map reduced? Is that always possible? Finally, a concern I have is that cascalog, the clojure implementation of datalog, datomic query language all seems to solve the same problem with a slightly different syntax. Is this the right time to think about an uniform standard?

<DT><A HREF="http://blog.jayfields.com/2012/01/lessons-learned-while-introducing-new.html" ADD_DATE="1344600657" PRIVATE="0" TOREAD="0" TAGS="clojure,teaching,migrating,team">Jay Fields' Thoughts: Lessons Learned while Introducing a New Programming Language</A>
<DD>I enjoyed this reading, a very insightful guide to migrate your team to a new language (in this case Clojure over Java). The first step is parallel development of features off work and comparison during office hours. Non production code is a good place to start: tests, log parsers, simulations, migration scripts. You should be prepare to re-write the new part back to the old language if somebody is having a lot of difficulties. Something else I didn't think about: it's okay if part of the team is working on the old language and other people are working with the new if they don't want to follow. I'd like to add: if your company has a teaching/learning department engage with them to offer Clojure courses, presentations, dojos and so on. Another comment: there is a fight on two fronts. From the above: management should recognise the business advantages of the new language. From the bottom: developers should scream their frustration with the old language and ask to move to the new. There are many other takeways. 1. the new language must be almost as fast as java 2. if the company is already JVM based, it must be on the JVM 3. Causing the least amount of pain possible to teammates, adapting to current development env (for example, run on IntelliJ, right click run tests, CI integration, profiling)

<DT><A HREF="https://github.com/technomancy/leiningen/blob/master/sample.project.clj" ADD_DATE="1344587892" PRIVATE="0" TOREAD="0" TAGS="clojure,leiningen,options">leiningen/sample.project.clj at master · technomancy/leiningen</A>
<DD>The other day I had the following question for Google: how can I tell leiningen that there are other sources which are not in the default src folder? I had a good 15 minutes search and then found the all-you-can-eat version of the project.clj from the leiningen repo itself. This is all you need to understand what you can do with leiningen, and the list of options is long and well documented in this sample project.clj. My question, for instance, is answered by the :source-paths option. At the bottom you'll see that lein is going to obey a few of the usual Java environment variable suspects that will be passed to the JVM, like jvm_opts. Well done.

<DT><A HREF="http://blip.tv/clojure/phil-hagelberg-making-leiningen-work-for-you-4733496" ADD_DATE="1344497943" PRIVATE="0" TOREAD="0" TAGS="clojure,leiningen,tool,build">Phil Hagelberg: &quot;Making Leiningen Work for You&quot; | Clojure on Blip</A>
<DD>Phil Hagelberg (aka techmomancy) goes through the main features of Leiningen, which is the workhorse tool for developing Clojure application. The presentation is quite old, so some of the new features you'll see here are already there now, especially with version 2.0-preview that is available today. Many changes since the previous release: dependencies stay in place where they are in the maven repository. Plugins are now more modular and flexible for the installation. A few things I didn't know: the /checkouts folder can be used to override dependencies with out-of-the-trunk projects. This is useful for parallel hacking while developing your own project instead of jumping to the directory where you have the dependency to work on a patch. You can write your own task (to be expected) something that I never used myself. And many more. At the end Phil lists what makes a good open source project good, like leiningen with its 50+ active contributors is.

<DT><A HREF="http://thinkrelevance.com/blog/2012/07/31/rich-hickey-podcast-episode-014" ADD_DATE="1344497282" PRIVATE="0" TOREAD="0" TAGS="clojure,rich,history,podcast,audio">Blog | Rich Hickey - Podcast Episode 014 | Relevance</A>
<DD>An easy listening get-to-know-the-inventor-of-clojure podcast. Rich is a very smart guy and he's the main responsible for my interest in Clojure, not the language. Let me explain. When I was a full time Ruby programmer I use to follow (and I still do) Stuart Halloway blogs, presentation and books. When I saw his interest in Clojure I was intrigued as well and I promptly found Rich's Clojure introductions on Video. It was just fascinating to hear him speaking about the concept of time and identity. What?!? What time and identity has to do with OO and functional programming? It snowballed from there. So if I can give a suggestion for the next language inventor is: think carefully about the principles behind your language, document them and possibly send out easily accessible videos that result at the top of the google page. In this interview Rich talks about his background, how he came up with Clojure, his past as audio engineer and C++ guru. He's also working on a third &quot;big thing&quot; other than Clojure and Datomic: Machine Listening (http://en.wikipedia.org/wiki/Machine_listening).

<DT><A HREF="http://en.wikibooks.org/wiki/Learning_Clojure/Special_Forms" ADD_DATE="1344441372" PRIVATE="0" TOREAD="0" TAGS="clojure,form,special,macro">Learning Clojure/Special Forms - Wikibooks, open books for an open world</A>
<DD>Is a special form really special? Yeah, kind of, because they are all special in the same way. Special means that it looks like a normal function but it doesn't behave as such. What usually is different is the was parameters are evaluated and in which way the function is dependent on the surrounding context. The clojure reader needs to apply a special treatment for these forms: if ,quote, do, try, fn, let to name a few. They usually differ from functions and macros provided by the standard library in the sense that they are not built on top of other Clojure primitives. This wikibook page contains a nice summary of the most common Clojure special forms.

<DT><A HREF="http://stackoverflow.com/questions/1191628/block-comments-in-clojure" ADD_DATE="1344410239" PRIVATE="0" TOREAD="0" TAGS="clojure,comments,macro,block">Block Comments in Clojure - Stack Overflow</A>
<DD>coming from a Ruby background I searched for some form of block comment in clojure on day one. I was surprised not to find a proper one. A definition of proper is a sintactic form that the compiler totally ignore so I can for example embed some raw XML without escaping for further processing as a string. You can comment with ';'  but it doesn't work that well. There is a 'comment'  macro that can enclose multiple lines but it needs to be proper clojure. The #_ macro is a shortcut for the 'comment' block that requires less typing but again it must enclose proper clojure. A patch was submitted at some point to allow raw text but it was deemed as useless by Rich Hickey in person. That's the meaning of having a benevolent dictatorship in charge of the language!

<DT><A HREF="http://blog.8thlight.com/colin-jones/2010/12/05/clojure-libs-and-namespaces-require-use-import-and-ns.html" ADD_DATE="1344355594" PRIVATE="0" TOREAD="0" TAGS="clojure,namespace,include,require,refer">Clojure Libs and Namespaces: require, use, import, and ns | 8th Light</A>
<DD>By far this is the best introduction to clojure tooling for namespaces manipulation. I came across this a while ago and I keep getting back to it when I need a quick refresh. The well crafted article by Colin Jones is a gradual introduction to all the flavours of require, use and lately refer. There are many powerful options and unfortunately it can confuse at the beginning. With the introduction of Clojure 1.4 'use' has been replaced by require plus :refer to obtain similar results. Everything adds then together with the ns macro where you can list all of them at once. My preferred way to include clojure namespaces at the moment  (and avoid quite a bit of thinking) is to always prefix them by qualifying  them like: (require '[clj-json.core :as json]) so it's always clear what I'm talking about: json/generate-string for example.

<DT><A HREF="http://debasishg.blogspot.co.uk/2010/04/thrush-in-clojure.html" ADD_DATE="1343751937" PRIVATE="0" TOREAD="0" TAGS="clojure,operator,macro,threading,syntax">Ruminations of a Programmer: Thrush in Clojure</A>
<DD>The so called thrush operator in Clojure, aka -&gt;&gt; (and cousin -&gt;), is an handy macro that helps readability in certain scenarios. It is basically a way to invert the sense of multiple levels of enclosing functions so that they read top-down as they are evaluated by the interpreter. With time in clojure you'll learn how to do this automatically by searching the innermost function, evaluates it, move up one level with the first result in mind, and so on up to the outmost function. In cases where it makes sense, you can flat this sequence of functions top to bottom with the thrush -&gt;&gt; operator. The cousin -&gt; operator is similar but it threads functions the other way around, from the first to the last. Illuminating examples are here for both: http://clojuredocs.org/clojure_core/clojure.core/-%3E .When to use them? Is context specific, but probably when you have a sequence of 3/4 very short sequence calls acting on some initial value in self-enclosing way.

<DT><A HREF="http://blip.tv/clojure/mark-mcgranaghan-one-ring-to-bind-them-4724955" ADD_DATE="1343750808" PRIVATE="0" TOREAD="0" TAGS="clojure,ring,compojure,hof">Mark McGranaghan: &quot;One Ring to Bind Them&quot; | Clojure on Blip</A>
<DD>Ring is a wrapper around Java servlet including a mechanism to chain together &quot;filters&quot; in front of the incoming request and at the end of the resulting response. At its core, ring is a mapping (app request) of a request into a response. So called middlewares (filters in Java, chain of responsibility pattern of GOF memory) can be added to the chain to manipulate the input output. From the functional perspective filters can be built on top of the main mapping through high order functions (HOF): (defn middleware-blah [app] (fn [app] (do-something-with-app (app request))). A lot of libraries build on top of Ring. Compojure helps creating mappings between an incoming http url request and a method that returns a response.

<DT><A HREF="https://github.com/mmcgrana/clj-json" ADD_DATE="1343748806" PRIVATE="0" TOREAD="0" TAGS="clojure,ring,json,library">mmcgrana/clj-json</A>
<DD>Here's another nice addition for your clojure toolbox. A straight and clean json parsing library called clj-json based on the popular and fast http://jackson.codehaus.org java library. Once again all the goodies of very well tested and robust Java libraries that you can use idiomatically from Clojure often resulting in single liners. And it comes from Mark McGranaghan of Ring (Heroku and many more) fame.

<DT><A HREF="http://www.infoq.com/presentations/Clojure-in-the-Clouds" ADD_DATE="1343748287" PRIVATE="0" TOREAD="0" TAGS="clojure,framework,noir,joodo,gaeshi,web">Clojure in the Clouds</A>
<DD>In this presentation from Clojure/West Micah Martin introduces a few neat libraries and framework to develop real life Clojure web stacks. https://github.com/slagyr/gaeshi is the first attempt based on google app engine. http://joodoweb.com instead is built on top of gaeshi stripped of the relation to a specific cloud engine. Joodo is Rails inspired with almost a one to one mapping to the rails development process. It brings together testing tools, database mapping tools, project generation and automation libraries and can deploy to Heroku. The presentation is not too long and a very good starting point to explore these libraries. The only controversial sentence that Micah says in the presentation is that he decided not to adopt other clojure libraries to deploy to app engine because they were not test driven (but tested after apparently). Really?

<DT><A HREF="http://mmcgrana.github.com/2010/08/clj-http-clojure-http-client.html" ADD_DATE="1343747062" PRIVATE="0" TOREAD="0" TAGS="clojure,http,rest,library">Introducing clj-http, a Clojure HTTP Client</A>
<DD>I had a quick look at the problem of invoking rest services from Clojure. There are several solutions, including the option of using the good old JDK. The Programming Clojure book contains an example of http rest calls based on HttpURLConnection at page 220. But it seems unnecessary verbose. There are definitely nicer clojure alternatives wrapped in a much more idiomatic way. clj-http wraps apache httpcomponents for example and can be used as single liner in most cases. It's well documented and actively developed. There are alternatives, like the case in which you need to go asynch. In that case you can use http.async.client instead.

<DT><A HREF="http://clojure.org/macros" ADD_DATE="1343149711" PRIVATE="0" TOREAD="0" TAGS="clojure,macros">Clojure - macros</A>
<DD>Macros are special constructs which are interpreted by the reader and will influence the final output which is going to the compiler. With Macros you can effectively extend the language. Clojure “when”, “for” or syntax like the arrow operator “-&gt;” are effectively macros. There are contexts where only macros can be used. Clojure is strict in the sense that all parameters are evaluated. There are cases though where this is not the behaviour you want: you want the reader to wait until the compiler to evaluate those expressions (i.e. at runtime) so that at compile time you can decide the final form of the code.

Try to give these to the REPL and enjoy the expansion: [1.] (macroexpand '(when (= &quot;a&quot; &quot;a&quot;) (def renzo &quot;, renzo&quot;) (str &quot;this is also true&quot; renzo))) [2.] (macroexpand '(for [x (range 10)] (str x)))

<DT><A HREF="https://peepcode.com/products/functional-programming-with-clojure/" ADD_DATE="1343149407" PRIVATE="0" TOREAD="0" TAGS="clojure,learning,screencast,intro">Clojure Tutorial | PeepCode Screencast</A>
<DD>Not completely impressed by this peepcode about Clojure. I watched it a long time ago and it made sort of sense. I won't suggest you buy this unless it's the first time you hear about Clojure and you want some pointers. It's very basic and unfortunately not very idiomatic. The &quot;mire&quot; adventure game is not the best example of functional thinking, it resembles more a literal translation from procedural programming into Clojure. So, go buy it if this is really an intro for you, but watch Rich Hickey introductions to Clojure anyway.

<DT><A HREF="http://codemonkeyism.com/clojure-scala-part-2/" ADD_DATE="1343148825" PRIVATE="0" TOREAD="0" TAGS="scala,clojure,languages,jvm">Clojure vs Scala, Part 2 and Part 3</A>
<DD>There are many threads on Stackoverflow about language comparisons. I've found this short series of blog posts to report some good and bad about clojure and scala. The two languages have completely different philosophies but the impression is that at the end they have more in common than expected. There are hiring and people factors to consider when choosing one or the other. Clojure is a radical approach that refuses objects as the main tool to model the world, especially a concurrent world. Scala embraces both styles and let object oriented developers depart from the paradigm when needed.
The choice between the two language is almost impossible to make outside a specific context. They both have pro and cons that compensate each other on an absolute scale. What should not happen in both cases is that you choose the language because you can “send methods to collections and around”. There is much more about the functional paradigm that has nothing to do with closures.

<DT><A HREF="https://groups.google.com/forum/?fromgroups#!forum/london-clojurian-jobs" ADD_DATE="1343148635" PRIVATE="0" TOREAD="0" TAGS="job,clojure,clojurian,london">London Clojurian Jobs - Google Groups</A>
<DD>If you are in the London area you may want to bookmark this URL from the London Clojurian google group. You need to login into your google account to see the page, but that's completely free. At the moment there aren't a lot of posts but it's nice to see that there are some and companies are hiring for Clojure jobs. Sometimes not 100% Clojure but a mix of languages which is still a good plus. These companies definitely have advantages over the competition: hiring for Clojure programmers means to attract old and new lispers (or lisp-thinkers), some fine minds you don't want to miss in your team.

<DT><A HREF="http://blip.tv/clojure/dan-friedman-and-william-byrd-minikanren-5936333" ADD_DATE="1342769497" PRIVATE="0" TOREAD="0" TAGS="clojure,logic,minikanren,scheme,talk,video">Dan Friedman and William Byrd: &quot;miniKanren&quot; | Clojure on Blip</A>
<DD>The authors of the Reasoned Schemer, Dan Friedman and William Byrd, are here to introduce the Clojure crowd to a lot of Scheme with miniKanren. miniKanren is a logic programming language written on top of scheme. It is an entertaining and mind bending talk. The peak was when given a small syntax of a language, they generated random instructions that obeyed a specific output required from the query. They seemed quite excited to see some &quot;higher level&quot; construct in the middle like when the logic reasoning behind miniKanren introduced the &quot;app&quot; construct or some recursion. At the beginning they explain that it takes just two things to mutate a functional program into a logic one: what the function returns should be now a parameter and the function should return true/false. And of course, you should change the name appending a spanish &quot;o&quot; to the name of the refactored function! :)

<DT><A HREF="http://thinkrelevance.com/blog/2012/04/26/thinkrelevance-the-podcast-episode-010-stu-halloway" ADD_DATE="1342448457" PRIVATE="0" TOREAD="0" TAGS="clojure,datomic,stu,relevance">Blog | ThinkRelevance: The Podcast - Episode 010 - Stu Halloway | Relevance</A>
<DD>Here's ThinkRelevance's episode with Stu. The episode is mainly about Datomic, a new database concept written in clojure. Datomic is what happens when a database stores fully versioned data and nothing is lost. At that point you don't really need to run query on a single server anymore. Data can be distributed as well as the view of the data between peers. Some other process will take care to enqueue and transactionally make changes. Github is somehow using a similar model, although you can't really indicate that the store resides on some other harddrive. Halloway also speaks about Relevance process a bit, describing that the do pair especially when the design of a system is involved and less when the &quot;construction&quot; phase is going on. Sounds waterfallish eh? Something similar apparently happened with Datomic as well. They designed carefully all the features for a long time before going hard at code. I think this reflect on the vocabulary used to describe Datomic (and sometimes Clojure as well): it's full of coined words that you need to understand first. That's probably one of the reason why you can't grasp Datomic at first sight.

<DT><A HREF="http://blip.tv/clojure/sam-aaron-programming-music-with-overtone-5970273/" ADD_DATE="1342447641" PRIVATE="0" TOREAD="0" TAGS="clojure,entertaining,video,talk,overtone">Sam Aaron: &quot;Programming Music with Overtone&quot; | Clojure on Blip</A>
<DD>I had the pleasure to meet Sam Aaron a while ago at ScotRuby conf. He's not just the inventor of overtone, is a truly passionate programmer and all round inspiring guy. His energy permeates throughout the presentation. Overtone is a clojure wrapper around the SuperCollider API. What interesting about Overtone is how is capable of describe complicated tone generations with a few lines of Clojure. He demonstrate several live capabilities of Overtone (and Aaron as a musician) making this one of the most requested Clojure talks at conferences.

<DT><A HREF="http://clojure.com/blog/2012/05/08/reducers-a-library-and-model-for-collection-processing.html" ADD_DATE="1342439070" PRIVATE="0" TOREAD="0" TAGS="clojure,reducers,parallel">Clojure/core — Reducers - A Library and Model for Collection Processing</A>
<DD>The reducers library is alpha work and contains two main groups of &quot;public apis&quot;. The first group contains r/map r/filter and so on, all the relatives &quot;reducing&quot; versions of the standard library. The main differences are that the reducing versions are composable and you can concatenate a bunch of them together. After composing them (for example, increment plus one a collection, then filter out even numbers) you can then apply the resulting collection to a classic &quot;reduce&quot; function from the standard library. While composing them they remain &quot;lazy&quot; in the sense that nothing is rendered until the final reduce is applied, creating a &quot;recipe&quot; for computation. The second part of reducers has to do with &quot;fold&quot;. Fold is a paralellizable version of reduce. Fold will split the collection into subparts and reduce them independently, which implicitly means that internally fold is doing a reduce over a reduce. For this to happen the given function must provide an identity value when called by itself and be associative (of course).

<DT><A HREF="http://www.andrewhjon.es/142343729" ADD_DATE="1342415567" PRIVATE="0" TOREAD="0" TAGS="clojure,introducing,pitch">Shall we use Clojure - my presentation - Andrew Jones</A>
<DD>A little bit controversial, but there is some good thought about why your company and team should adopt clojure. Succinctness is measured against custom code that we have to trust and probably results are a little exagerated. It would be interesting to run static tools against codebases completely rewritten in clojure as the article does but on open source projects. The bracket comparison is simple but effective I think. Is one of those &quot;stupid&quot; arguments against clojure when you see the quantity of parenthesis. I agree with the point about recruitment. If you want to hire smart, hire from communities using a smart language. The article is otherwise lacking supporting evidence and written too quickly.

<DT><A HREF="http://clojuredocs.org/clojure_core/clojure.core/promise" ADD_DATE="1341561513" PRIVATE="0" TOREAD="0" TAGS="clojure,core,concurrency">ClojureDocs - clojure.core/promise</A>
<DD>Promises are still alpha work in Clojure core. Futures and promises are similar. They differ in the way you de-ref them. A future can be dereferenced any time and will return nil if not realized. A promise will block the caller until the promise realize. You definitely want to use higher abstractions to control concurrency, but in case you need a layer below, futures and promises can be useful. A promise for example can be used to implemet a semaphore-like construct to synchronise multiple threads on a common starting point.

<DT><A HREF="https://github.com/mmcgrana/clj-stacktrace" ADD_DATE="1341561116" PRIVATE="0" TOREAD="0" TAGS="clojure,stack-trace,improvement">mmcgrana/clj-stacktrace</A>
<DD>Mentioned while speaking about complexity of clojure stack traces in Jay Fields' blog post, this is a library that intercept calls to clojure.stacktrace print-cause-trace using leiningen hooks in a very smart way. Once the call is intercepted the stack trace can be cleaned up and organised as shown. The resulting stack trace is much more readable. Yeah. Thanks go to http://twitter.com/mmcgrana

<DT><A HREF="http://mitpress.mit.edu/sicp/" ADD_DATE="1341509400" PRIVATE="0" TOREAD="0" TAGS="clojure,functional,book,video">Welcome to the SICP Web Site</A>
<DD>Not sure why I waited that much to start reading the SICP. Maybe fear of an academic book full of abstract theory. Not at all! I wish I had had a look at this book while started learning Clojure. I did struggle a bit understanding all those notions like tail recursion, big(O) notations for recursive and iterative versions of algorithms and so on. But not only: SICP is also a clear explanation of what happens to a compiler during recursion, what the real meaning of bound arguments is and many more. SICP And it's just the first chapter!

<DT><A HREF="http://blog.jayfields.com/2012/06/reading-clojure-stacktraces.html" ADD_DATE="1341420773" PRIVATE="0" TOREAD="0" TAGS="clojure,stacktrace,annoying">Jay Fields' Thoughts: Reading Clojure Stacktraces</A>
<DD>If there is a thing that annoys me is when inside vimclojure I get those long stack traces and in order to see the problem I need to change split window and &quot;gg&quot; to the top. In this article Jay Fields is explaining what you should focus on while looking at the stack trace. Notable hints: you can temporary name anonymous functions to see them in the trace and visually remove everything that is clojure core and search for lines connected to your custom namespace. Look again at the rest to give some more context after you realize what line of your code is giving the problem. Apparently there are smart solutions to make the stack trace more readable: https://github.com/mmcgrana/clj-stacktrace. It's intercepting calls to clojure.stacktrace print-cause-trace to make the output more readable. The problem still remains though for the quantity of generated classes that the clojure compiler produces. That's valid for other JVM languages like JRuby suffering similar problems.

<DT><A HREF="http://vimeo.com/euroclojure" ADD_DATE="1341350359" PRIVATE="0" TOREAD="0" TAGS="video,clojure,conference">EuroClojure 2012 on Vimeo, first videos are available</A>
<DD>EuroClojure 2012 was the first 2-day, full-blown conference in Europe for the Clojure community. Unfortunately I had to miss it but I managed to get an impression of the conference from the Starbucks around the corner the morning of the second day! People were enthusiastic and that made me even more envy. Anyway, I'm happy that the videos are finally here.

<DT><A HREF="http://www.skorks.com/2009/09/bash-shortcuts-for-maximum-productivity/" ADD_DATE="1320768041" PRIVATE="0" TOREAD="0" TAGS="bash,craft">Bash Shortcuts For Maximum Productivity</A>
<DD>Really neat list of bash line kung-fu moves.

<DT><A HREF="http://www.dextronet.com/blog/2011/04/10-best-tricks-of-fooling-myself-to-work/" ADD_DATE="1303202612" PRIVATE="0" TOREAD="0" TAGS="productivity">10 best tricks of fooling myself to work « How to get organized, how to be productive, GTD, Swift To-Do List tips and tricks – Dextronet Blog</A>
<DD>Some good ones in this list, especially the ones I feel weaker implementing. Here's the list after I removed the not important ones for me and re-prioritized based on my weaknesses: 
1. START WORKING FIRST THING: especially in the morning get straight to the point.2. BACK TO WORK: build the habit of constantly repeating your self to get back to work after interruptions.3. PAPER AND PENCIL: todo lists are great, but you always need a faster cache-like storage in fron of you which is completely destructured.4. REAL BREAKS: get up and away from the computer is the only real break.5. GO META WHEN YOU REFUSE TO DO IT: Describe the tasks needed to get it done. Write down notes and thoughts about each one, write down more tasks.6. ALWAYS READY WITH WHAT'S NEXT: you should never need to think, just start executing the next item right away.7. LEAN DESK: remove everything which is not essential. Ideally you should only have your laptop.

<DT><A HREF="http://pragprog.com/magazines/2010-06/when-did-that-happen" ADD_DATE="1303198922" PRIVATE="0" TOREAD="0" TAGS="">The Pragmatic Bookshelf</A>
<DD>So let me see if I get this correctly. One day not so long ago a very clever guy named Alan was able to model how humans calculate to solve an intriguing mathematical problem. He envisioned a mechanical equivalent of the human reasoning (the Turing Machine) that is able to sustain infinite calculations (given the right amount of paper). That model implemented in circuitry is the modern computer. My question is: the computer models how our limited brain works, but are there other ways to calculate?

<DT><A HREF="http://kerryb.github.com/iprug-rspec-presentation/#9" ADD_DATE="1295339341" PRIVATE="0" TOREAD="0" TAGS="">RSpec Tricks</A>
<DD>Terrific collection of hard to find rspec tricks. 

<DT><A HREF="http://samisamhuri.blogspot.com/2010/11/37signals-chalk-dissected.html" ADD_DATE="1291442217" PRIVATE="0" TOREAD="0" TAGS="html5,css3,ipad,ios,coffeescript">sjs: 37signals' Chalk Dissected</A>
<DD>That was an interesting reading. Sami Samhuri dissected 37signals' Chalk which is a webapp targeted at iOS devices specifically iPad. Sam Stephenson wrote the app in CoffeeScript, a trendy way to write JS (like haml-sass is for html-css). We are talking about one of those ways to spare yourself to learn Objective-C. The background image can be used both landscape as well as portrait thanks to image positioning with CSS3 media queries. This is why you can speak of sprites instead of images. Many other elements are also positioned dynamically from the same image file. All animations are CSS3 hardware accelerated (--webkit-transform) instead of the old style JS transitioning. Several other tips and tricks for bleeding edge JS and CSS3 to capture touches and draw accordingly. Clever.

<DT><A HREF="http://www.starling-software.com/employment/programmer-competency-matrix.html" ADD_DATE="1291289736" PRIVATE="0" TOREAD="0" TAGS="skills,recruitment">Programmer Competency Matrix</A>

<DT><A HREF="http://simonwillison.net/static/2010/redis-tutorial/" ADD_DATE="1288178275" PRIVATE="0" TOREAD="0" TAGS="nosql,redis,recipes,scalability,performance">Redis tutorial, April 2010 - by Simon Willison</A>
<DD>Delighted by this Redis tutorial in the form of slides by Simon Willison. I have read a few introductory things about NoSQL databases in the past, namely CouchDB and Mongo. Redis sounds much more simpler to understand and fluff-free-oriented. This tutorial is a must read for the quality of the examples and usage scenarios given. I never realized how many algorithms would benefit from a NoSQL installation while I was too focused on the OO impedance mismatch. Sure objects or documents persistence is something you can do in NoSQL, but there are many other interesting scenarios: social graphs, random selections from a set, statistics, IDs shuffling and handling and much more. How Redis handle concurrency? By being a *very* fast single-threaded server! The &quot;recipe&quot; form is the same used by the expanding collection at http://rediscookbook.org/ soon to become an O'Reilly book. The importance of good communication: I got definitely interested in Redis.

<DT><A HREF="http://techzinglive.com/page/288/techzing-58-david-fogel-evolving-a-world-class-ai" ADD_DATE="1287524317" PRIVATE="0" TOREAD="0" TAGS="ai,game,evolution">TechZing 58 – David Fogel / Evolving A World-Class AI</A>
<DD>Another interesting episode of TechZing. BTW I always learn something new from Justin and Jason, especially advices about how to organize my life as a contractor. This time they interviewed a veteran AI expert, David Fogel. The first part of the interview is dedicated to the history of Blondie24, a self-tought checker program that achieved impressive results. The idea from conception to implementation and what Blondie24 was able to win as told by the author is engaging. I learned a bit more about the history of game applied AI and how it evolved.

<DT><A HREF="http://startuppodcast.wordpress.com/2010/08/20/show-80-josh-clark-tapworthy-designing-great-iphone-apps/" ADD_DATE="1286392382" PRIVATE="0" TOREAD="0" TAGS="iphone,mobile,business,development,ux">Show #80 Josh Clark, Tapworthy: Designing Great iPhone Apps - The Startup Success Podcast</A>
<DD>Josh Clark is not telling us the usual commonplace stuff we use to hear when speaking about what makes a mobile application great. The big picture consists of three mindsets: micro-tasking (repetition), locality (urgency), boredom. I'm on the go when I use my iPhone so I'm micro-tasking to get something done quickly. The application should allow me to get to the final results in just a few quick moves. I'm local, so I expect from the application to localize information and to mix &quot;local&quot; with sensors: visualize what is local, speak to me what is local or tell me what's in front of me thanks to the compass. We can give new context to the &quot;personal computer&quot; definition of decades ago. Speaking of porting legacy app to mobile, Josh suggests not to just replicate the experience on the phone, but to find what part can be really be mobile. Mobile platforms aren't just for work, they are cultural platforms, something with a personality.

<DT><A HREF="http://startuppodcast.wordpress.com/2010/07/10/show-74-kent-beck-on-lean-startups-tdd-and-startups/" ADD_DATE="1285579951" PRIVATE="0" TOREAD="0" TAGS="kentbeck,lean,startup,tdd">Show #74 Kent Beck on Lean Startups, TDD and startups The Startup Success Podcast</A>
<DD>The &quot;Learn, Measure, Build Cycle&quot; is at the base of continuous deployment. You can think of it as an A/B Testing which takes place ahead of feature completion. The principle is to build just enough software just to get the answer to the business question. Then deploy and measure the results. Capital requirements and risk will go down as a consequence.

Capital efficiency for startups has increased to the point that a single person can work to more startup projects at once. VCs of course enjoy this because they can increase the number of startups to fund at a lower cost and increase the probability of success of at least one.

Sometimes it's necessary to take a shortcut and avoid testing. TDD is especially effective for the not well known areas of the application and for parts subject to heavy optimization. The decision to skip testing is not a practice you can take in isolation, it's an option when it considerably slows down the dev cycle.

<DT><A HREF="http://thecleancoder.blogspot.com/2010/09/hacker-novice-artist-and-craftsman.html" ADD_DATE="1285351270" PRIVATE="0" TOREAD="0" TAGS="craftsmanship,unclebob,roi">The Clean Coder: The Hacker, The Novice, The Artist, and The Craftsman.</A>
<DD>Never thought of that in this terms, but the ROI-based model Uncle Bob describes covers a lot of cases. The craftsman is the only category described here that cares about ROI. Wonder where researchers would fit in here. There is definitely some sort of ROI in research, but the time to achieve ROI is different that that of the industry.

<DT><A HREF="http://blog.dannorth.net/2010/08/30/introducing-deliberate-discovery/#com-head" ADD_DATE="1284804079" PRIVATE="0" TOREAD="0" TAGS="agile,discovery,ignorance,planning,stories">Dan North - Deliberate Discovery</A>
<DD>Dan North speaks on his blog about what we are missing when we just concentrate on user stories during the inception of a project with the effect of having stakeholders looking at the story backlog, turning it 90 degrees and think of it as a gaant chart. Deliberate discovery means to allocate part of the inception effort to something which is not story description. Learning is the constraint.
Ignorance decreases as the project moves forward in a non linear fashion. The skill to improve is how to find which factors in a project (or ignorance axis) are the most effective to reduce ignorance the quickest and take whatever action is needed in that direction along with user story planning. Dan is convinced that this skill is subject to the Dreyfuss model and as such it requires practice and this is why we have the impression we can't predict what's going to happen to the project. Of course we don't have the crystal ball, but we can get better at it.

<DT><A HREF="http://herdingcode.com/?p=254" ADD_DATE="1284049140" PRIVATE="0" TOREAD="0" TAGS="ruby,dotnet,rails,design,architecture">Herding Code 82: Cory Foy and Will Green Compare .NET and Ruby Development | Herding Code</A>
<DD>Comparisons between languages are usually useless or even stupid. I heard a very discussion instead in this PodCast by Herding Code thanks to Cory Foy. First of all ActiveRecord and its SRP violation: in Ruby with mixins and dynamic types it's much easier to add persistency into model objects. This is probably the main reason why Rails developers usually don't care. With typed languages instead the amount of code and interfaces required to achieve the same thing is evident and scarier. &quot;Your application tends to model the company organizational structure&quot; so people think that Java apps are more complicated because they model complex businesses. False: Ruby is just so expressive that you don't need a lot of layers just to make it works. DDD is uncommon because Rails came out from a presentation first approach that somehow permeates into the framework.

<DT><A HREF="http://www.se-radio.net/podcast/2010-07/episode-165-nosql-and-mongodb-dwight-merriman" ADD_DATE="1279650271" PRIVATE="0" TOREAD="0" TAGS="nosql,podcast,database,consistency,data">Episode 165: NoSQL and MongoDB with Dwight Merriman | Software Engineering Radio</A>
<DD>Another nice episode on the nosql db space. I think I'm getting closer and closer to understand what kind of problem nosql dbs are solving. One of the reasons is that the relational model is very easy to understand and intuitive: the transactional ACID properties is exactly what we want to see. I write something and I can read my changes. I move data from one place to another and I expect to see the new data in the right place. And so on. NoSql is just opening to all the shade of grey in between. Data will be eventually consistent is the key: concurrency and availability is embraced. Programmers now have one more task each user story developed: what is the consistency model? Based on the answer, different part of the application can be tuned for different consistency. For example if I am the user making the change I want to see my changes, but I don't care if others will see in a few minutes. There are many other nuances like this one which are not easy with MySql.

<DT><A HREF="http://twitter.com/cirillof/status/14775002057" ADD_DATE="1275034410" PRIVATE="0" TOREAD="0" TAGS="pomodoro,productivity,timer">Twitter / Francesco Cirillo: ...right now 5 minute</A>
<DD>This tweet from Francesco, the inventor of the Pomodoro Technique, remembers me that the 25 mins pomodoro &quot;time&quot; is customizable. The fact that the timer can be adjusted during the day is probably one of the most important aspect of the technique. The pomodoro time should contract or expand to fit the current focus ability. If you can't focus for more than 5 minutes, then that should be your pomodoro time. The Pomodoro time can be be reverted slowly up to 25 minutes or more when internal distractions aren't an issue anymore. Pomodoro shrinking accomplishes a specific goal: keep frustration away when we are not able to concentrate and keep on working with satisfaction even when bad mood kicks in.

<DT><A HREF="http://gojko.net/2009/02/27/thought-provoking-tdd-exercise-at-the-software-craftsmanship-conference/" ADD_DATE="1274255383" PRIVATE="0" TOREAD="0" TAGS="WIP">Gojko Adzic - Thought-provoking TDD exercise at the Software Craftsmanship conference</A>
<DD>This article describe a constrained mode TDD where the implementation that makes the test passes is first written directly inside the test, hence without structural plumbing like methods or classes. The implementation moves to classes only with a set of restricted steps. I consider this a good exercise to test everyday assumptions while applying TDD, like right jump to create a class to make the test pass. The need for structural containment is discovered through testing exactly like the implementation details. As someone noticed in the comments, this style leads to a functional style of programming since the first encapsulation of code admitted are methods.

<DT><A HREF="http://www.infoq.com/presentations/Sustainable-Test-Driven-Development" ADD_DATE="1274254407" PRIVATE="0" TOREAD="0" TAGS="tdd,craftsmanship,design">InfoQ: Sustainable Test-Driven Development - Steve Freeman</A>
<DD>WIP
there is really a lot to learn from this presentation. Simple things if you want, but too often I think I'm a good practitioner of TDD while I have still so much to learn. WIP

<DT><A HREF="http://www.smashingmagazine.com/2010/05/15/why-a-tale-of-a-post-modern-genius/" ADD_DATE="1273998379" PRIVATE="0" TOREAD="0" TAGS="_why,ruby,kids">Why: A Tale Of A Post-Modern Genius - Smashing Magazine</A>
<DD>A nice write-up about the _Why persona, who he was and what he did in computer programming and arts. If ever had the need to send someone who doesn't know _why reading something about him, this is for sure a well written biography. _Why is another example (the other being Alan Kay) of person who was inspired by young people for their programming activities, treating them like &quot;customers&quot;. There is definitely something to learn looking at kids while they try to force a system to do what they want. Their naivety is almost impossible to replicate in our adult world but it is fundamental in interaction design. So if you have a kid, don't miss the opportunity to watch him/her closely while they learn because it's an invaluable source of inspiration.

<DT><A HREF="http://www.useit.com/alertbox/ipad.html" ADD_DATE="1273522791" PRIVATE="0" TOREAD="0" TAGS="ipad,ux,interface,usavility">iPad Usability: First Findings From User Testing (Jakob Nielsen's Alertbox)</A>
<DD>Hard to believe, but the iPad's bigger screen poses serious challenges to interaction designers. I'd be tempted to say it's just a bigger iPhone, no big deal but that's not the case. On the iPad the text that is big enough to read is not big enough to tap, for example. Another problem that the bigger screen seems to aggravate is the lack of a strong touch interface standard and users get confused on what to expect when tapping. About swiping: should you swipe   bottom to top or right to left to scroll? The screen format doesn't help to discover what on the iphone is evident. Personally I found the same issues on the iPhone as well. For example, a great application like Stanza always confuses me when I try to reach the homepage with the book index. I always end up on the topic list for the current book.

<DT><A HREF="http://37signals.com/rework/" ADD_DATE="1272974912" PRIVATE="0" TOREAD="0" TAGS="books">REWORK: The new business book from 37signals.</A>
<DD>The book by 37signals is not saying a lot of new stuff. But it's not a surprise. I'm an avid reader of their blog and followers of podcasts and presentations by DHH, Jason Fried and friends and they talk constantly about what was condensed in this book. Nevertheless this is a good reading. First of all is not easy to express what creates a profitable company in a succinct way like they did. Second, I like the format: small illustrated chapters that you can read easily. Of course there was also something to learn. Reading the history and motivation behind the success of whatever human endeavor gives a lot of insight for current projects and the book is full of great examples. Favorites: focus on what won't change, underdo your competition, four letter words.

<DT><A HREF="http://markupslicer.com/" ADD_DATE="1272522842" PRIVATE="0" TOREAD="0" TAGS="tools,markup,partial,css,html,template">markupslicer | Slice your HTML/CSS markup into Ruby on Rails templates</A>
<DD>Just a great idea. This service allows you to automate that repetitive action of splitting a web page into functional areas that are then worked separately. This includes also css tags, a time waster every time I need to think a name for a section. I can see it especially useful to extract partials for a Rails application but other frameworks will be supported soon.

<DT><A HREF="http://www.threeriversinstitute.org/blog/?p=488" ADD_DATE="1272487918" PRIVATE="0" TOREAD="0" TAGS="xp,deploy,build,production">Three Rivers Institute » Blog Archive » Continuous Deployment Immersion</A>
<DD>Nice. This should be called Extreme Deployment and be part of the Extreme Programming practices set. What Kent describes here gives you a method to move the build process to continuous deployment step by step the hard way. Why? Search my other links, there are a few talking about lean startup thinking and when continuous deployment makes a lot of sense: essentially to move the product more close to what the customer wants instead of what you think they need.

<DT><A HREF="http://blog.businessofsoftware.org/2010/02/what-will-happen-when-a-software-company-downs-tools-for-a-week.html" ADD_DATE="1271864202" PRIVATE="0" TOREAD="0" TAGS="productivity,motivational,enterprise,company">What will happen when a software company downs tools for a week? - Business of Software Blog</A>
<DD>Here's an expanded version of what Relevance is doing every Friday. With a week available to create something which doesn't need to be related with your company current stream of revenue, what will you do? I have plenty of ideas and the fact that your company supports you is nice. But as someone said in the comments, it should probably be expanded to whatever you have in mind, company related or not, open or closed source. In my opinion it is a win-win even if the whole company contributes to open source projects for a week. It's an huge return of image, free advertisement and word of mouth and not only. What was contributed outside the company will return in as side thinking, new knowledge and ideas. Well done anyway, although it should sounds more like a practice for the long term instead of something to try once a year. Hope they'll consider this for the time being.

<DT><A HREF="http://techcast.chariotsolutions.com/index.php?post_id=604618" ADD_DATE="1271769352" PRIVATE="0" TOREAD="0" TAGS="panel,debate,tiobe,jquery,css,philly">Chariot Tech Cast - Battle of the Frameworks II</A>
<DD>An interesting debate. I don't usually like panels because they are too broad and unfocused. This is an exception but the panel is not interesting for the web framework discussion itself (which is just a little more than a marketing pitch) but for the several unrelated topics in between. JSF is a hostile abstraction web framework because it brings too far away from HTML in a unnatural way. &quot;Successful languages like Objective-C or JavaScript are really abominations&quot;, while framework like JQuery are there to fix ten years old problems of browsers and make it a modern language. CSS flexible boxes, dom local storage and other HTML 5 tricks are not yet organically explained in tutorials to build up complete applications. The TIOBE index is bullshit because it reflects the inability of search engine to return coherent results when the language name is not enough (like Go for example or Prototype that requires an additional &quot;programming&quot; term). And much more, enjoy.

<DT><A HREF="http://news.ycombinator.com/item?id=1262467" ADD_DATE="1271511549" PRIVATE="0" TOREAD="0" TAGS="">Hacker News | HN Contractors: Add Yourself</A>
<DD>A resource of valuable information, like rates and what people are up to for their contracting activity, with emails and web sites. This list helped me understand how to adjust my actual rate and also gave me an opportunity to look at web sites of people I value like the HN community.

<DT><A HREF="http://www.xent.com/pipermail/fork/Week-of-Mon-20091109/054578.html" ADD_DATE="1271255158" PRIVATE="0" TOREAD="0" TAGS="programming,languages">[FoRK] Programming languages, operating systems, despair and anger</A>
<DD>Ah ah, enjoyed this one. There is definitely truth in the rant. Especially the fact that many if not all main stream languages are more written for computers than humans, with some noticeable exception in languages like Ruby or Python. The point to take away from the post in my opinion is that language design should take into account the list of all the common programming tasks listed here. It looks that we need again another layer of abstraction on top of programming languages, something similar to a DSL where the domain is day to day programming for an average application. Good stuff.

<DT><A HREF="http://www.slate.com/id/2249562/entry/2249563/" ADD_DATE="1271058179" PRIVATE="0" TOREAD="0" TAGS="productivity">I'm quitting the Internet. Will I be liberated or left behind? - By James Sturm - Slate Magazine</A>
<DD>An interesting reading with thoughtful comments. I went information diet myself and from that short 15 days experience I understood a lot about my mistakes. I also realized that the all-or-nothing is not a solution. I need and I enjoy to keep up with the Internet buzz. But I understand who needs to quit completely, at least temporary, to understand where the limit is, as in this blog post.

<DT><A HREF="http://www.se-radio.net/podcast/2010-04/episode-159-c0x-scott-meyers" ADD_DATE="1271003861" PRIVATE="0" TOREAD="0" TAGS="languages,java,cplusplus">Episode 159: C++0X with Scott Meyers | Software Engineering Radio</A>
<DD>So even C++ gets lambdas, type inference and power support for concurrency (along with the other features added in this last re-incaranation). As I heard already a few times, Java is apparently dead. When lambdas will be included in Java most of the developers will be already using Scala or Groovy. The JSR is a remarkable high ceremony process that forces people to create their own flavor of Java with the features they miss the most.

<DT><A HREF="http://daringfireball.net/2010/04/iphone_agreement_bans_flash_compiler" ADD_DATE="1270810337" PRIVATE="0" TOREAD="0" TAGS="iphone,macruby,buzz">Daring Fireball: New iPhone Developer Agreement Bans the Use of Adobe's Flash-to-iPhone Compiler</A>
<DD>Maybe not only Flash. What about MacRuby? This is an high risk move from Apple. True, they can protect the quality of the product and avoid third parties to create tools that can compile down iPhone, Android and other platforms at the same time like Titanium. On the other hand, other languages are more expressive and maintainable than Objective-C giving iPhone app a quality boost. Although I'm developing iPhone in Objective-C it sounds to me like nonsense. I'd like the option to use the right tool for the job and maybe Objective-C is not always the right tool. I'm worried that Apple will stop the MacRuby team on working on an explicit garbage collector, thus preventing MacRuby to run on the iPhone.

<DT><A HREF="http://thisweekin.com/thisweekin-startups/twist-46-with-david-heinemeier-hansson-2/" ADD_DATE="1269389278" PRIVATE="0" TOREAD="0" TAGS="business">TWiST #46 with David Heinemeier Hansson</A>
<DD>Here we go. Every once in while there is something you can't miss. Two interpretations of capitalism (or maybe just one is and the other is not): the one that Calacanis defines old school and maybe European is in my opinion the new school or the anti-american school. David explains perfectly well what the differences are, but I think it all comes down to the presence of an upper limit. With no limit, the model is to raise money and move to something else to raise possibly more money, often by creating a bubble of expectation and excitement made of meaningless metrics. The other way (David) gives less prominence to money accumulation and more importance to searching the best idea to implement, an healthy life style and real profit. Overall it means doing business with the idea that when your income is enough to afford everything, there is no need to raise more money just because you can. With a nice side effect: better wealth distribution overall.

<DT><A HREF="http://danieltenner.com/posts/0017-how-to-nap.html" ADD_DATE="1269386758" PRIVATE="0" TOREAD="0" TAGS="nap,productivity">danieltenner.com — How to nap</A>
<DD>Glad to see I'm not the only exercising how to nap. It also took me some time to get to the point where I'm now. My experience is very similar to the one described in this post. I still use sometimes white noise tracks from 20 to 30 minutes based on the mood of the moment. And yes, never ever go over 30 minutes, or you risk drowsiness as described here. Something I'm doing lately after the muscles relaxing focus part, is to focus my thinking to someone walking and just visualizing the legs and almost nothing about the surrounding of the scene. Sometimes it takes some effort, but apparently it puts the brain on some useless thinking that removes other thoughts and prepare for napping. At least, this works for me!

<DT><A HREF="http://startuppodcast.wordpress.com/2009/12/28/show-49-eric-ries-lean-startup-and-productmarket-fit/" ADD_DATE="1268317135" PRIVATE="0" TOREAD="0" TAGS="business,startup,lean">Show #49 Eric Ries, Lean Startup and product/market fit « The Startup Success Podcast</A>
<DD>You should really listen to this one. Eric is great explaining what this is all about and I very enjoyed his clarity. The relation to acceptance tests idea is mine though. So: continuous deployment + production cluster + revenue metrics and an automatic halt and revert system for production is the recipe to drastically reduce the importance of acceptance testing. The scary part is that we are accepting and embracing the fact that bugs will make it to production even if we fight them hard (it will happen anyway). By gradually deploying to a cluster if there are bugs only a small portion of our customer will find out. The presence of a &quot;revenue&quot; metric will trigger the revert button automatically, reducing the loss to the bare minimum. By accepting the risk of some bugs passing to production we can leverage a very tight customer feedback loop and learn very early how to change direction to achieve market fit. This works well for startups, where the kernel idea need to be validated ASAP.

<DT><A HREF="http://en.wikipedia.org/wiki/QR_Code" ADD_DATE="1268301770" PRIVATE="0" TOREAD="0" TAGS="freelance,business">QR Code - Wikipedia, the free encyclopedia</A>
<DD>Thinking seriously to place this on my business card. Slick and if you have a modern phone, readable!

<DT><A HREF="http://blog.eizesus.com/2010/02/using_sintara_to_test_remote_services_in_rails-27-2-2010/" ADD_DATE="1268300822" PRIVATE="0" TOREAD="0" TAGS="testing,stub,http,mock">Emphasized Insanity - Using Sinatra to test remote services in Rails</A>
<DD>In my last project I had a lot of stubbed request response to stub out web services like S3 or MTurk. I did everything by hand and it was not difficult, what is difficult is to reproduce the call and dump the raw response when you realize you need just another slightly different test case. For the next time I'd like to user something like FakeWeb or this Sinatra server built on top of it. Recording and storing should be much easier and repeatable improving the maintenance of integration tests with stubbed web services.

<DT><A HREF="http://vimeo.com/4971984" ADD_DATE="1267711038" PRIVATE="0" TOREAD="0" TAGS="ux,design,iphone">Sketchnotes iPhone Tapstack App by SixVoices</A>
<DD>An interesting case of a company (SixVoices) selling a product which is an User Experience concept. The idea is then adapted and implemented down to iPhone apps like this one to illustrate sketchnotes. The concept is to reproduce with the iphone what happens to a stack of cards or pages when they are on a table and can be browser with your finger. The effect is very intuitive.

<DT><A HREF="http://www.rohdesign.com/weblog/archives/003086.html" ADD_DATE="1267709814" PRIVATE="0" TOREAD="0" TAGS="productivity,sketching">About Mike Rohde's Sketchnotes</A>
<DD>Here is a concise introduction to sketch notes. Mike Rohde explains the process and tools needed. What is actually amazing considering the quality and quantity of details of the illustrations is how this can be done realtime while possibly paying attention to the presentation. I think at least at the beginning I'd be completely absorbed by the sketching part. Maybe start incrementally: just writing, then a few geometrical sketches, then some more typography and fonts to create the finger memory. Anyway,

<DT><A HREF="http://37signals.com/podcast/#episode9" ADD_DATE="1267709476" PRIVATE="0" TOREAD="0" TAGS="book,37signals">37signals Podcast - Rework</A>
<DD>A few simple annoying facts about business books (and sometimes not only business) which I agree with in this interview about the soon to be published 37signals book. Very often the main topic of the book is thoroughly explained in the first 60 pages which by them selves sell the book. Money well spent and a lot of a-ha moments. The remaining 250 pages &quot;rework&quot; the same topic killing completely my interest in the book. Unfortunately there could be the same treatment at the beginning too and this is enough to abandon the book right away. The second are those 15+ pages before chapter 1, with 20% interesting contents. But I hate prefaces (why I wrote the book, why I decided to republish the book, etc) copyrights and so on. Needless to say, &quot;Rework&quot; refused the format in both cases. I knew also about Rohdesign, the mind behind sketchnotes. This reminds me of the importance of engaging right brain thinking using all the possible senses. Wondering if to use the technique for my learnings.

<DT><A HREF="http://rubyconf2009.confreaks.com/20-nov-2009-15-05-solid-ruby-jim-weirich.html" ADD_DATE="1267656036" PRIVATE="0" TOREAD="0" TAGS="ruby,patterns,design,solid">Confreaks: RubyConf 2009 - Solid Ruby Jim Weirich</A>
<DD>I'm always sure that whatever presentation by Jim will teach me something. I had the opportunity to reflect on a few important facts. Changing behavior by monkey patching is dangerous because it is triggered by a require statement at the beginning of a file which nothing has to do at least apparently with the patch. It triggers unexpected behavior. Changing by subclassing instead depends on the type of the instance receiving the message which usually is dependent on the instantiation context and therefore planned more carefully. There are no enforced interfaces in Ruby as for example in Java. But there is an implicit protocol to obey which has more to do with discipline. The protocol is in the documentation and parameters name, much more freedom, no need for ceremony with interfaces. A protocol is basically a subset of the methods of a class. So in Ruby OCP and DIP does not need the creation of a new interface to invert dependencies.

<DT><A HREF="http://www.mobileorchard.com/podcast-interview-with-oceanhouse-media-brands-and-their-impact-on-volume-and-price/" ADD_DATE="1267608546" PRIVATE="0" TOREAD="0" TAGS="iphone,marketing">Podcast Interview With Oceanhouse Media Brands And Their Impact On Volume and Price</A>
<DD>One reason to choose volume over complexity in the app store is discoverability: many apps in the app store makes more likely to be found. The app store is a search engine: we need SEO kind of rules. Simplicity is the key, not necessarily low-quality. A working iphone prototype is the new business card to catch the attention of the next customer. After 80+ apps created their experience is you can't predict what will sell the best. The development effort should be 3-4 weeks to minimize the impact of low number of units sold. You accept 3-4 months project only when you know is a guaranteed seller.

<DT><A HREF="http://hanselminutes.com/default.aspx?showID=218" ADD_DATE="1267451786" PRIVATE="0" TOREAD="0" TAGS="versioning,stackoverflow,focus">Jon Skeet - World's Greatest Living Programmer</A>
<DD>Heard an interesting and simple trick to make 2 services built on top of the same API but supporting different versions. If the version of the response retrieved by the server is not the wanted one, the client can make a second request of translation with downgrading of the default version to the previous one (for example). The service that upgraded the version of the API is supposed to provide the translation service and to know how to downgrade the response version (when applicable). Jon then tells us how he achieved the best contributor status on StackOverflow. There is really nothing surprising here, he doesn't plan for a daily StackOverflow session. He just fills all the possible holes during his working day with StackOverflow, that's it. As simple as it sounds, being really focused on only one or few goals is the key for success. The problem is learning how isolate from all the possible external distractions. Pomodoro rules.

<DT><A HREF="http://railscasts.com/episodes/199-mobile-devices" ADD_DATE="1267450935" PRIVATE="0" TOREAD="0" TAGS="iphone,jqtouch,rails,mobile">Railscasts 199 - Mobile Devices</A>
<DD>Pretty impressive here the ease you can setup your Rails web app to serve better content for a mobile device or even completely look like a mobile device with JQTouch. You can start by just a better looking UI by defining a css which is only triggered when the user agent matches a certain string. You can create an helper method for that. If you want a link to switch back and forward from mobile to normal version, you need to save which UI you're on in the session. If you need instead the pages to look different beyond what a CSS can do, you need a custom template for a specific new format. When the page is called with the new format (.mobile instead of .html) a completely different layout is triggered. JQTouch can be used at this point only for the mobile layout to render the application very similar to a native iPhone interface. This is all concisely and beautifully explained by Ryan Bates in this screencast. Enjoy.

<DT><A HREF="http://www.infoq.com/interviews/bryant-smalltalk-trendly" ADD_DATE="1251600736" PRIVATE="0" TOREAD="0" TAGS="clamato,javascript,smalltalk,trendly,bryant">InfoQ: Avi Bryant on Trendly, Ruby, Smalltalk and Javascript</A>
<DD>Here's a dense and worth remembering interview full of bleeding edge technological aspects and also a brief state of the art of Smalltalk and Squeak. Avi talks about their last product, a time series analysis tool that grab its data from Google Analytics. The problem is typically solved by a batch-like processing on the server side which is suitable for a multi-language approach. Trendly uses a mix of Smalltalk, Ruby and Java on the server side, a good example of better tool for the job: Smalltalk is for the core server logic, Ruby is used to interface with the operative system, Java is for performances. Another interesting fact is that the server only produces images and json and all the rendering logic resides on the client in Javascript. From the need of creating tons of JS Avi forked Clamato.net, a Smalltalk like language that can generate JS. The tool is self-contained (the language is parsed in Javascript) and can be used totally in the browser. A coolness concentrate.

<DT><A HREF="http://www.se-radio.net/podcast/2009-07/episode-140-newspeak-and-pluggable-types-gilad-bracha" ADD_DATE="1248954795" PRIVATE="0" TOREAD="0" TAGS="newspeak,dynamic,static,typing,languages,programming">Newspeak and Pluggable Types with Gilad Bracha - Software Engineering Radio</A>
<DD>Here's the best analogy so far comparing static type system VS dynamically typed system. In a static type system applies something similar to the &quot;presumption of guilt&quot; from the Napoleonic Law: the compiler stops the program (guilty) if the program doesn't comply to the type system even if it makes perfectly sense at runtime. The compiler can't prove the program is &quot;innocent&quot;, so it has to be wrong! In dynamically type systems the program is allowed to run and judged only after the facts. Statically typed languages are therefore more restrictive but this doesn't imply they are more &quot;secure&quot;. Second: the type system is similar to a BDUF (big design upfront) and restricts the possible uses of the language to what it was designed for: have you tried AOP in Java and then in Ruby? Dynamic languages accommodate &quot;side&quot; uses more easily. The rest of the podcast is centered around the features of NewsSpeak, an interesting language that deserves attention.

<DT><A HREF="http://www.infoq.com/presentations/sieger-jazzers-programmers" ADD_DATE="1248902473" PRIVATE="0" TOREAD="0" TAGS="jazz,programming,improvisation,practice,craftsmanship">InfoQ: Jazzers and Programmers</A>
<DD>This is mostly about jazz than programming. But I appreciated the concise history of my favorite music with examples, quotes from great musicians and a little theory. I'd certainly point someone to this presentation to have a quick introduction to Jazz. There is a clear parallel between Jazz and programming. Something common is the need for continuous practice in both. We call this &quot;software craftsmanship&quot; and apparently developers of our times don't practice often enough. I also think that there is less room for improvisation in programming than Jazz. Most of the time in programming you have to follow rigid rules (like classical music) and the real improvisation is when a tool or technology is used in a different and unexpected context, like for example Erlang for mutli-core CPUs.

<DT><A HREF="http://alexander.letmego.com/2009/07/29/how-productive-was-the-letmego-immersion/" ADD_DATE="1248897499" PRIVATE="0" TOREAD="0" TAGS="startup,team,productivity,debt">How Productive Was the LetMeGo Immersion? « Alexander’s Blog – The Making of LetMeGo</A>
<DD>From one side I can only admire what a small team was able to accomplish. From the other I can't stop thinking that this project is seriously screwed. Just the fact that you're forced to a 90 days 24/7 with something like 12 hours working day to produce a partial beta smells bad. I understand how this can be a wonderful experience. But I suspect they accumulated an huge pile of technical debt. If I were an investor I wouldn't invest in LetMeGo because it seems like a bomb ready to explode right after a few months of exercise. I could be wrong of course, or just envy because when you have a family you're done with this kind of things. All the best to the project, we'll see.

<DT><A HREF="http://www.hanselman.com/blog/HanselminutesPodcast171TheReturnOfUncleBob.aspx" ADD_DATE="1248352357" PRIVATE="0" TOREAD="0" TAGS="unclebob,podcast,interview,professionalism,craftsmanship,discipline,ritual">Hanselminutes Podcast 171 - The Return of Uncle Bob</A>
<DD>This time Uncle Bob talks about professionalism. IT industry is amateurish to some extents and lacks the same level of professionalism of other professions. Rituals can be a measure of professionalism, since they are the result of a consolidated discipline. Of course you try not to abuse rituals and loose the intent behind the discipline (like completely skip design to jump right into testing, see Jim Coplien). After talking about the need for architects to also be developers to feel the pain they are asking for, Uncle Bob also speaks about the density of a language, intended as the concentration of meaning for a single word or even a single character. See the nice Game of Life in APL screencast that illustrates the concept here: http://www.youtube.com/watch?v=a9xAKttWgP4. I especially like this quote from Uncle Bob: &quot;I want them to find me with my nose stuck between the keys of the keyboard&quot;. Yeah, code code code.

<DT><A HREF="http://www.infoq.com/presentations/katz-couchdb-and-me" ADD_DATE="1248182655" PRIVATE="0" TOREAD="0" TAGS="video,couchdb,erlang,motivational,rubyfringe">InfoQ: CouchDB and Me - Damien Katz</A>
<DD>This is a great presentation, one of those you see once or twice in a year. It's great not for the technical content  but mainly for the life lesson it gives. Damien was laid off, he had to move to a cheaper place and start all over with two growing kids. How do you find the motivation to grow your own idea and live on savings while nobody cares about you and your work? The answer to this question is the main message of the talk. This is how CouchDB got started. Damien also talks about choosing Erlang and JSON over HTTP and some more technical aspect. Simple and regenerating talk.

<DT><A HREF="http://www.hanselminutes.com/default.aspx?showID=187" ADD_DATE="1247567986" PRIVATE="0" TOREAD="0" TAGS="tdd,podcast,audio,interview,mock,setup,stub,testing">Hanselminutes Podcast 169 - The Art of Unit Testing with Roy Osherove</A>
<DD>An interesting podcast again from Hanselminutes. And again about unit testing. Here's some take away: if you have tear-downs in your tests those are probably integration tests. If you have class based setup tear-down again those are probably integration tests. If you do a lot of corner cases testing around a method, you're probably doing after-the-fact testing. A good definition of mock object: if you're setting expectations on an object which is not part of the project, that object is a mock. You don't make assertion against a stub for example. When do you stop testing? When you're comfortable with it, that is, when all the ideas about how the software should behave have been implemented. And of course you should stop at the most interesting cases without over-specifying.

<DT><A HREF="http://www.mobileorchard.com/push-notification-store-kit-an-interview-with-urban-airship/" ADD_DATE="1247143622" PRIVATE="0" TOREAD="0" TAGS="iphone,podcast,audio,sdk,api">Push Notification &amp; Store Kit - An Interview With Urban Airship</A>
<DD>Here's an interesting discussion that explains the technical details of two new capabilities of the iphone sdk 3. Push notification is a stay resident application running on the iphone capable of receiving messages and dispatch them to other applications. There is a server side notification service involved with persistent queues maintained by Apple. The Push Notification removes the need for an app to poll a server remotely dragging the batteries out using a persistent IP connection. The store kit is an API that allows iphone apps to present mini-stores to their users to buy additional capabilities. Interestingly enough, there are companies like Urban Airship producing intermediate layers (or a server with an application on top of it) because the whole process requires  good programming and administration skills. Kudos to Dan Grisby for the very good questions.

<DT><A HREF="http://javaposse.com/index.php?post_id=493300" ADD_DATE="1246036484" PRIVATE="0" TOREAD="0" TAGS="hiring,interviewing,people,personality,skills,agile">The Java Posse - Staffing Agile Teams</A>
<DD>Interesting panel. I think Barry Hawkins is the chair master (http://www.yepthatsme.com/) and he's the one  saying the most interesting things. Overall the talk illustrates different personality types for agile programmers and what to search for to staff agile teams. Sometimes is necessary to turn down awesome skilled people if they don't fit into the team. For example ability to cooperate must be just the right level: humility is important as well as not over-cooperate (questioning too much about team choices instead of having things done). Prefer people you need to bring up to speed in 3/4 weeks instead of skilled people that you can't unlearn if they are assholes. Inefficiencies of the interviewing process can be exploited by contracting to hire. Problems are a certain kind of super-stars: they give the illusion f productivity creating unnecessary complexity that they only can understand. Sometimes you just need some more courage to let go people that are not a good fit.

<DT><A HREF="http://olabini.com/blog/2009/06/videos-from-the-chicago-acm-ioke-talk/" ADD_DATE="1245213650" PRIVATE="0" TOREAD="0" TAGS="ola,ioke,languages,compilers">Videos from the Chicago ACM Ioke talk | Ola Bini: Programming Language Synchronicity</A>
<DD>This is a very nice presentation. I was there in person and I think Ola was giving his best. Of course Ioke is Ola's little kid, who wouldn't be thrilled to talk about it? Sure enough the talk is about the language, but there are interesting cross-language considerations. I realized how specific is the domain of languages, it really requires you to be into it to understand everything. For this reason, Ioke is a good teaching language because it's all about language theory than for example, performances or concurrency. Final note: stating that all other languages are crap is not fair, even from the point of view of expressiveness which is subjective matter. If expressiveness of a language is the deviation from the idea you have in mind and what actually can be coded, then also Ioke is crap to someone who of doesn't think the same as Ola.

<DT><A HREF="http://www.javaworld.com/podcasts/jtech/2009/060209jtech-zilker-terracotta.html" ADD_DATE="1245211953" PRIVATE="0" TOREAD="0" TAGS="terracotta,enterprise,java,provisioning,vmware,deploy">Ari Zilka on Terracotta's VMware integration</A>
<DD>Again on Terracotta. In this episode there are again interesting solutions to remember. Terracotta partnered with VMWare to distribute enterprise Java applications in VMs. The side effect is the one click provisioning model, where instead of the tarball you install an image that freezes completely the environment so you don't need to fight with compatibilities issues. It also turns out that multiple instances of the same app running on the same big server is a better hardware optimization than having the same instances running on different physical hardware. So instead of 100 servers, maybe you have only 20 running 5 VMs each with the same image. Now this has nothing to do with Terracotta in specific, it's just their actual selling pitch. The Ruby hosting world has indeed moved to the same model, calling them slices, dynos, nodes and so on.

<DT><A HREF="http://web20show.com/episodes/episode-19-david-heinemeier-hansson" ADD_DATE="1245157364" PRIVATE="0" TOREAD="0" TAGS="inspiring,business,dhh,interview,podcast,rails,37signals">The Web 2.0 Show - Episode 19 - David Heinemeier Hansson</A>
<DD>Once again I enjoyed listening to the story of DHH and 37Signals flagship products. This time I heard a little more about the personal history starting from the 2000 or around. It's inspiring and motivational. The idea I got about the success of Rails is that is based on pure execution, that is, given a technology that doesn't get in your way and an idea on how to improve a bit the quality of life, a pragmatic approach makes it a success no matter what. Doh, sure that is a known fact, but VCs and the Valley style pushes to another direction. DHH gives a good reason why it's time to start a software business: it requires just your time, the hardware is cheap, an office is less important when the network enables distributed collaboration easily. In other word, you don't need a huge investment to start with, just 3 months of your nights and weekend. Of course is not easy, but at least you know that depends just on you.

<DT><A HREF="http://www.vimeo.com/4335944" ADD_DATE="1244833085" PRIVATE="0" TOREAD="0" TAGS="css,blueprint,compass,design,layout,ui,screencast">Compass: A Real Stylesheet Framework</A>
<DD>Here's a very nicely done screencast on how to jump start quickly on a web page design based on sass, blueprint and compass. Chris is kind enough to explain basic concepts, when to use id or classes, sass basics, how to organize your project and so on. The power of mix-ins in sass is great and makes thing quick and easy. As Chris says at some point, you can write your self most of these stuff, but why? Sass generation is unobtrusive and sass template are very readable. The grid system is a breeze once you understand how to attach the column width information to divs. All pretty easy stuff. Thanks for the great screencast.

<DT><A HREF="http://railsconf.blip.tv/file/2081411/" ADD_DATE="1244747978" PRIVATE="0" TOREAD="0" TAGS="rails,opinionated,custom,dhh,railsconf">RailsConf 09 DHH Rails 3</A>
<DD>I think it's the second time I heard about custom attributes in HTML 5. Rails 3 is going to use custom attributes to signaling the framework how to build the javascript actions connected to events, like onclick(). Remains to understand when the transition will actually happen for legacy browsers. Another interesting thing is the rewriting of generators so that scaffolding can be tailored for the particular choice of javascript library, ORM mapping strategy and so on. Rails is still opinionated with defaults but it should be easier to coexist with different opinions.

<DT><A HREF="http://www.cincomsmalltalk.com/blog/blogView?showComments=true&printTitle=Industry_Misinterpretations_138:_Who_Killed_What&entry=3421246603" ADD_DATE="1244575820" PRIVATE="0" TOREAD="0" TAGS="smalltalk,unclebob,languages,keynote">Industry Misinterpretations 138: Who Killed What</A>
<DD>Interesting response here to Uncle Bob &quot;who killed SmallTalk&quot; keynote. If you skip the discussion about the definition of &quot;dead&quot; which is useless in my opinion, I like the &quot;renaissance&quot; model in which a powerful language which is no more fashionable at some point, becomes mainstream again for some unexpected conjunction of facts. At least this is the hope of the SmallTalk community. I don't know if that could happen though, considering that SmallTalk evokes old technologies that didn't work (being that true or not). What maybe is possible is the re-incarnation of SmallTalk with a different name, exactly like old good marketing rules tell us all the time.

<DT><A HREF="http://www.engineyard.com/blog/community/scotland-on-rails/page-2/" ADD_DATE="1244512592" PRIVATE="0" TOREAD="0" TAGS="ruby,objects,languages,simula,smalltalk">Scotland on Rails 2009 - The Ruby Object Model - Dave Thomas</A>
<DD>This is basically the screencast no.1 from the pragcasts made up as a presentation. I viewed that again with pleasure because Dave is a great speaker and the topic is always hot. Ruby is strictly object based as it should be for an OO language. The strange thing is that passing the time the pure OO heritage has been lost starting from C++, Java and the rest that came after. In those languages a Class is not an object but only something that the compiler knows what to do about it. In Ruby class are just &quot;simulated&quot; as interaction between objects that contain methods and a pointer to the &quot;parent&quot;. This is the reason of the great flexibility of Ruby, everything is an object model and can be accessed anytime.

<DT><A HREF="http://www.martinfowler.com/bliki/IntentionalSoftware.html" ADD_DATE="1244462020" PRIVATE="0" TOREAD="0" TAGS="dsl,video,intentional,workbench">MF Bliki: IntentionalSoftware</A>
<DD>I finally took some time to see Intentional demo of their Intentional Domain Workbench. DSL workbenches are a fascinating topic these days and there is sure potential in our industry. The typical use case for DSLs is medium to high complexity business logic that usually is described by business analysts in a non-executable formats. The workbench can be used to maintain the sync between the generated DSL and the business view of rules. Why not using user stories like the rest of the application? Because the business logic is so complicated that it requires a detailed description and verbal communication is not enough. With a DSL workbench duplication between the Word documents and the actual code is eliminated by using an abstract language that describes the domain. Just be careful: the presentation talks generically about &quot;creating software&quot; without specifying that we are talking about the DSL portion of it. Don't use these products to generate the whole application!

<DT><A HREF="http://www.se-radio.net/podcast/2009-05/episode-136-past-present-and-future-mda-david-frankel" ADD_DATE="1244229029" PRIVATE="0" TOREAD="0" TAGS="mda,modelling,dsl,architecture">Episode 136: Past Present and Future of MDA with David Frankel | Software Engineering Radio</A>
<DD>MDA is presented in this podcast as the evolution of UML which with after the introduction of OCL was trying to be more specific and semantic. Sorry, I just don't get it and what I hear is pure fluff. As far as I can understand, MDA is trying to be a visual language for languages. Components can be specified using MDA and the code generated accordingly. In the opinion of David Frankel abstractions are emerging from different industries and similar tools are created to model the application. From what I can remember, this was going on for decades, but we never had the power of building the big unifying abstraction to describe all business components.  And by the way, what is wrong in choosing a language and evolve reusable components and stick with it for, say, 5 years? Then I throw everything away and switch to the next language, so what? I understand using DSLs to describe portions of an application, but I don't understand why I should create the whole application as a DSL or MDA.

<DT><A HREF="http://www.hanselman.com/blog/HanselminutesPodcast163SoftwareMetricsWithPatrickSmacchia.aspx" ADD_DATE="1244161065" PRIVATE="0" TOREAD="0" TAGS="metrics,podcast,audio,quality">Hanselminutes Podcast 163 - Software Metrics with Patrick Smacchia</A>
<DD>Interesting talk on metrics here. It's always good to remember the there are good and simple metrics that cover most of the cases without the need of an exotic mathematic formula. For example lines of code by feature can reveal unwanted complexity for comparable features. Another interesting one is loc covered by test ratio. Loc is not enough to guarantee quality of code. Cyclomatic complexity can be used to spot difficult-to-maintain code. While too high afferent (incoming) coupling (Ac) means probable SRP violation and it's time to extract one/many interfaces to create dependency on abstractions. There are also composed metrics: CRAP is one or the maintainability index. But these are numbers without dimensions and it's is easy to expose false positives because of their complexity. A new one I learned here is the MethodRank, the rank algorithm applied to the method dependencies tree. At the top there are methods which should be tested more carefully because of their high dependency.

<DT><A HREF="http://lifehacker.com/5109653/david-allens-making-it-all-work-a-new-look-at-gtd" ADD_DATE="1243546094" PRIVATE="0" TOREAD="0" TAGS="productivity,pace,rhythm,gtd,chart,perspective,control">Lifehacker - David Allen's Making It All Work a New Look at GTD - David Allen</A>
<DD>Interesting chart here. On the axis, perspective and control. The 4 resulting quadrants are very typical situations for everyone of us. High perspective means knowing at a glance everything that we want to have done and knowing that nothing is outside that list. Control means that we decide the priority of execution and how to manage that list. Low perspective, low control, means poor slave. High perspective high control means &quot;captain &amp; commander&quot; of you life. You go crazy when even if you maintain your high perspective you don't follow your plans. I'm 80-90% in commander state but sometimes I fail and go &quot;crazy&quot; state. The main reason for that remaining 10-20% achievement is lack of sustainable pace because it happens almost only when I'm tired.

<DT><A HREF="http://en.wikipedia.org/wiki/Gpgpu" ADD_DATE="1243454178" PRIVATE="0" TOREAD="0" TAGS="gpu,parallel,processing,computation,stream,grid">GPGPU - General Programming GPU</A>
<DD>There's a lot of interest in what GPU can do other than processing vertexes these days. It is pretty much the case that your actual computer is already equipped with a &gt; 200 cores underutilized GPU (unless you play a lot of 3D games). NVidia and ATI already produces SDK to exploit this computing power other than games for highly parallel stream processing. So instead of off-loading high load computations to some external form of parallel processing you can think of just run them on the GPU with surprising results. GPUs are much more powerful than normal multi-core CPUs for parallel processing so it make sense to use them instead of conventional parallel architectures.

<DT><A HREF="http://www.43folders.com/node/47756/323765" ADD_DATE="1243453514" PRIVATE="0" TOREAD="0" TAGS="pomodoro,gtd,productivity,podcast,audio,interview,daveallen">Productive Talk Compilation: 8-episode podcast with GTD's David Allen | 43 Folders</A>
<DD>I've listened to this series back in time and I was curious to re-listen this conversation between Merlin Mann and David Allen about GTD to compare with the Pomodoro Technique. There are definitely lot of similarities. Basic principles are the same: avoid procrastination, focus on what is important and ultimately getting things done. But I see clear differences also: GTD focuses more on the collection phase while the Pomodoro Technique is more about execution and tracking. Thus the two technique mix together very nicely. Pomodoro doesn't say anything about how to empty your brain out or give a name on what is in your head or the organization into folders and context. On the other end GTD doesn't talk about prioritization processes or tracking to collect metrics. Also in the PT interruption handling is much more specific and reviews are daily. Last: GTD does way a better job at marketing the technique than pomodoros. That will change in the future, I think.

<DT><A HREF="http://www.hanselminutes.com/default.aspx?showID=179" ADD_DATE="1243368960" PRIVATE="0" TOREAD="0" TAGS="bbs,history,networking,im,chat">Hanselminutes - BBS era</A>
<DD>I'm really enjoying IT history lately and here's another interesting piece of the story. I was too young at the time of BBSs to remember, too bad. BBS are similar to our IM of nowadays but as said in the podcast there are big differences. At the beginning, the computer of the SYSOP had to be completely dedicated to maintain the connection and the SYSOP could see user actions, like painting screens and drawing text. As such it allowed a complete control over the communication channel, with the option of jumping right into the user screen to ask questions or offer for help. It remembers me of the difference between modern cars, all electronics and pre-assembled pieces and old cars that could be potentially torn apart with a screwdriver to be inspected easily.

<DT><A HREF="http://www.mobileorchard.com/interview-with-joe-hewitt-creator-of-facebook%E2%80%99s-iphone-app-the-three20-project-and-facebook-connect-for-iphone/" ADD_DATE="1242511909" PRIVATE="0" TOREAD="0" TAGS="iphone,audio,podcast,interview,facebook,hewitt">Joe Hewitt - Mobile Orchard</A>
<DD>Joe Hewitt, author of Firebug, moved to iPhone development lately with one of the most downloaded app from the AppStore, Facebook. Several core components from the Facebook app have been extracted and cleaned-up to become an open source collection of components called Three20. In this podcast Joe talks about the development details in Three20, html table cells without UIWebview, a Quartz based rich text editor for text field, an auto-resizeable text field and the popular photo chooser. I enjoyed the very technical conversation even if I'm not proficient with iPhone development. I immediately linked the Three20 project hoping to play with it soon. A good listening.

<DT><A HREF="http://www.threeriversinstitute.org/blog/?p=187" ADD_DATE="1242412369" PRIVATE="0" TOREAD="0" TAGS="testing,practice,craftsmanship,pragmatism">Kent Beck - To Test or Not to Test? That’s a Good Question.</A>
<DD>I also don't test for specific cases. When I don't it's because I'm missing the skills to test effectively, that is, in an easy and consolidated way. Let's take Rails view specs with rspec. I know how to spec them out very quickly, mocks, render directives and so on. Almost a no brainer. But there are other cases where it takes me a long time to figure out how to mock certain APIs, what methods should I call and how to organize the spec suite. So my rule became: if it's taking too long or it's too complicated fork a new task to spike and learn about it. But now ship it! It's brutal I know but usually that's the correct thing to do. Of course the meaning of &quot;too long&quot; is strictly project dependent. Then I put shame on me because I was missing a &quot;tool&quot; in my tool set so that next time I can't be taken by surprise. I know I need practice.

<DT><A HREF="http://www.wolframalpha.com/screencast/introducingwolframalpha.html" ADD_DATE="1242340121" PRIVATE="0" TOREAD="0" TAGS="wolframalpha,google,search,knowledge">Introduction to Wolfram|Alpha by Stephen Wolfram</A>
<DD>This is the screencast that introduced me to the work of Stephen Wolfram. Wolfram Alpha is an incredible piece of software, capable of correlations and interpretation beyond what I've seen so far. I'm wondering what kind of semantic engine is behind the web interface. This engine is capable of attaching meaning to the human knowledge and serve it at the speed of light. Google killer app? Nah, I don't think so. What you see on Wolfram Alpha is opinionated, a mash-up of related information that the engine thinks you may like. Wonderful if you want to infer knowledge from data you don't know about, less useful if you know what you're searching for. That's what Google is about when you input some words in the search box. Will it change the way we use the web? Again, I'm skeptic.

<DT><A HREF="http://en.wikipedia.org/wiki/Cellular_automata" ADD_DATE="1242339604" PRIVATE="0" TOREAD="0" TAGS="cellular,automata,algorithms,turing,wolframalpha,practice">Cellular automaton - Wikipedia, the free encyclopedia</A>
<DD>Looking at the WolframAlpha phenomenon I ended up wandering wikipedia reading about cellular automaton. I'm amazed by how complicated a model with simple rules can be. Very simple CAs like the monodimensional rule-110 are even turing complete. I also realized that the Langton's ant and Conway's Game of Life are to popular implementation of CAs. Some of these models are often seen in nature (predators, chaotic systems, population models etc.) and therefore is tempting to think that a basic combination of simple rules is responsible for biological life. What are those rules is the subject of Wolfram's book &quot;A New Kind Of Science&quot; which is already in my Amazon basket.

<DT><A HREF="http://www.se-radio.net/podcast/2009-05/episode-134-release-it-michael-nygard" ADD_DATE="1242162326" PRIVATE="0" TOREAD="0" TAGS="podcast,production,patterns,enterprise,sla,optimization,maintenance">Episode 134: Release It with Michael Nygard</A>
<DD>Sad: the book is standing on my bookshelf and I never managed to read it. Good: this episode remembers me what I'm missing. First: my knowledge of production systems just scratch the surface. For some reason in my career I always move when the system starts its life and that's not good. The podcast follows the book structure which is a nice to read patterns collection. Here's some interesting bite of the conversation. A system that self-adjusts or shuts down a specific feature when a functionality doesn't behave as from the SLA is better than timeout. Timeout usually creates more dangers. Ajax completion on key strokes is of low value and high server impact. I don't agree with this one, it depends on the application if this is low value. Caching can be good, but too much caching or caching done wrong can be dangerous. SLA inversion anti-patter: forgetting that SLA of dependent systems are correlated to the SLA of the main system. And much more. Recommended listening.

<DT><A HREF="http://railsconf.blip.tv/file/2089545/" ADD_DATE="1242156007" PRIVATE="0" TOREAD="0" TAGS="smalltalk,ruby,unclebob,talk,video,railsconf,inspiring">RailsConf 09: Robert Martin, &quot;What Killed Smalltalk Could Kill Ruby, Too&quot;</A>
<DD>I always enjoy to hear interesting pieces of computing history and Uncle Bob is clearly a skilled storyteller. It must be fun (and also sad when you realize how old you are :) to write talks adding pieces of your personal history.

What killed Smalltalk? It was too easy to make a mess. But also: image without source files, not free, competing implementations. Also a wrong attitude: Smalltalkers thought their language and tools were so good that they don't need to be compliant with the typical corporate IT infrastructure.

The presentation is a concentrate of great thoughts. What is clean code? Is code that reveals what it does by reading it. If the WTF/min is != 0 is not clean. Ruby risks the same because it's powerful. What can we do? Craftsmanship. Leave the campfire cleaner than you found it. A collective effort to maintain the code clean should save also the most powerful and risky language. Good start tdd: has infiltrated the ruby culture much more than it did with smalltalk.

<DT><A HREF="http://blog.stackoverflow.com/2009/04/podcast-50/" ADD_DATE="1241988276" PRIVATE="0" TOREAD="0" TAGS="podcast,javascript,ide,autocompletion,languages,google,yegge">Podcast #50 - Blog - Stack Overflow - Steve Yegge</A>
<DD>It sounds like at Google are creating an standardized support layer which adds language specific features to IDEs. If you take for example IntelliJ and Eclipse they provide the same quality Java support features like autocompletion, inline help or compile as you write kind of stuff. The same happens for other IDEs and languages: they are implementing the same functionalities over and over again. As a developer for example I'd like to have autocompletion in TextMate but that's not enough for me to move to Aptana. My understanding is that they started from JavaScript support to create the framework, supporting their internal type system for the most important IDEs. Of course they have to support also other languages to go public with the framework. Maybe one day we'll be able to command+space in vi and have autocompletion :)

<DT><A HREF="http://www.betaversion.org/~stefano/linotype/news/247/" ADD_DATE="1241927674" PRIVATE="0" TOREAD="0" TAGS="twitter,time,waste,productivity">Stefano’s Linotype » On Twitter</A>
<DD>Mmmh. Stefano thinks that when information is just so not-digested is difficult to understand the ROI of the effort required to follow. It's like reading reddit, infoq, tuaw etc. every day. All wonderful sources of information but those news are so &quot;new&quot; that they can turn completely useless in just minutes. It's like gambling: in this case the risk is to waste time. He talks about Twitter specifically. But for me Twitter is not the place for news. What I'm mostly interested in is what are other people habits, what they do during the day, how they can so productive, what extra-job activities they have and when. For me it's a source of completely new information, nothing to do with IRC or blogs where personal habits are completely out of scope. Before Twitter I couldn't really know what software geniuses were up to or in which way they tackle a problem during their everyday life at work. Twitter is for me inspiring 90% of the time. No gambling.

<DT><A HREF="http://agileproductdesign.com/blog/the_new_backlog.html" ADD_DATE="1241925706" PRIVATE="0" TOREAD="0" TAGS="agile,userstories,planning,map,management">The new user story backlog is a map</A>
<DD>Story mapping is a pattern for the organization of user stories, epics and tasks on a permanent board. Instead of having only the current iteration (or sprint) board, all stories are organized permanently on another huge board where relationships and context can be maintained. I've seen this in practice working as a consultant for a project managed by ThoughtWorkers. As the article clearly stated this is nothing new but just a pattern emerging from multiple places.

After I heard about minimum marketable features from naked planning this is the time of &quot;minimum viable product&quot;. They mirror the same thing. Epic is another synonym. The important point in this approach is that stories belonging to different epics are worked together to release a product which is &quot;epic-complete&quot; but maybe not story-complete. Stories are prioritized, epics really aren't.

<DT><A HREF="http://www.cincomsmalltalk.com/blog/blogView?showComments=true&printTitle=Industry_Misinterpretations_133:_Smalltalk_and_FPGAs&entry=3418153027" ADD_DATE="1241457969" PRIVATE="0" TOREAD="0" TAGS="fpga,hardware,smalltalk,squeak">Industry Misinterpretations 133: Smalltalk and FPGAs</A>
<DD>Enjoyed some history of the Squeak community. Squeak users somehow self-organized to avoid a community split when squeakers with different ideas wanted to create their on branch. Sad fact: SmallTalk was too young to be used in the early eighties when memory consumption was an issue and people were choosing C++ for that. SmallTalk is now considered too old  without having spent a period as a mainstream language. It looks like there is a lot of interested about hardware implementation of languages for specific business on FPGA and GPU. The first reason is of course the always decreasing price of such a devices. In this podcast an FPGA implementing smalltalk instructions is only running as a simulation but soon to be &quot;printed&quot; in hardware. There is a one-to-ten ratio for a transistor implemented as FPGA over the actual number of transistors actually used. Still a good ratio considering ad-hoc hardware design on one side and generic CPU like Intel's on the other.

<DT><A HREF="http://www.mobileorchard.com/lessons-in-iphone-game-marketing/#comments" ADD_DATE="1241043213" PRIVATE="0" TOREAD="0" TAGS="audio,podcast,iphone,marketing,appstore">Lessons In iPhone Game Marketing</A>
<DD>This is an interesting and sad listening. It talks about how important it is to get in those top 100 by iTunes store ranking for whatever good/bad application. The sad part is that 6 months of development for a game can bring to 500$ in revenue if you miss that top 100. It means it has nothing to do with quality, robustness, reliability of software, but with good marketing. The top 100 is reached after a certain number of downloads after the launch or because Apple decides to feature the app. The integration of the number of downloads over the time doesn't matter even if you have a great average/day. The way you can get into the top 100 are pre-releases to send to online specialized websites for review, advertisement with promos, a light and free version that seduces the user to buy the 5$ version. In one word &quot;buzz&quot; that needs to converge at launch time to reach the tipping point. Just want to remember that in the AppStore quality is not as important as good marketing.

<DT><A HREF="http://itc.conversationsnetwork.org/shows/detail3995.html" ADD_DATE="1241034338" PRIVATE="0" TOREAD="0" TAGS="audio,talk,methodologies,process,funny,opensource">O'Reilly Open Source Conference - Robert &quot;r0ml&quot; Lefkowitz on Open Source</A>
<DD>Here's a funny and short presentation. Robert Lefkowitz is a skilled orator in the ancient roman sense. And is right from the Quintilian's Institutes of Oratory one century B.C. that apparently our modern &quot;phases&quot; of software development come from. It's hilarious how such an old essay is applicable to our modern times and the similarities between the Microsoft development process or RUP. From there Lefkowitz explains his idea for an Open Source development process: exceptional driven development. No requirements, no nothing, just straight deploy waiting for customers who create tickets to request what they need! Of course this is a parody but there is some truth, for example in the description of what a requirement is. A requirement is the expression of our fear, an illusion of power to domesticate the future of the soon to be developed software. Naked planning comes to mind: eliminate the waste required to produce almost useless estimates.

<DT><A HREF="http://chariottechcast.libsyn.com/index.php?post_id=461474" ADD_DATE="1241031636" PRIVATE="0" TOREAD="0" TAGS="grails,java,web,groovy,podcast,audio">Chariot Tech Cast - Grails</A>
<DD>I was curious to see how Grails was doing after a couple of years away from the Java world. Good to see that now Grails is a solid framework that can be used exactly like Rails. Type Grails app-name from the command line and you've got your nice project layout to start with, no hassles. I was thinking that if I need to work on a Java web application again I will definitely start from a Grails app, write tests and pure Java at first (a language I know) to gradually transform and move to pure Groovy. Sounds like a plan.

<DT><A HREF="http://blog.asmartbear.com/blog/why-you-have-to-engage-in-social-media-even-if-you-dont-want.html" ADD_DATE="1240920808" PRIVATE="0" TOREAD="0" TAGS="marketing,company,selling,social,blogs">Why you have to engage in social media, even if you don't want to</A>
<DD>Summary: a web presence is not sufficient to guarantee popularity anymore. This was the case 10 years ago but today for each line of business there are tons of competing companies all with good services and products. Solution: social networks. Web presence today means 2 things: contents (the old blog) and social networking which works like a review system by word of mouth. I work for a software house and I think the same thing applies here. There are tons of good programming firm and the only way you have to enter the &quot;cool kids&quot; status is by word of mouth by social networking. First step: put decent contents (not just for marketing) on the web, produce open source software, speak at conferences and user groups. Second: build trust by publishing opinions and pointers to your content via social networks. If you don't do this your customer base risks to become stale.

<DT><A HREF="http://www.cincomsmalltalk.com/blog/blogView?showComments=true&printTitle=Industry_Misinterpretations_129:_Smalltalk_in_Small_Places&entry=3415738780" ADD_DATE="1240539337" PRIVATE="0" TOREAD="0" TAGS="smalltalk,iphone,bridge,isqueak">Industry Misinterpretations 129: Smalltalk in Small Places</A>
<DD>Yeah. SmallTalk on the iPhone! How cool is that! The process is a bit complicated: you need to strip useless classes from the VM (Squeak) and compile all down to C and use an Objective-C to SmallTalk bridge to connect the two world. The micro-VM was used to run Pier (a CMS) which runs on top of SeaSide. So you've got pretty much all the SmallTalk possible goodness on the iPhone. The interview is a fascinating trip inside the internals of the VM, the garbage collector and the Obj-C to SmallTalk bridge. Have a peek at http://isqueak.org.

<DT><A HREF="http://web20show.com/episodes/episode-9-jason-fried" ADD_DATE="1240454073" PRIVATE="0" TOREAD="0" TAGS="company,success,focused,business,37signals,podcast,audio">The Web 2.0 Show - Jason Fried</A>
<DD>I enjoyed this interview with Jason Fried which is very actual despite the date of recording, January 2006. I never read &quot;Getting Real&quot; but I suppose what I heard here is more or less what's on the book. Speaking of which, &quot;Less is More&quot; is one of the 37Signals slogans which refers to everything: less developers, less pages, less features, with the goal of creating something simple but complete in each part. I'm sure you can do everything interface first, but I prefer the approach of front-end back-end at the same time and in the same team. Interesting the approach of asking the customer feedback after the application is rolled-out. Basecamp was created in 10 hours/week for 3.5 months: it takes that long to create a great product if you stay really focused. The perpetual beta of some products is just bullshit because it looks more a way to apologize in advance for the crappiness of the product. Better focus on something 100% done from the start instead.

<DT><A HREF="http://web20show.com/episodes/episode-18-eric-meyer#commentform" ADD_DATE="1240319964" PRIVATE="0" TOREAD="0" TAGS="podcast,audio,css,ui,books,publishing">The Web 2.0 Show - Eric Meyer</A>
<DD>Here's an old (2006) interview with Eric Mayer. Eric talks about the future of paper-based publishing especially in the computer science field. Today is more profitable to self-publish your work considering how easy it is to create a following with just your web presence. If book publishing companies want to survive they have to adapt to some form of electronic process, offering authors editing or marketing services disconnected from the physical creation of a book. That's exactly what happened thinking at the Pragmatic BookShelf or the O'Reilly online book format. There is also some room in the interview to talk about Eric's experience. He became the CSS guru publishing tons of content about CSS for free and only after he was offered to write the popular book. He talks also about the UI design process, starting from photoshop comps, merging all layers, slicing and starting creating the box layout.

<DT><A HREF="http://cocoacast.com/?q=node/237" ADD_DATE="1239979735" PRIVATE="0" TOREAD="0" TAGS="podcast,audio,agile,generalists,fdd,bdup,coad">Unbound Developers - Interview with David Anderson Part II</A>
<DD>I heard again interesting things in this second episode of the podcast. David advocates the introduction of a new process in a company by examining the context and adopting values and principles first. It's the company responsibility to set the goals and find the best practices for them which can come from XP or Lean for example. In the need for a change is the team that self-organize and choose what practice works best in their situation. David's take on generalists VS specialists is that a profitable company needs both. With only generalists you have for sure flexibility and probably fast time to market but lack of marginal value (the key differentiator for a product on the market). Specialists are able to bring that key differentiator for a business to succeed in the long term. I also heard a quick history or FDD, circa 1987. FDD is like enterprise-agile with more design and architecture up-front to mitigate mission critical risks. I found evident traces of FDD in today's DDD.

<DT><A HREF="http://antoniocangiano.com/2009/04/13/startup-interviews-balsamiq-studio-llc/" ADD_DATE="1239920661" PRIVATE="0" TOREAD="0" TAGS="mockups,company,business,products">Startup Interviews: Balsamiq Studio LLC | Zen and the Art of Programming</A>
<DD>I think I heard about Mockups on some Stackoverflow episode but then I forgot abut the name when I wanted a tool to do rapid sketches of pages or part of an application. Glad I found a second reference, as usual when the tool is really a good tool. I'm impressed by the company effort to maintain good customer relationships and the web based office idea to keep the overall company costs very low. Happy to hear about italians doing great things, but sadly they are or they were first out of Italy to produce their ideas and leverage their potential.

<DT><A HREF="http://smartic.us/2009/04/01/introduction-to-acceptance-testing-ruby-web-applications/" ADD_DATE="1239817934" PRIVATE="0" TOREAD="0" TAGS="video,slides,cucumber,webrat,integrity,acceptances,add,bdd">Smarticus - Introduction to Acceptance Testing Ruby Web Applications</A>
<DD>Simple and enjoyable presentation on the typical Cucumber stack. I'm catching up these days with the latest evolution of acceptance driven development but having some real life experience with the story runner and webrat-rspec already I'm just focusing on the new things. Nice to see that there is a standard webrat steps library for common steps and the good use of regular expressions. Bryan made a good point worth remembering. It's fun to use Cucumber for development, but it's more a customer facing tool than developer oriented. If you don't have a customer willing to collaborate to write scenarios, you might want to switch to rails integration tests plus webrat (if you use Rails). Bryan doesn't use CruiseControl because it's too big... I also like Integrity, but the size of a product is not very important to me. Am I missing something?

<DT><A HREF="http://lizkeogh.com/2009/04/14/what-does-not-agile-look-like/" ADD_DATE="1239726958" PRIVATE="0" TOREAD="0" TAGS="agile,definition,adoption,practices">lizkeogh.com - What does &quot;Not Agile&quot; look like?</A>
<DD>Interesting point of view. Actually, I can't remember of an example of someone telling me &quot;we aren't agile&quot;. That depends of course on the kind of people I know. I agree: if we can all be agile just by saying the word, then the term failed to describe itself. At the same time Uncle Bob's example of filtering the audience by practices is not a perfect indicator either. Maybe this question is more appropriate: have you tried the practice you claim is not working for your organization before removing it? Definition of &quot;try&quot;: practice used consistently for at least one small (or above) size production project or full release (if the project is big).

<DT><A HREF="http://www.cocoacast.com/?q=node/236" ADD_DATE="1239661991" PRIVATE="0" TOREAD="0" TAGS="craftsmanship,organization,process,mentoring">Interview with David Anderson Part I</A>
<DD>First time I hear the voice of Dave Anderson after reading his blog. David speaks also about craftsmanship in this episode saying that craftsmanship is mainly an individual attitude and as such it shouldn't be a problem to apply it to enterprises because it doesn't require changes to the actual processes. I agree. I also think that should be possible to organize big companies into cross-departmental mentoring hierarchies. After I heard this podcast I thought that craftsmanship is all about continuous self-improvement and the mentoring organization (master programmer, journeyman, apprentice) is just how individuals, who try hard to self-improve, collaborate.

<DT><A HREF="http://www.ibm.com/developerworks/web/library/os-couchdb/index.html" ADD_DATE="1239375199" PRIVATE="0" TOREAD="0" TAGS="couchdb,database">Exploring CouchDB</A>
<DD>Here's a nicely written introduction to CouchDB and document-based databases. It's not too short not too long and assumes you have a relational background. CouchDB remembers me of another doc-db I've used in the past: Exist. Since Exist is XML based there is somehow an implied Schema structure given by the XSL (you can decide not to use it) while CouchDB is completely de-structured. I couldn't understand how the map-reduce is related to CouchDB: I understand the result are key-value pair but I didn't understand what criteria are used for the hashing. It's just a matter to try some example first and I'm sure I'll understand.

<DT><A HREF="http://blog.8thlight.com/articles/2009/3/30/material-consciousness-in-software" ADD_DATE="1239373987" PRIVATE="0" TOREAD="0" TAGS="craftsmanship,exercise,photography">Material Consciousness in Software - Paul 8thlight</A>
<DD>Enjoyed this post by Paul at 8thlight. Material consciousness is the essence for a craft and we should avoid to go &quot;meta&quot;. The best definition of craftsmanship for me is exactly this: doing things. Therefore pure exercise is a must to refresh the craft: kata, solving quizzes, refactoring exercises, etc. A sentence often repeated in photography communities is: &quot;go out and take some pictures&quot;. This is because people tend to spend all their time reading forums and article to improve their photography skills while of course they should be out taking pictures. The same is valid in software.

<DT><A HREF="http://media.fngtps.com/rubybanter/2008/008/#play" ADD_DATE="1239163565" PRIVATE="0" TOREAD="0" TAGS="video,screencast,ruby,strategy,conditionals">Conditional logic with methods · Ruby Banter #008</A>
<DD>The guys at Fingerprints put together a series of small pairing sessions which are a mix of video and screencasting. It's a good way to promote the work of the company and it illustrates how the guys work internally. I would say a must for a company of craftsmen. In this episode you can see why is always possible to substitute conditionals creating on the fly the opportune strategy object. Ruby allows to create strategies like this quickly and with a clean format just by using blocks as container of the strategy. That said, for this specific case (checking if mocha is installed) I'd rather use a simple if. A strategy is overkill for a case where there is only one option and its negation. I understand the usage here to illustrate the possibilities. Well done.

<DT><A HREF="http://www.se-radio.net/podcast/2009-03/episode-130-code-visualization-michele-lanza" ADD_DATE="1239162461" PRIVATE="0" TOREAD="0" TAGS="audio,podcast,visualization,metrics,graph">Code Visualization with Michele Lanza | Software Engineering Radio</A>
<DD>I was talking a while ago about esthetic in code, specifically the way the code displays on the screen. Here's something that goes close to that idea although it seems very connected to the notion of module, class or function. What I was talking about was more a matter of symmetry and surrounding spatial composition in code as a metric (right now I don't have any idea if what I said make sense :) Anyway, the work of Michele is remarkable, especially the animation of the evolving code-base as visual artifact.

<DT><A HREF="http://jamesshore.com/Blog/Stumbling-Through-Mediocrity.html" ADD_DATE="1239116428" PRIVATE="0" TOREAD="0" TAGS="agile,mediocrity,adoption,change,effort">James Shore: Stumbling Through Mediocrity</A>
<DD>Need to remember. I think that objections to Agile are done mostly with the same &quot;Does Agile scale?&quot; principle in mind: can I attach that &quot;Agile&quot; thing on my name but keep doing what I do? We are back to that &quot;real world&quot; context excuse that hides reluctancy to change. Change is difficult, requires energy, strong decisions and probably an unpleasant feeling at first. Like anything that brings you to another level and makes you great, you have to try hard.

<DT><A HREF="http://cocoacast.com/?q=node/228" ADD_DATE="1239114891" PRIVATE="0" TOREAD="0" TAGS="lean,agile,process,podcast,audio,interview">Agile Corner - Interview with Curt Hibbs on Lean</A>
<DD>I found in this podcast a concise and convincing description of Lean Development: Lean applies to an already existing process adding the tools to improve throughput, increase quality and eliminate waste. Considering Lean like an &quot;attachment&quot; of Scrum or XP, the three Agile processes together form a nice combo. Scrum handles the management, XP handles the development, Lean handles the optimization of the production phase. There are already several Lean contaminations in XP (Kanban being the last of them), sign that the different agile souls are slowly converging as expected into a single entity.

<DT><A HREF="http://web20show.com/episodes/web20show-ep55-capital-factory" ADD_DATE="1239113987" PRIVATE="0" TOREAD="0" TAGS="craftsmanship,startup,venturecapital,business,company,podcast,audio">The Web 2.0 Show - Capital Factory</A>
<DD>Are companies like Capital Factory the next kind of venture capital funding for start-ups? There seems to be a huge difference when Marc Nathan illustrates the mentoring program for young entrepreneurs that Capital Factory provides as part of the package. I'd like to call it entrepreneur craftsmanship, because the entrepreneur is trained to produce more business value from the funding they are given. Like software craftsmanship locality is fundamental to create relationships.

<DT><A HREF="http://agiletoolkit.libsyn.com/index.php?post_id=400364" ADD_DATE="1238820715" PRIVATE="0" TOREAD="0" TAGS="naked,planning,kanban,arlo,agile,estimate,mmf,podcast,mp3,audio">Arlo Belshee - Naked Planning</A>
<DD>Ok, this guy officially does crazy stuff! I remember his &quot;promiscuous pairing&quot; and the &quot;least qualified implementor&quot; and this time we are talking about &quot;naked planning&quot;. Main facts: the user story (minimal marketable feature) length is bigger up to an average of 45-60 days and is prioritized by value not by cost (that means no estimate). Releases happen as the MMF is done (no release planning). The iteration is just a container for retrospectives. When the MMF is in progress, the team discuss the design and sub-tasks, always with no estimate. Last thing (not connected with naked planning) is that Arlo doesn't like the maintenance cost of acceptance tests. His suggestion is to use acceptances to drive unit testing and then throw them away. Pretty wild uh? Naked planning is based on the assumption that: the customer is trained to create MMFs, value is the only thing that matters (no cost) and programmers doesn't need the pressure of estimates to maintain a steady pace.

<DT><A HREF="http://blog.objectmentor.com/articles/2009/04/01/master-craftsman-teams" ADD_DATE="1238681856" PRIVATE="0" TOREAD="0" TAGS="craftsmanship,journeyman,master,agile,team,unaclebob">Master Craftsman Teams - Uncle Bob</A>
<DD>Here's a flame-like post by Uncle Bob for the richness of ideas it contains. Perplexity: skipping higher CS education for a serious apprenticeship? Could be. But somehow higher education is important beside the actual subject of training. So why not learning physics, maths, chemistry or other high abstraction disciplines with the specific goal to move to computer science right after? I know a lot of successful examples of cross-discipline CS professionals and the success seems to depend on their ability to think &quot;differently&quot; than the subject of their studies. I think what Uncle Bob describes is doable but probably what is missing are those Master Programmers described in the post. There are just a few of them in my opinion, I don't know if this is enough. Anyway, I aspire to be a Master Programmer one day. I changed my Linkedin tag line accordingly. :)

<DT><A HREF="http://video.google.com/videoplay?docid=-7230144396191025011&ei=aLvQSd2tJpuo_AGQsPmYCg&q=scrum" ADD_DATE="1238506184" PRIVATE="0" TOREAD="0" TAGS="scrum,agile,quality,burndown,schwaber">Ken Schwaber on Scrum at Google</A>
<DD>Here's the classic video about Scrum by Ken Schwaber. Three years have passed already but the talk is just actual as it used to be. I'm wondering how Scrum adoption at Google is doing after several years. Anyway, I liked the how Ken rendered the accumulation of technical debt using burn-down charts. First management asks to increase velocity to produce more value. The team reacts reducing quality and achieving the velocity increase. But the following sprints velocity decreases for the accumulation of technical debt although the team is always trading quality for speed. What they experience is a false perception of instant velocity while they fail to see the decrease of long-term velocity which is so much harder to fix. Amazing that Ken can explain whatever idea with a burn-chart :)

<DT><A HREF="http://www.nomachetejuggling.com/2009/02/21/i-love-pair-programming/" ADD_DATE="1238379270" PRIVATE="0" TOREAD="0" TAGS="pairing,cowboy,hacker,quality,experience">I Love Pair-Programming - Absolutely No Machete Juggling</A>
<DD>At first I judged this experience report to be too naive. It's instead a valuable article about the conversion of a cowboy coder into a quality-aware agile practices enthusiast. There are catch phrases and definitions to remember, like the experience of coding at the speed of light or the fact that &quot;programmer man&quot; is instead &quot;technical debt man&quot;. I don't know if I ever was a programmer man: I probably suffered of the opposite problem of lacking of pragmatism and focus.

<DT><A HREF="http://itc.conversationsnetwork.org/shows/detail3987.html" ADD_DATE="1238276665" PRIVATE="0" TOREAD="0" TAGS="audio,podcast,legacy,eloquence,talk,speech">Legacy Code - David Heinemeier Hansson</A>
<DD>I want to remember this podcast not for the content but for the speech capabilities of DHH. The content is actually very simple and can be summarized as: &quot;legacy software is a personal opinion&quot;. On top of this interesting concept DHH was able to create an entire speech. I'm amazed by the approach: a very simple catch phrase or concept and then, like in a mind-map, a set of corollary and consequences and for each one an simple explanation. I'll be happy to be able to repeat the same approach in my talks: find out what the content is all about in just one sentence and draw from that sentence all the consequences. Is not necessary for the main topic to be a complex theory, just something simple that can potentially have many consequences and what are the most important of them. Just a dream... I don't have of course the same eloquence.

<DT><A HREF="http://www.youtube.com/watch?v=pqeJFYwnkjE" ADD_DATE="1238254909" PRIVATE="0" TOREAD="0" TAGS="video,technicaldebt,debt,quality,agility,metaphor,refactoring">Ward Cunningham - Debt Metaphor</A>
<DD>Amazing how many good things can be said in less than 5 minutes. When technical debt accumulates it's usually too late to fix it mainly because the code was not written to be easy to clean-up an debt accumulation is exponential. Especially when instead of fixing the broken design all dependencies to that part are fixed creating duplication. Ward remembers us that technical debt is about writing bad code with the idea of fixing it later, not writing good code with the understanding of the moment designing it so that can be easily changed. That is exactly what evolutionary design is about, not to be confused with technical debt.

<DT><A HREF="http://www.satisfice.com/blog/archives/224" ADD_DATE="1238190054" PRIVATE="0" TOREAD="0" TAGS="quality,craftsmanship,customers">James Bach’s Blog Quality is Dead #1: The Hypothesis</A>
<DD>The quality is dead hypothesis is a scary one but I have to agree. The hypothesis is that we lowered the bar of software quality to such an extent that software users believe that grotesque user experiences, crashes and unpredictable behaviors are what software really is. Fatalism that we created. Like the post said, marketing efforts are all focused to easily measurable metrics for the customer satisfaction like a good help line or useless services. What a sad thing.

<DT><A HREF="http://www2.computer.org/portal/web/csdl/abs/html/mags/so/2007/03/s3024.htm" ADD_DATE="1238188813" PRIVATE="0" TOREAD="0" TAGS="tdd,agile,study,jeffries">TDD: The Art of Fearless Programming</A>
<DD>In this article Ron Jeffries and Grigori Melnik discuss advantages of TDD adoption. The article is a basic introduction to TDD, but it publishes a couple of tables of research studies in the industry and academic about results of agile adoption. The study shows an average increment in the effort which is usually low and a substantial quality increase percentage. The article confirms that with agile adoption a low increase in the effort produces a substantial quality increase. The results aren't extraordinary but positive, just to stress once again that there is no silver bullet.

<DT><A HREF="http://www.infoq.com/articles/adopting-pair-programming" ADD_DATE="1238154813" PRIVATE="0" TOREAD="0" TAGS="pairing,agile,xp,pair,patterns">Jay Fields: Successfully Adopting Pair Programming</A>
<DD>Here's another nice write-up by Jay. This article is good to remember because it clearly describe usual pair programming stories and their challenges. Is good to remember that pair programming should never be imposed. There are people who obviously aren't interested in pairing if they never tried or if they fear their freedom is in danger. Jay suggestion to start from who is more willing to pair to first create a working team and then convince the others is great. The mentor/learner distinction is very important too especially talking of the mentor role. In my experience often the mentor doesn't switch to teaching mode (driving the learner to the correct solution instead of dictate literally the solution). I also tried pairing sessions myself and I am very happy about the results.

<DT><A HREF="http://mwrc2009.confreaks.com/14-mar-2009-15-00-bdd-with-cucumber-ben-mabey.html" ADD_DATE="1238109330" PRIVATE="0" TOREAD="0" TAGS="video,cucumber,webrat,specs,funny">BDD with Cucumber - Ben Mabey: MountainWest RubyConf 2009</A>
<DD>This is a well crafted Cucumber presentation, with funny examples and a great selection of pictures. I already know what cucumber can do and I know is a wonderful acceptance framework. My take-aways are a concise formulation of the 5 whys rule and a clear statement that there is no fixed way to say what to use between views specs, controllers spec, models spec, Cucumber-webrat or Cucumber-Selenium. Based on the project, you can use all of the possible level of testing or just part of them.

<DT><A HREF="http://mwrc2009.confreaks.com/14-mar-2009-15-35-what-the-ruby-craftsman-can-learn-from-the-smalltalk-master-philippe-hanrigou.html" ADD_DATE="1238028290" PRIVATE="0" TOREAD="0" TAGS="video,smalltalk,esthetic,cleancode,patterns,kentbeck">Smalltalk to Ruby: MountainWest RubyConf 2009</A>
<DD>Maybe this presentation is too simple as the author said at the end. It presents the Implementation Patterns book Smalltalk version by Kent Beck with  a few examples from the everyday Ruby and Rails development. But it helped me out to clarify the meaning of esthetic in code. Esthetic is about visualization: symmetry for example is a visual effect. How then software relates to esthetic? Because there is a visualization aspect of code which is actually very important. It is through visualization for example that is possible to say if some code is good or bad, because of the &quot;impression&quot; of length of methods or the symmetry of a class where there is the same amount of code averaged in every method. The first metric we often use to judge clean code is the visual aspect. At least this is what I do. It would be interesting to analyze these visual aspects in a formal way. Mmmh.

<DT><A HREF="http://rubyconf2008.confreaks.com/advanced-dsls-in-ruby.html" ADD_DATE="1237835948" PRIVATE="0" TOREAD="0" TAGS="video,dsl,ruby,domain,business,rubyconf">Neal Ford DSLs RubyConf 2008</A>
<DD>The de-facto DSL in Ruby presentation these days. Neal Ford's talk are usually well crafted and this is no exception. I especially liked the constant factory trick to avoid double quotes on names, bubble words and instance_eval to expand contexts. Slides available here http://www.nealford.com/downloads/conferences/canonical/Neal_Ford-Advanced_DSLs_in_Ruby-slides.pdf

<DT><A HREF="http://jakescruggs.blogspot.com/2009/03/on-going-fast-because-youre-start-up.html" ADD_DATE="1237473058" PRIVATE="0" TOREAD="0" TAGS="startup,speed,quality,craftsmanship,example,story,fast">Jake Scruggs: On Going Fast Because You're A Start-up</A>
<DD>Jake talks about a typical start-up frustration experience. The &quot;experiment&quot; should not be longer than 4-6 months and after that the entrepreneur should know if it's worthwhile. From the technical standpoint that should be also the time to plan based on the user feedback. The problem is that once lower quality is established and there is a public release it's too late to educate the customer about the need for quality. So my suggestion is never trade quality for speed, it's a false impression of speed. Yes the entrepreneur will probably go finding someone else for a 4th of the price but we (the craftsmen) have the responsibility to tell the customer what to expect. And this post is a good example. Thanks for sharing.

<DT><A HREF="http://matteo.vaccari.name/blog/archives/171" ADD_DATE="1237398020" PRIVATE="0" TOREAD="0" TAGS="practices,adoption,agile,metaphor">Extreme Enthusiasm » Blog Archive » Not wishful thinking</A>
<DD>I want to remember the example of the toddler baby. They are not sold the idea of walking on two feet and still they are able to move quite well anyway on four. They try the new &quot;practice&quot; anyway and they see they can cover much more distance with ease. So, yes, you don't need to try anything new if you are successful already. But you might discover you can do the same thing with less effort and spend the energy for something else.

<DT><A HREF="http://blog.objectmentor.com/articles/2009/03/16/tighter-ruby-methods-with-functional-style-pattern-matching-using-the-case-gem" ADD_DATE="1237396452" PRIVATE="0" TOREAD="0" TAGS="regexp,functional,ruby,case,erlang">Ruby Functional-style Pattern Matching, Using the Case Gem - Dean Wampler</A>
<DD>Interesting use of pattern matching instead of explicit conditional to control the program flow. The best would be to have a method definition in Ruby that accept a &quot;Case&quot; pattern declaration. When the method with that name is called the selection of which overridden version is done by the patter matching. Should we fork a functional Ruby? :)

<DT><A HREF="http://www.cuberick.com/2009/03/pair-programming-with-multiple-mouse.html" ADD_DATE="1237384444" PRIVATE="0" TOREAD="0" TAGS="pair,xp,multiple,keyboard">Pair programming with multiple mouse pointers and keyboard</A>
<DD>Wondering why I never thought about this before :) Why a screen should be constrained to just a single user interacting with it? Multiple mice and keyboards can be connected to a single screen with the use of a special switch and used sequentially. But the possibility of having multiple mouse pointers and users sitting in front of the same screen offers new possibility for pair programming. For a little more on discipline, you cut down on all those &quot;can I grab it for a moment&quot; synchronization points! Thanks to Josh for pointing this out.

<DT><A HREF="http://agileinaflash.blogspot.com/2009/03/extreme-measures.html" ADD_DATE="1237383648" PRIVATE="0" TOREAD="0" TAGS="agile,tips,flash,xp,team,iterations">Agile: In A Flash: Extreme Measures</A>
<DD>This is a series of flash cards collecting agile and programming principles. The format is a pleasure to read: small enough to attract your attention with a single catch sentence. I link to this one in particular (but go and read the rest) because it's full of original and advanced tips. In particular I like the technique of splitting a team so that developers aren't tempted to cheat on the done percentage of a story and sneak features into the following iteration. Since they can be in a different sub-team, there is no next iteration to close the user story. The other interesting tip is to discard work which is over 3 weeks old. I would also add to clean-up the task list of stale/old tasks that never get done in the hope to have more time in the future. I know from experience that they never get done.

<DT><A HREF="http://rubyconf2008.confreaks.com/what-all-rubyist-should-know-about-threads.html" ADD_DATE="1237148344" PRIVATE="0" TOREAD="0" TAGS="threads,concurrent,ruby,video,rubyconf,threading,erlang,clojure">Jim Weirich - Threads - RubyConf 2008</A>
<DD>Classic threads presentation but as usual with Jim Weirich entertaining and fun. Common aspects of concurrent programming in Ruby are covered here and was a good refresh for my Java memories too. The problem with thread is all about shared state and very similar to transaction management at the end. You need to make atomic a sequence of operations with something like a Mutex. Deadlock is when all the thread are in a wait state (and this happens when a couple of them are waiting for each other) and can be solved with prioritization. Suggestion: if your application is highly concurrent in nature, consider to use a secondary inherently thread safe language like Erlang or Clojure instead of trying to use thread controlling constructs of the sequential language.

<DT><A HREF="http://www.cocoacast.com/?q=node/217" ADD_DATE="1236980552" PRIVATE="0" TOREAD="0" TAGS="kanban,agile,distributed,teips,lean,podcast">Agile Corner. Interview with James Shore | CocoaCast</A>
<DD>This podcast is a concentrate of good stuff (and Vlad is a great interviewer). Let's start with distributed agile tips: teams travel a lot, everybody at the phone for call conferences, no main physical board (same handicap). Kanban: especially good for maintenance or established products because there is less need for predictability which is easier with iterations. Last advice for those situation where a strict planning is required: let the team have at least 3/4 iterations first to give more reliable estimates. If you don't then you get those fixed bid projects where you deliberately under-bid to make profit on change requests later. Only one thing I disagree at the very end: it's true that static analysis tools tell you what you can easily see in code. But it's the game that matters: play against your self to see those numbers changing.

<DT><A HREF="http://blog.jayfields.com/2009/02/thoughts-on-developer-testing.html" ADD_DATE="1236722930" PRIVATE="0" TOREAD="0" TAGS="testing,patterns,engineering">Jay Fields' Thoughts: Thoughts on Developer Testing</A>
<DD>A post about testing, full of &quot;from the field&quot; advices. Number one: if it hurts you're doing it wrong. Jay describes a situation where common test patterns or tools are applied without a conscious decision like a big design up-front. Contextualize is again the keyword. There was a time I did the same: I thought mock-all development was the way to go and I started mocking all collaborators to discover interfaces. Which is of course not bad at all! The problem is if you decide that is the only approach possible for the entire application. Test maintenance is going to eat 100% of your time.

<DT><A HREF="http://blog.thinkrelevance.com/2009/2/16/2008-a-fine-year" ADD_DATE="1236712352" PRIVATE="0" TOREAD="0" TAGS="process,relevance,company,corporate,practices">Relevance Blog</A>
<DD>I'm glad to read about the details of well known companies like Relevance. I usually learn something original (I recently had good reading also about HashRocket and Pivotal Labs). The open source Fridays for example. Instead of dedicating an average 20% a week to open source projects, at Relevance they decided to concentrate the effort on a single day. This set the customer expectation in a very clear way. Personal retrospectives instead of standard progress reviews. Here you can talk with not just the boss but with the entire team that can give you advices and positively judge you. Third the hacker in residence program (similar to Hashrocket's rockstars) where you develop with the team for a good 6-12 weeks.

<DT><A HREF="http://programmingtour.blogspot.com/2009/02/road-thoughts-practice.html" ADD_DATE="1236651354" PRIVATE="0" TOREAD="0" TAGS="craftsmanship,practice,skill,tools,release,pressure">On Being A Journeyman Software Craftsman: Road Thoughts - Practice</A>
<DD>Of the many good posts from Corey Haines I chose this one to remember about an important fact he often repeats. For practicing, a software craftsman would start from those skills which fail under the pressure of a release. The different behavior between the comfort of a regular day at work and the stress of an incoming release is the measure of what you still need to practice. The lack of practice is also responsible for the perceived &quot;slowness&quot; that forces the developer to give up on &quot;decorations&quot; when the timeline is approaching.

<DT><A HREF="http://xprogramming.com/blog/2009/01/30/context-my-foot/" ADD_DATE="1236559537" PRIVATE="0" TOREAD="0" TAGS="agile,xp,adoption,process,scrum">Context, My Foot! « Hot Needle of Inquiry</A>
<DD>I've got the same impression that Ron Jeffries describes in his post. The need of flexibility that label Kent Beck's Extreme Programming Explained 2nd ed. was a double edged sword. In name of that flexibility many teams defined themselves &quot;agile&quot; after the exclusion of XP practices not compliant with their &quot;context&quot; without even try them first. Which is of course bad because it's then easy to blame agile for a failure that is dependent on the same context that prevented the real agile adoption.

<DT><A HREF="http://blog.fohjin.com/blog/2009/2/21/Craftsmanship" ADD_DATE="1236558098" PRIVATE="0" TOREAD="0" TAGS="craftsmanship,customers,expectations,quality">Mark Nijhof about Craftsmanship</A>
<DD>The content of this post is extremely true. IT industry customers tolerate low quality standard for software but do not tolerate the same for other crafts or industries. Why is that? It could be that IT is very young compared to millenary crafts like building a house and therefore people believes that chronic late releases and lot of bugs are &quot;normal&quot; in software. Is our (developers) responsibility to raise the bar and the customer expectation level. I also believe that the software craftsmanship movement is the answer not only Agile practices.

<DT><A HREF="http://www.atomicobject.com/pages/PF+Ruby+Example" ADD_DATE="1236452721" PRIVATE="0" TOREAD="0" TAGS="ui,testing,test,mvp,presenter,example,code">Presenter First Ruby Example | atomicobject.com</A>
<DD>Once again the Presenter pattern. The example and accompanying documentation are well done this time although the observer pattern and dependency injection make the example less readable. The Model View Presenter extracts all the presentation flow from the view and since the presentation logic is business logic everything can be tested easily without mocking the UI. The tests are basically from the presenter down but no view (which is just a thin wrapper around the UI api). MVP looks good for tricky UI, where the cost of instantiating and using the UI for the tests is too high. I don't think it's the case for erb pages in Rails though because those are really easy to test.

<DT><A HREF="http://aac2009.confreaks.com/07-feb-2009-13-30-tatft-the-laymans-guide-bryan-liles.html" ADD_DATE="1236188345" PRIVATE="0" TOREAD="0" TAGS="integrity,culerity,celerity,tatft,act2009,video,presentation">acts_as_conference 2009 tatft-the-laymans-guide-bryan-liles</A>
<DD>Here's another enjoyable talk full of humor and good advices. I can't say the content was completely new for me. But I updated my tool box with a couple of promising apps. Integrity instead of Cruisecontrol.rb and Culerity that combines Cucumber and Celerity. I'm curious to know if finally we have something robust to use for end to end head-less testing. I'm also interested in trying Vim for development after I saw Bryan's blog is full of good suggestions. Last: Bryan uses a kind f pomodoro technique with 15 minutes time slots. Good to know someone got to the same conclusion that is better to break often.

<DT><A HREF="http://aac2009.confreaks.com/06-feb-2009-20-30-lightning-talk-under-your-fingers-corey-haines.html" ADD_DATE="1236023338" PRIVATE="0" TOREAD="0" TAGS="tdd,practice,craftsmanship,coreyhaines,speed,exercise">Corey Haines acts_as_conference 2009</A>
<DD>Corey is a great speaker. With passion. He condensed in this talk a very simple thing: the fear to apply a practice when the pressure comes in and the reasons of that fear. Simple: it's not enough to spike on TDD and then apply it in all situations. If you don't master the practice enough chances are you'll drop TDD close to a deadline because &quot;it's slow&quot;. TDD isn't slow, it requires practice like everything else but for some reason in our software industry we don't consider practicing a practice. Moreover TDD isn't easy at all and require systematic effort. Only after you practiced enough to &quot;breath&quot; the technique you're ready to apply it at the same speed of every other tool. Great lighting talk.

<DT><A HREF="http://www.mobileorchard.com/interview-with-beginning-iphone-development-authors-dave-mark-and-jeff-lamarche/" ADD_DATE="1235919650" PRIVATE="0" TOREAD="0" TAGS="cocoa,objectivec,outlet,nib">Interview with “Beginning iPhone Development” authors Dave Mark and Jeff LaMarche</A>
<DD>I'm glad sometimes I discover a little gem hidden under a misleading title. So instead of iPhone for beginners I found an Objective-C introduction for developers that I really liked. Mark and LaMarche explains here what is an outlet, how Cocoa classes are serialized into a Nib file and why, the power of a Nil object that can reply to messages, how delegates work plus what you should expect as a C or Java developer approaching iPhone development.

<DT><A HREF="http://aac2009.confreaks.com/06-feb-2009-11-00-the-grand-unified-theory-jim-weirich.html" ADD_DATE="1235835268" PRIVATE="0" TOREAD="0" TAGS="connascence,design,principles,coupling,dry">Jim Weirich The Grand Unified Theory aac 2009</A>
<DD>Maybe Jim is just revisiting old books that nobody cares about, but the result is entertaining and the Connascence model explains quite a bit of what we consider today as &quot;quality&quot; software. Absolutely worth listening. With the Connascence model things like an &quot;extract method refactoring&quot; can be explained in terms of tension to the less dangerous Connascence of Names. Also different kind of bad smells in code can be explained the same way and Jim give us example from Rails and Fixtures. I'm definitely surprised of the power of the Connascence model though I'm not sure we can talk about the grand unified theory. Connascence seems to me an explanation of coupling on steroids , something to add to the group of principles (like SOLID, Demeter etc.). Thoughtful talk.

<DT><A HREF="http://rubyconf2008.confreaks.com/keynote.html" ADD_DATE="1235605366" PRIVATE="0" TOREAD="0" TAGS="ruby,davethomas,fork,rubyconf">Dave Thomas RubyConf 2008: Fork Ruby</A>
<DD>I'm not sure I understand the need of forking Ruby &quot;the language&quot;. Dave says that all of the enhancements proposed are in SmallTalk for example. Since there are other languages carrying those ideas, do we really need to fork Ruby to know if those enhancements are really worth in Ruby? Anyway, the talk is a concentrate of smart ideas. For example, there are obscure apis and methods that can be removed to make a lighter Ruby. Dave then describes a parallel implementation of the multiple assignment as a way to introduce transparent parallelism in Ruby. Lambdas can be downsized to a single construct instead of the many we have now up to the extreme of removing class and global variable. Overall an enjoyable and entertaining presentation worth looking.

<DT><A HREF="http://www.jroller.com/rickard/entry/qi4j_and_state_modeling" ADD_DATE="1235172591" PRIVATE="0" TOREAD="0" TAGS="qi4j,cop,ddd,modeling,mixins,design">Qi4j and State Modeling</A>
<DD>I've been following Rickard since the XDoclet days and always found his work inspirational. It is also the case for Qi4j although my understanding is not yet enough to judge the framework consistently. I just want to express my impression so far. The kind of work I see is very similar to an architecture where there is an interface for each method of a class. It's like extreme decomposition. If you have an interface for each method (or just a few of them which would usually make up a single interface or class) you can compose objects by mixing many interfaces (for example Nameable instead of having a class with a getFirstName getLastName kind of methods). The mechanism seems powerful but at the same time I fail to see how this can increase the expressive power to describe domain models. It looks less readable and more confusing for me now, but as I said, I need to study composition oriented programming first.

<DT><A HREF="http://www.abetterteam.org/" ADD_DATE="1235170440" PRIVATE="0" TOREAD="0" TAGS="maturity,agility,agile,values,questions,quiz,team">a better team</A>
<DD>This is cool. I didn't know about the quiz in the book, because I don't have it. But I had a look at the questions and they are very well posed and targeted manly at values other than practices. I agree with the site motto: is the discussion that matters not really the results of the quiz. I would probably add this list of questions to those related to craftsmanship(http://reborg.tumblr.com/post/65104831/are-you-a-software-craftsman): team agility maturity model and individual craftsmanship maturity model. If we add also the Rails maturity model we probably have enough to assess maturity of a company.

<DT><A HREF="http://alexbarnett.net/blog/archive/2009/01/29/7-tips-to-a-successful-landing-at-a-large-company.aspx" ADD_DATE="1235148362" PRIVATE="0" TOREAD="0" TAGS="tips,corporate,company,job">7 Tips to a Successful Landing at a Large Company - Alex Barnett blog</A>
<DD>Interesting and original tips here. It's a long time I don't land in a large corporate environment (and when I did it was as a consultant). I'm not missing it, but I recognize that some of the challenges you can find in a large company are peculiar and worth trying. Of the 7 tips there is one I never thought about: reading the annual report. Probably this is because I don't understand the financial field very well, but I'd like to give it a try the next time.

<DT><A HREF="http://www.jonathancrossland.com/post/TalkWare-Episode-3-with-Robert-C-Martin.aspx" ADD_DATE="1235002434" PRIVATE="0" TOREAD="0" TAGS="agile,scrum,practices,craftsmanship,unclebob">TalkWare Episode 3 with Robert C Martin</A>
<DD>Jonathan Crossland is putting together a cool podcast series. This time he interviewed Uncle Bob (who is pretty active these days but I never get tired of listening to). I heard an interesting theory about Scrum seen as the &quot;killer app&quot; of Agile. Thanks to this killer app, the Agile word spread across the IT world, from the developer up to higher management. Like with Rails, many started to learn more about Ruby after working with the web framework. So if Scrum is the Rails of Agile, what is the language? In my opinion the language is Craftsmanship or all the detailed technical practices that Scrum doesn't address directly. This is the reason why Uncle Bob is consulting on practices in those companies where Scrum just got popularity.

<DT><A HREF="http://www.infoq.com/news/2009/01/classic-mockist-tdd" ADD_DATE="1234972540" PRIVATE="0" TOREAD="0" TAGS="tdd,mocking,mock,testing,test,agile,xp,jmock">InfoQ: &quot;Classic&quot; versus &quot;Mockist&quot; TDD, Distinction Real?</A>
<DD>There was a time I was always mocking collaborators as part of the process. This introduces a big overhead because mocks aren't free (speaking of test maintenance and readability). I now adopted a lighter approach where I mix classic and mock based TDD based on the complexity of the interaction and the need to mock out collaborators that are too demanding (read distracting) for the feature in development. It's good to see the distinction discussed and I agree with Nat Price (co-author of JMock) that mocking is a tool for TDD not the test driven process itself.

<DT><A HREF="http://blog.asmartbear.com/blog/joy-of-honesty-in-business-a-5-part-series.html" ADD_DATE="1234972064" PRIVATE="0" TOREAD="0" TAGS="marketing,honesty,business">Joy of Honesty in Business: A 5-part Series - SmartBear</A>
<DD>&quot;A Smart Bear&quot; is a well written and smart blog. This series of 5 articles is about honesty in business. The &quot;discount gambit&quot; problem is when you don't see the floor of a price, when if you insist you get an order magnitude discount, something I heard recently about Dell where you know that the advertised price is just for losers and winners buy through a sale person instead. What I like about Apple? I know I don't need to waste time trading for a different price. Second article suggests to sign an addendum to the contract of the actual employer if you're developing a side project stating there are no business conflicts. Third article is about honesty as a marketing feature (!) when just being honest differentiate yourself from everyone else. Article number 4 is about &quot;smallness&quot; like using the &quot;we&quot; in a one man shop. Waiting for the article number 5 of the set. Jason Cohen's blog is full of original ideas: I call it Agile business.

<DT><A HREF="http://www.rubyology.com/podcasts/show/73" ADD_DATE="1234902564" PRIVATE="0" TOREAD="0" TAGS="ui,design,javascript,css,unobtrusive">Rubyology - OpenRain - JS and CSS</A>
<DD>I heard a great discussion about unobtrusive javascript and CSS in this episode of Rubiology. The discussion opens with a Prototype vs jQuery match but the discussion is more about Prototype and jQuery versus YUI and Dojo. Of course it depends on the context and specifically if the need for javascript is for widgets or dom access. Then unobtrusive JS pros and cons. Good to remove the visual cluttering of JS out of the HTML, bad when CSS and javascript load with slightly different timings and temporal dependencies are broken. There are hacks to make javascript wait the relevant CSS. The discussion goes on to CSS vs HTML tables. Amazing how much I learned from a single podcast.

<DT><A HREF="http://www.jonathancrossland.com/post/TalkWare-Episode-2-with-Kent-Beck.aspx" ADD_DATE="1234801342" PRIVATE="0" TOREAD="0" TAGS="kentbeck,agile,xp,junitmax,values">TalkWare Episode 2 with Kent Beck</A>
<DD>Enjoyable chatting with Mr Beck driven by good questions from Jonathan Crossland, the author of this fairly new podcast. When I hear Kent Beck talking I always learn something new and important. Kent's take on DSL is that if they are used to substitute customer communication that's not good. He moved from a prescriptive approach to XP to a more adaptable &quot;what is working for you and why&quot; kind of approach. I was not surprised to hear the answer to do you test all the time: Kent does what everybody should do. It's a trade off about what you gain and the effort you need to put into the test phase. So he left out the Eclipse-side of JUnit max for a while to make the product shippable. Testing is a two sides effort: writing the tests and run them. The run side is what Kent is doing these days with JUnitMax. An early attempt done when he was with Agitar was not as successful.

<DT><A HREF="http://blog.stackoverflow.com/2009/02/podcast-41/" ADD_DATE="1234539331" PRIVATE="0" TOREAD="0" TAGS="agile,quality,podcast,unclebob,startup">Podcast #41 - Blog - Stack Overflow</A>
<DD>Ha! Way too politically correct (you need to listen stackoverflow 38 to understand this). Or maybe this is how things should be. I had the impression that Jeff and Joel agreed that the wrong thing was to be so harsh and offensive about quality code and TDD but they stay on their respective positions.

<DT><A HREF="http://www.viddler.com/explore/oredev/videos/15/" ADD_DATE="1234537249" PRIVATE="0" TOREAD="0" TAGS="unclebob,agile,cleancode,oredev,video,smells">Uncle Bob - Øredev 2008 - Clean Code III: Functions</A>
<DD>The Clean Code book by Bob Martin is still sitting on the book shelf. I'd like to find the level of attention ant time to read it and that day is coming closer. In the meanwhile I managed to have an impression about what's inside the book through this presentation at Øredev. I know you can get just an impression considering the many skipped slides. This is the kind of book you want to read if you care about the details of clean everyday programming with an eye on principles and the high-level design. There are interesting challenges in the presentation like trying to understand messy code in 3 minutes. Listening to Bob talking is never boring, give it shot.

<DT><A HREF="http://www.patmaddox.com/blog/2009/1/22/oo-minifesto" ADD_DATE="1234448752" PRIVATE="0" TOREAD="0" TAGS="OO,solid,design,principles,refactoring,TDD">Pat Maddox - OO Minifesto</A>
<DD>I like Pat's application of the SOLID principles on top of a simple example. This is the kind of inquisitive behavior that the SOLID principles should guide you through. But, I think that the &quot;action&quot; that the principle is calling for should be driven by a business requirement. What I do is I take note of the possible smell/refactoring but I don't apply it right away. I wait until another business requirement call for the refactoring and at that point I reevaluate the need for generalization/refactoring. If that still holds true, I apply the principle. In my opinion, this is YAGNI and prevent premature generalization.

<DT><A HREF="http://blog.jayfields.com/2009/01/questions-to-ask-interviewer.html" ADD_DATE="1234447391" PRIVATE="0" TOREAD="0" TAGS="questions,interview,hiring,career,job">Jay Fields' Thoughts: Questions To Ask an Interviewer</A>
<DD>Here's a starting point for that tricky question you are asked usually at the end of an interview. Do you have any questions for us? I remember that my questions are often related to the process and the organization. I try to be inquisitive about buzzwords used by the interviewer and I always ask something like: &quot;if you decide I'm the right person for you, what kind of role do you see for myself in your company?&quot; I try to understand if they are hiring with a long term plan in mind or just because they have some urgent need at the moment.

<DT><A HREF="http://www.mobileorchard.com/99-cent-iphone-apps-not-significantly-more-popular/" ADD_DATE="1234360444" PRIVATE="0" TOREAD="0" TAGS="iphone,marketing,statistics,itunes,guitartoolkit">99 Cent iPhone Apps Not Significantly More Popular</A>
<DD>Again on the topic of &quot;fairness&quot; at the iTunes store. There seem to be an uniform distribution of applications on price bands and popularity with no interesting skew. But as Jack was saying at the MobileOrchard podcast the other day, there is no way to correlate quality. What is quality for an iPhone app? Is quality of support, quantity of bugs, quantity of releases before the product disappear, speed in fixing issues and in general reliability. I understand it's difficult to track these important metrics but the &quot;popularity&quot; only is not a good enough indicator over time. For this reason, very good application drop out from the top 100 too quickly.

<DT><A HREF="http://www.hanselminutes.com/default.aspx?showID=158" ADD_DATE="1234278336" PRIVATE="0" TOREAD="0" TAGS="ddd,design,patterns,podcast">Rob Conery limps and learns about Domain Driven Design Hanselminutes</A>
<DD>I tried several times to understand what DDD is. At the end I always have this feeling of patterns of enterprise architectures plus a process where the design is upfront like the old RUP school. Clearly my effort is not enough but at least I know that I'm not alone struggling with the definition. In this podcast, Rob and Scott decided they are not in the position to give us a definition but nevertheless they are telling us where to start to understand DDD principles. I appreciated the effort and the good conversation. Also notice the difference: if this was StackOverflow podcast I'm pretty sure that instead of declaring their ignorance, Joel and Jeff would probably bash DDD as an useless acronym since their business does great already without it. Same happened to SOLID.

<DT><A HREF="http://www.cocoacast.com/?q=node/185" ADD_DATE="1234199540" PRIVATE="0" TOREAD="0" TAGS="agilepartners,guitartoolkit,jack,podcast,agile,values">Cocoacast Talk Episode 21- Interview with Jack Ivers</A>
<DD>Jack is for sure a great evangelist of GuitarToolkit and my company products in general. I'm not saying this just because he's my boss :) He received some tricky questions triggered from the company name: how can you think that a company named AgilePartners is not using state of the art Agile processes? Well we aren't. There are experimenters as usual, using practices here and there. The truth is that AgilePartners works great for the presence of bright programmers and managers who are self-disciplined and the entire company seems to be based on self-discipline as a result. But another truth is that we'll never know if we are even capable of more until the formal application of a software process (and maybe the consequent refusal of the process) is in place. In the meanwhile, I'm glad to see that typical agile values (as from the manifesto) are already part of the company.

<DT><A HREF="http://push.cx/2009/open-source-communities" ADD_DATE="1233953177" PRIVATE="0" TOREAD="0" TAGS="web,framework,django,rails,community">Open Source Communities - Push cx</A>
<DD>A brave attempt to compare Django and Rails and crystallize a definition of success for a web framework. You can disagree with Peter analysis (many did in the comments) but the article is more a platform for discussion about what define a successful community. Why Django? Why Rails? Why not Lift (Scala), Seaside (Smalltalk), Grails (Groovy)? I think that before Rails it was not such an evident fact that the key success for a language (the so called killer app) was the creation of a web framework on top of it. Rails made that evident first by leveraging a very specific segment of applications (web-apps targeted at small-medium businesses). So today if you hear about a successful new language you can be sure a web framework is growing along with it. Rails was the first and hence why it's more popular. But I agree that popularity is not the only measure for success.

<DT><A HREF="http://push.cx/2009/rules-of-database-app-aging" ADD_DATE="1233951528" PRIVATE="0" TOREAD="0" TAGS="db,database,ormapping,mapping,rdb">Rules of Database App Aging - Push cx</A>
<DD>How true is that! I never thought about it, but databases always show similar aging patterns. I'm also thinking that Rails approach to database mapping changed the way I think upfront at the database design. In the Java age I was much more careful about attributes and their properties (such as null-ability) because the cost of change was huge, even with Hibernate and Spring. Rails convention over configuration approach is the first help in this direction: I don't need to think about database design right now, because there is a default. Second, it's so easy to change decisions later that database design it's purely evolutive. To summarize: the way Rails approaches database design is such that many typical db aging signs don't appear: many to many relationships and nullable fields are there from the beginning unless you put an explicit effort against it.

<DT><A HREF="http://blog.jayfields.com/2009/01/most-java-unit-tests-consist-of-class.html" ADD_DATE="1233950306" PRIVATE="0" TOREAD="0" TAGS="mock,tdd,builder,testing">Jay Fields' Thoughts: Creating Objects in Java Unit Tests</A>
<DD>Here's a nicely written article with examples that describes all the possible types of test doubles. I think I've used all of them in one way or another and I'm glad there is a more formal definition. I also learned about the builder pattern which I'll be happy to try as soon as I have a chance. It looks promising to use a very DSL-ish and fluent API to build test doubles. I'm also hearing over and over again about Mockito. If I ever turn back to Java I will sure give it a try.

<DT><A HREF="http://www.joelonsoftware.com/articles/LeakyAbstractions.html" ADD_DATE="1233762998" PRIVATE="0" TOREAD="0" TAGS="joel,abstraction,model,knowledge">The Law of Leaky Abstractions - Joel on Software</A>
<DD>True. Abstractions are leaking mechanisms by default. There is no such a thing like the perfect abstraction, there are only models close to perfection. Like genes, fittest abstractions survive multiple generations until a better model is found. Even Joel's post is an abstraction on abstractions: it describes very well that even though you master some new technology you should also know about the low level details behind it to fix the issues when the abstraction leaks. Very good reading.

<DT><A HREF="http://web20show.com/episodes/episode-49-obie-fernandez" ADD_DATE="1233595524" PRIVATE="0" TOREAD="0" TAGS="audio,podcast,obie,hashrocket">The Web 2.0 Show - Episode 49 - Obie Fernandez</A>
<DD>Can we always have torrents of rain and thunders as a background noise? So relaxing. By the way, great interview. Obie deserves all the possible interest and respect for his career and what he's doing right now at Hashrocket. In this podcast you'll hear about key decision he made in the past and for the future, how to deal with a success company, the internals of the 3-2-1 program and many more. Two things I want to talk about. He honestly admitted that the first release of the 3-2-1 program was not practically achievable. I appreciate his honesty and I remember since the beginning that he was always clear about the meaning of 3 days of work for a fully working app. Today the 3-2-1 program is a 3 weeks work with a 3 days guest-stars on site. The second original idea is the guest-star program. It is for sure very productive and effective to have kick-ass developers on site pairing with your developer for a few days. Go and listen.

<DT><A HREF="http://www.pathf.com/blogs/2009/01/creating-and-distributing-your-own-gem-a-quick-rundown/" ADD_DATE="1233593414" PRIVATE="0" TOREAD="0" TAGS="tutorial,gem,ruby,github">Agile Ajax » Creating and Distributing your own gem: a quick rundown » Pathfinder Development</A>
<DD>A good starting point to add your gem to github. I followed it realizing I didn't need a gem. But excluding the gem related features leaves you with a nice clean application tree anyway. Newgem will create everything you need and more. The script/console borrowed from Rails is a quick debugging tool to load the project classes and play with them. I changed it to run macirb instead.

<DT><A HREF="http://www.infoq.com/news/2009/01/Burn-Stories-Not-Tasks" ADD_DATE="1233349792" PRIVATE="0" TOREAD="0" TAGS="agile,stories,planning,tasks,userstories">InfoQ: Burn Stories Not Tasks</A>
<DD>Burning stories is especially important because stories are customer driven pieces of functionalities. I found here a good definition of story: 1. adds some value to the product 2. is user visible 3. stands alone 4. is testable. Those &quot;technical&quot; stories that sometimes the team scream for could be seen as stories but not from the customer perspective. For this reason they have a different box on the wall most of the time. Focusing on task (and task only) is also wrong for the same reason: your satisfaction as a developer must synchronize with the value added to the product from the customer perspective. If that doesn't happen, bad surprises can happen during the showcase when nobody can understand why developers are so happy.

<DT><A HREF="http://www.spacevatican.org/2008/9/28/required-or-not" ADD_DATE="1233346956" PRIVATE="0" TOREAD="0" TAGS="rails,const_missing,reload,hotswap">Space Vatican : Required or Not ?</A>
<DD>Fascinating and helpful in-depth into the const_missing hook up by Rails. This is the mechanism Rails uses in development mode to reload classes and make everything extra smooth for fast development. Except that sometimes thing doesn't work as expected. The mechanism is not fragile, it is instead the assumption that in Rails I can do everything that I can do in standard Ruby. Well, not always. Requiring a model class explicitly is one of those cases. If you really need to, there are specific ways to do this (require_dependencies) that keep Rails in the loop.

<DT><A HREF="http://www.betaversion.org/~stefano/linotype/news/243/" ADD_DATE="1233328951" PRIVATE="0" TOREAD="0" TAGS="cognitive,thinking,divergent,convergent,creativity">Stefano’s Linotype » Blog Archive » Convergent vs. Divergent Thinking</A>
<DD>I always enjoy reading Stefano's posts. This time I learned about the formal definition of something I knew about in a more intuitive way. Convergent or divergent thinking. We often imply that more intelligent people have a great convergent thinking capabilities, which means they can abstract really well a problem into higher forms of knowledge and reuse the new abstractions to solve the next problem. Although this is a very good quality to have, divergent thinking is also a very important component especially for creativity and research. Of course if you are a very good divergent thinker you're not less intelligent than other people but just as good. Divergent thinking requires practice and study as convergent one and it's a great quality to have. People with both are very lucky: this is Why The Lucky Stiff.

<DT><A HREF="http://blog.stackoverflow.com/2009/01/podcast-38/" ADD_DATE="1233328432" PRIVATE="0" TOREAD="0" TAGS="design,tdd,solid,agile,podcast,stackoverflow">Podcast #38 - Blog - Stack Overflow</A>
<DD>I enjoy the podcast of Jeff and Joel since episode 1. They talk about interesting things and usually with a critical eye toward agility and being &quot;Agile&quot;. This episode contains a critique to the SOLID principles of uncle Bob. I disagree. Joel started from the wrong assumptions about SOLID. They are not applied in the vacuum. At least the way I apply those principles is the following: I use TDD to drive my design and acceptances test to verify the customer expectations. Before I can apply one of those principles I wait until I feel &quot;the bad smell&quot;. In other word, I keep evolving the design developing new business feature. In the podcast instead, Joel seems to imply principles are applied in any case, ahead of a code smell or business requirements. I don't think this is the case.

<DT><A HREF="http://psacake.com/web/jl.asp" ADD_DATE="1233179500" PRIVATE="0" TOREAD="0" TAGS="css,stylesheet,ui,design">Pure CSS Tooltips</A>
<DD>Just plain easy display of tooltips in pure CSS 100%. With this solution you don't need to use any javascript at all. With a simple trick you can even use an image as hyperlink and instead of render the box as a square, you can render the shape you like, maybe with transparent gif. It's just a few lines of CSS worth trying.

<DT><A HREF="http://www.contrast.ie/blog/killing-distractions/" ADD_DATE="1233097810" PRIVATE="0" TOREAD="0" TAGS="productivity,gtd,tomato,distractions,discipline">Contrast | The Blog | Killing distractions</A>
<DD>I enjoyed this easy reading and I want to remember a few things about it, because I'm dealing with the same kind of problems here. The key to kill distractions is discipline of course. Most of the time I set rules, I time box things that are not related to the main work I'm supposed to do or I schedule them for specific part of the day. The problem is then that even if the rules are in place you have to obey them and here comes the difficult part. Something I think is strictly necessary is to remove ping events of any kind: sounds, growls, little messages here and there, everything. At least this works for me. If I don't remove balloons and the alike, especially when I'm tired, I sub-consciously follow the alert and I find my self reading something. It's also true that you need to follow things. This is why the tomato technique is so effective: I have 5 full minutes every 25 to get distracted. And it's enough.

<DT><A HREF="http://blog.obiefernandez.com/content/2009/01/top-ten-attributes-of-good-clients.html" ADD_DATE="1232738760" PRIVATE="0" TOREAD="0" TAGS="customer,management,manager,coaching,agile,clients">Obie Fernandez: Top Ten Attributes of Good Clients</A>
<DD>A paying customer is of course a good customer but it's clearly not enough to define what is &quot;good&quot;. The relationship with the customer impacts the good health of the project and the effort you have to put in as a team to implement requirements. Maybe you're very good at dealing with &quot;bad&quot; customers anyway but how much frustration and tension are you willing to tolerate? Why tolerate? So here's a nice list from Obie on how to define a good customer. Even more important to me is: given this list and a bad customer what can I do to educate the customer? Even if I could jump from customer to customer until I found the self-educated one, I think it's my responsibility as a coach or project manager to educate the customer because she's part of the team. A good follow up to this list would be what action can I take to transform my customer into a good one. Next blog post.

<DT><A HREF="http://www.al3x.net/2008/12/03/how-i-use-textmate.html" ADD_DATE="1232724569" PRIVATE="0" TOREAD="0" TAGS="textmate,plugins,bundles">Alex Payne | How I Use TextMate</A>
<DD>This is a good bookmark to start with for a new TextMate from scratch installation. The 3 add-ons listed are kind of necessary ones. I'd probably add a few more: the RailsCast color theme, the Tasks bundle and the wonderful RubyAmp. I never found the &quot;find in project&quot; built in function in TextMate to be so slow. Maybe my projects are not big enough. I decided to give Ack a spin and see how it goes. It's faster, so it can't be too bad! ProjectPlus instead is a really nice one too to replace the crappy standard navigator window. But I'm still investigating why creating a new directory (ctrl+apple+G) doesn't work for me. Finally: GetBundles. I used this in the past, but now it's shiny new and connect to the github repository. A must have.

<DT><A HREF="http://www.igvita.com/2008/12/27/scalable-datasets-bloom-filters-in-ruby/" ADD_DATE="1232642884" PRIVATE="0" TOREAD="0" TAGS="algorithm,hashtable,bloom,cache">Scalable Datasets: Bloom Filters in Ruby - igvita.com</A>
<DD>Bloom filters are essentially hash-table of keys without values. An element in the bloom is represented as a map of bits scattered through a larger array. To know if an element is in the set you need to know which bits in the array to look for and if they are all set to 1. The big deal is that a bloom filter is extremely space optimized. A 10k words dictionary can stay in around 18KB (with a 0.1% error rate). One of the best possible use is as a first lookup stage for a cache. Instead of asking the hash-table about the existence of the element, you ask the bloom filter which is much more efficient. Google uses a bloom filter in Bigtable. There is a library in Ruby you can use to create bloom filters described in this article. Interesting thing to know about and keep in mind for the next app.

<DT><A HREF="http://rubyconf2008.confreaks.com/how-ruby-can-be-fast.html" ADD_DATE="1232568475" PRIVATE="0" TOREAD="0" TAGS="video,performances,vm,virtualmachine,compilers,ruby,yarv,rubinius">How Ruby Can Be Fast - RubyConf 2008</A>
<DD>Compilers and virtual machines are applications on their own. As such, as soon as you understand the business domain, many programming tricks apply to them like for other apps. For example caching. Optimization for a virtual machine or for the garbage collector often means to pre-compile and run portion of codes that doesn't change. It also means to understand object lifetime, how many of them are short lived or long lived. In general it means to learn about the application under execution while it is executing and apply the relevant optimization. In this presentation, Glenn Vanderburg, explains all the common problems modern VM are facing today and what is missing in the current Ruby VMs implementation. There are also useful hints for the perfectionist programmer who likes to optimize the code: most of the the time that's just a waste of time and counterproductive.

<DT><A HREF="http://www.infoq.com/presentations/francl-testing-overrated" ADD_DATE="1232567363" PRIVATE="0" TOREAD="0" TAGS="tdd,testing,video,rubyfringe,coverage">Testing is Overrated</A>
<DD>There are some good thoughts inside this presentation. But it seems not to consider tdd. Without the focus on features to implement and to the business rules first, metrics like coverage or code reviews become more the final goal than the feedback tool.
I know that if I want 100% coverage on something I can force it pretty easily. Of course that's not the point. When I write tests first I don't consider coverage, I only want those features the customer need to appear in the code. Then I look at the coverage and if it's low I ask myself why.
He also claims that there is a tendency not to hire QAs if there is a lot of development testing. I never saw anything like that in my experience or heard someone thinking test automation can replace testers. So the title should read something like &quot;Coverage is overrated&quot; and explain why metrics, code reviews and developer testing is not enough to guarantee the project success.

<DT><A HREF="http://www.ibiblio.org/harris/500milemail.html" ADD_DATE="1232478912" PRIVATE="0" TOREAD="0" TAGS="debugging,failure,entertaining,example">The case of the 500-mile email</A>
<DD>This is an emblematic example of how far the root of a problem can manifest away from itself. How can a mail send action fail only if the mail is going geographically 500 miles away? How could such a strange correlation exist? I bet we all had to fight with some strange debugging session like this one at least once in our programming life. The lesson here is that no change can be considered 100% safe even when all variables have been taken into account. There is always something that can go wrong. Overall a short and entertaining reading to use as an example for the next presentation.

<DT><A HREF="http://www.hanselminutes.com/default.aspx?showID=164" ADD_DATE="1232478427" PRIVATE="0" TOREAD="0" TAGS="tdd,design,audio,mp3,podcast,bdd">Hanselminutes - Test Driven Development is Design - The Last Word on TDD</A>
<DD>In this podcast I heard the best explanation so far on why the word &quot;test&quot; in test driven development can be so counterintuitive and deceiving. From the argument against &quot;test&quot; the whole BDD Behavior Driven Development movement took off. The summary is: TDD is all about evolutive design, not necessarily testing. It just happens that test tools used to evolve the design through test-first are the same used by the more common unit testing. TDD failed to convey the idea of evolutionary design because the name is so strongly evocative of &quot;unit of test&quot;. Overall a nice conversation to remember. Audio.

<DT><A HREF="http://rubyconf2008.confreaks.com/macruby-ruby-for-your-mac.html" ADD_DATE="1232156372" PRIVATE="0" TOREAD="0" TAGS="macruby,rubyconf,video">MacRuby: Ruby for your Mac Confreaks RubyConf 2008</A>
<DD>Not so impressed. Yes there is good content but I was expecting some more in-depth details about how MacRuby works internally. From the end user point of view I learned a couple of things about interacting with Mac Os X native applications and macirb. Laurent doesn't mention macgem for example. There is also a practical demonstration of what can happen if you mess up with Mac Os internals. It looks like after Laurent did a couple of tricks with macirb the New Project functionality in XCode stopped working. Anyway, good introduction material to MacRuby.

<DT><A HREF="http://onestepback.org/articles/poly/index.html" ADD_DATE="1232154852" PRIVATE="0" TOREAD="0" TAGS="languages,oo,shape">OO Example in all languages</A>
<DD>This is a nice collection maintained by Jim Weirich of the same classic OO shape example written in many languages. There are interesting things that differ about the syntax, constructs or lack thereof. Yes because there are also not OO languages in the list. Big absent: Brainfuck. More elegant: Clojure. More awkward: sed.

<DT><A HREF="http://steve.yegge.googlepages.com/practicing-programming" ADD_DATE="1232153171" PRIVATE="0" TOREAD="0" TAGS="motivational,craftsmanship,practice,mustread">Stevey's Home Page - Practicing Programming</A>
<DD>What an amazing reading. This essay is about how to practice programming when it's clear that all the other older professions already have some codified way of doing it. There are 12 drills in the article (things you can quickly put into practice about programming as whole). At the recent Software Craftsmanship Symposium we discussed about several possible interview questions and I'm glad to find them here again. Steve Yegge uses the musician skills and practice tools as example for programmers. I have to say I learned a lot also as a musician from this article! I also found out that the habit I have to read about computer science history on Wikipedia is one of the drill. But I don't practice many others apart from that and so there is clearly space for improvement. As usual. Also read carefully the Interviewing pills at the bottom. I think there is everything you need to know to be a great interviewer (and interviewee). Must read.

<DT><A HREF="http://rubyconf2008.confreaks.com/os-x-application-development-with-hotcocoa.html" ADD_DATE="1231975355" PRIVATE="0" TOREAD="0" TAGS="macruby,hotcocoa,confreaks,rubyconf">OS X Application Development with HotCocoa - Rich Kilmer</A>
<DD>Of course you need to be interested in MacRuby and HotCocoa to watch this presentation. I can tell you that at least right know there are not many more other sources of information to look for. Especially if we speak about HotCocoa. For example the mappings mechanism, one of the key to understand HotCocoa. Opening existing mappings is a very good source of documentation about what is available for a specific Cocoa widget. it's very likely you will end up creating your own mappings: first because Cocoa widgets are so many and there is no need to try to map all of them up-front. Second because the set provided with HotCocoa is as of today just a small fraction. As Rich told the public, he's adding new mappings whenever the target application requires something new. Overall an interesting presentation. You may want to check-out also Laurent Sansonetti's MacRuby presentation from ConfFreaks as well.

<DT><A HREF="http://www.hanselminutes.com/default.aspx?showID=163" ADD_DATE="1231779825" PRIVATE="0" TOREAD="0" TAGS="audio,podcast,unclebob,solid,oo,objectoriented,software,engineering,design">Hanselminutes SOLID Principles with Uncle Bob</A>
<DD>I know, this is old stuff. Uncle Bob started talking about these principles in the C++ era around late 80-ies. But this is a wonderful podcast to listen to carefully again and again. Uncle Bob explains in few sentences the S.O.L.I.D. principles with unmatched clarity and entertainment. SRP, OCP, LSP, ISP and DIP should be printed on the wall in front of your desk and used continuously during software development even in those cases where an exception to the principle is needed. In the interview is also stated in which way the principles should be applied and how the should be part of your day to day developing life. Extremely recommended.

<DT><A HREF="http://www.cs.bham.ac.uk/~axj/pub/papers/lambda-calculus.pdf" ADD_DATE="1231546476" PRIVATE="0" TOREAD="0" TAGS="lambda,lisp,clojure,church">A short introduction to Lambda Calculus - Achim Jung</A>
<DD>At some point I found this accessible paper explaining Lambda calculus. Accessible is yet not enough for my poor mathematical skills so expect some formula. Some math skills should be expected when talking about a new notation for mathematical functions! The first few lines read almost like LISP. No surprises that the functional paradigms is inspired by the work of Alonso Church. I think this paper is a good reading especially the first part describing the foundations.

<DT><A HREF="http://assets.pivotallabs.com/talks/08-13-2008_SCRUM_Christian-Sepulveda.mov" ADD_DATE="1231545497" PRIVATE="0" TOREAD="0" TAGS="scrum,agile,pivotal,filetype:mov,media:video">Scrum by Christian Sepulveda at Pivotal Labs</A>
<DD>This is a lean introduction to Scrum with no marketing emphasis, good comparison with XP practices and applicability and answer to common questions. There is also the audio version available.

<DT><A HREF="http://www.robertsosinski.com/2008/12/21/understanding-ruby-blocks-procs-and-lambdas/" ADD_DATE="1231373458" PRIVATE="0" TOREAD="0" TAGS="ruby,procs,lambda,closures">Robert Sosinski » Understanding Ruby Blocks, Procs and Lambdas</A>
<DD>A clean introduction to blocks, procs, lambdas and methods in Ruby. An example is given to explain the main concept, then differences are explained and finally use case scenarios are given. I appreciated the clarity and the fact that the article is reasonably sized. My take away: lambdas and Method objects are more intuitive to me, because they don't return the method they are passed in. I just don't expect that jump out.

<DT><A HREF="http://en.wikipedia.org/wiki/Joy_programming_language" ADD_DATE="1231359047" PRIVATE="0" TOREAD="0" TAGS="languages,functional,concatenative">Joy (programming language) - Wikipedia, the free encyclopedia</A>
<DD>Joy is a stack based concatenating language. It's functional but is not based on lambda calculus as List for example. For this reason the main difference is the absence of function decelerator like lambda and formal parameters declaration. This is not needed because everything is assumed to be passed inside an implicit stack from where literals and intermediate values are taken. It is like always passing a generic stack parameter to all functions so there is no need to declare it. It remembers me of a Turing Machine where states aren't explicit.

<DT><A HREF="http://furbo.org/2008/12/09/ring-tone-apps/" ADD_DATE="1231352873" PRIVATE="0" TOREAD="0" TAGS="iphone,marketing">furbo.org · Ringtone apps</A>
<DD>In this open letter developers of Twitterrific iPhone complain about the opportunity/cost of creating smarter iPhone apps requiring more effort to develop. The kind of exposure a good application gets on the AppleStore seems to be related to the price. The lower the price, the more average customer reviews on the app. That's not wrong in principle, but the problem is that in the absence of other marketing mechanisms from Apple, it doesn't make a lot sense to create more sophisticated app that could not sell for 99c.

<DT><A HREF="http://blip.tv/file/1578541/" ADD_DATE="1230594227" PRIVATE="0" TOREAD="0" TAGS="video,rails,performances,caching">Paris On Rails 2008 Michael Koziarski</A>
<DD>A very well done presentation by Michael Koziarski at Paris On Rails. There are the obvious things about performance tuning, but they are well explained and displayed with examples. There are also the not-so-obvious things. What I appreciated the most is the fact that the process is explained top to bottom making this presentation a reference if you need to start improving performances on your Rails app.

<DT><A HREF="http://www.robbyonrails.com/articles/2008/12/14/launching-ruby-on-rails-projects-a-checklist" ADD_DATE="1230338229" PRIVATE="0" TOREAD="0" TAGS="rails,hints,checklist,production">Robby on Rails : Launching Ruby on Rails projects, a checklist</A>
<DD>A nice checklist before going into production with our brand new Rails project. We (developers) are always so focused on user stories that we forget about the fact that the release is just the beginning of our customer journey not the end.

<DT><A HREF="http://alistapart.com/articles/gettingrealaboutagiledesign" ADD_DATE="1230335949" PRIVATE="0" TOREAD="0" TAGS="agile,design">A List Apart: Articles: Getting Real About Agile Design</A>
<DD>I'm often experiencing in projects the eternal fight between the design team and the development team. What happens is always a variation of the following: the design team waiting for the business analysts to converge on the final design and the development team waiting to connect to the final design to close the user story. In an agile project where documentation should be light, comps and/or very realistic wireframes are the equivalent of hundreds pages of requirement docs. The approach should be more sketch based and evolutive also for the UI. If that happens then this is not unrealistic: designers research on n+2, design on n+1, support iteration n and review n-1 where n is the iteration number. I understand that the big problem can be convincing the user to accept small increment of the application, design included. But if that fails is our (IT developers and managers) fault.

<DT><A HREF="http://www.betaversion.org/~stefano/linotype/news/169/" ADD_DATE="1230135996" PRIVATE="0" TOREAD="0" TAGS="css,design,web,stefano">Stefano’s Linotype » Blog Archive » Why Programmers Suck at CSS Design</A>
<DD>After reading Stefano's explanation about CSS in the form of this tutorial, I think the best take away are all the links to get started about CSS design. Following those links and the first part of the tutorial you should be able to create a skeleton CSS which at least doesn't suck and deploy something to the public.

<DT><A HREF="http://blog.fiveruns.com/2008/8/6/quickly-switching-between-different-rails-releases-with-git" ADD_DATE="1230069460" PRIVATE="0" TOREAD="0" TAGS="rails,spike">Quickly Switching Between Rails Versions</A>
<DD>I followed these steps to quickly have an embedded Rails version x.x into a spike project. Very useful if you want to quickly test something on a specific version of Rails without the need of gem install anything. If instead of generating the spike app you git clone Bort then you also have specs and a bunch of other useful things ready to go.

<DT><A HREF="http://www.threeriversinstitute.org/HitEmHighHitEmLow.html" ADD_DATE="1229547481" PRIVATE="0" TOREAD="0" TAGS="tdd,testing,saffsqueeze,techniques,kentbeck">Hit 'Em High, Hit 'Em Low</A>
<DD>Saff Squeeze AKA disciplined inline instead of jumping into a debugger or manual reproducing the bug. This technique replaces what I usually do when I need to fix a bug. I manually run the app and using a couple of println I search what a value should be for the problem to not happen. Then I create a test to assert that excepted value. In saff squeeze it's a test that will tell you what value should be expected, with the result that the test has been driven by inlining the code backward. This way the test is very selective and focused on the bug and you don't need to understand it by approximation.

<DT><A HREF="http://www.gamasutra.com/view/feature/3847/beyond_scrum_lean_and_kanban_for_.php?print=1" ADD_DATE="1228949258" PRIVATE="0" TOREAD="0" TAGS="kanban,optimization,production,lean,agile">http://www.gamasutra.com/view/feature/3847/beyond_scrum_lean_and_kanban_for_.php?print=1</A>
<DD>Kanban looks promising after the product shipped or has reached a steady development cycle where &quot;user stories&quot; repeat and the production chain can be tweaked for productivity.

<DT><A HREF="http://startuplessonslearned.blogspot.com/2008/09/one-line-split-test-or-how-to-ab-all.html" ADD_DATE="1228945787" PRIVATE="0" TOREAD="0" TAGS="testing,a/b,roll-out,split-testing">Lessons Learned: The one line split-test, or how to A/B all the time</A>
<DD>Split testing is a way to organize code during the roll out of a new functionality so that the old and the new application co-exists at the same time. The application will collect statistics about the behavior of the user with the old and the new functionality to grab information on how good the decision was. This article introduces the subject and at the bottom there is a much more detailed paper.

<DT><A HREF="http://podcast.rubyonrails.org/programs/1/episodes/monty-williams-on-maglev" ADD_DATE="1228757867" PRIVATE="0" TOREAD="0" TAGS="podcast,maglev,ruby,smalltalk">Monty Williams on MagLev | the Ruby on Rails Podcast</A>
<DD>An interesting walk through the steps required to make a new Ruby implementation compliant with the Ruby specifications.

<DT><A HREF="http://www.agilemanagement.net/Articles/Weblog/Whywelostfocusondevelopme.html" ADD_DATE="1228744958" PRIVATE="0" TOREAD="0" TAGS="management,agile,craftsmanship">Why We Lost Focus on Development Practices</A>
<DD>David Anderson thinks that the lost of focus on pure development practices advocated by the software as a craftsmanship movement is because developers aren't the bottleneck but management is. Does this means that the developer community has reached their momentum and they don't need any more innovation? I think the forces behind Agile are coming from developers and management should adapt to the new way of thinking. The focus should always be on developers in any case.

<DT><A HREF="http://nubyonrails.com/articles/emacs-emacs" ADD_DATE="1228574816" PRIVATE="0" TOREAD="0" TAGS="emacs,editor,productivity,tutorial">Emacs? Emacs. | Ruby on Rails for Newbies</A>
<DD>If I ever decide to start developing with a new editor I'd give Emacs a try for sure. This is a simple tutorial to get you started from a TextMate/Mac persepctive by Goffrey Rosenback. Many interesting suggestions are also in the comment and a Peepcast is soon to come.

<DT><A HREF="http://drnicwilliams.com/2008/12/05/my-rubygems-development-tools-and-workflow/" ADD_DATE="1228485803" PRIVATE="0" TOREAD="0" TAGS="gem,git,package,drnic,ruby">Dr Nic » My RubyGems development tools and workflow</A>
<DD>Dr Nic illustrates a step by step workflow to package a gem, distribute it and connecting the source code to continuous integration. Open the slides of the presentation from the page. Examples of newgem, git, runcoderun.

<DT><A HREF="http://jasonrudolph.com/blog/2008/12/02/textmate-oldie-but-goodie-wrap-up/" ADD_DATE="1228313419" PRIVATE="0" TOREAD="0" TAGS="textmate,keyboard,shortcut,productivity">:jasonrudolph =&gt; :blog » Blog Archive » TextMate Oldie But Goodie Wrap-up</A>
<DD>Definitive collection of TextMate tips, mainly keyboard shortcut. Some of them are just a must use. Jason Rudolph is maintaining the list as Tweets at http://search.twitter.com/search?q=TMOBGOTD

<DT><A HREF="http://www.dancres.org/blitzblog/2008/12/02/remodelling/" ADD_DATE="1228247744" PRIVATE="0" TOREAD="0" TAGS="design,engineering,values,principles">Pragmatic Dictator » Remodelling</A>
<DD>Dan Creswell lists what underlining values are responsible for a maintainable code base instead of focusing on tools and frameworks. This list is perfect to explain why &quot;shot gun surgery&quot; kind of approach fails.

<DT><A HREF="http://www.azarask.in/blog/post/socialhistoryjs/" ADD_DATE="1228140334" PRIVATE="0" TOREAD="0" TAGS="css,hack,javascript,blog">Aza’s Thoughts » Vote! How to Detect the Social Sites Your Visitors Use</A>
<DD>Visited links on the browser have different colors based on the site they belong to. This information is &quot;saved&quot; in the CSS style-sheet and can be re-used to know previously clicked social bookmarking site visited by an incoming request. A real hack. Use with caution.

<DT><A HREF="http://github.com/twerth/dotfiles/tree/master" ADD_DATE="1224161138" PRIVATE="0" TOREAD="0" TAGS="vim,configuration,dotfiles">twerth's dotfiles at master — GitHub</A>
<DD>A quite definitive VIM jump start for Rails developers.

<DT><A HREF="http://www.youtube.com/watch?v=m-nwvB7Up_g" ADD_DATE="1221422370" PRIVATE="0" TOREAD="0" TAGS="dsl,acceptances,video,selenium">YouTube - GTAC 2007: Douglas Sellers- CustomInk DSL</A>
<DD>The experience of building a DSL on top of Selenium on Rails that generates Selenium scripting for actual execution. The presentation by Douglas Sellers is really well done and full of insights.

<DT><A HREF="http://szeryf.wordpress.com/2007/06/27/self-referential-many-to-many-relations-in-ruby-on-rails/" ADD_DATE="1220395730" PRIVATE="0" TOREAD="0" TAGS="rails,example,self-referencing">Self-referential many-to-many relations in Ruby on Rails « require ‘brain’</A>
<DD>A good starting point for a many-to-many self-reference implementation.

<DT><A HREF="http://rubyhoedown2008.confreaks.com/07-obie-fernandez-do-the-hustle.html" ADD_DATE="1219524595" PRIVATE="0" TOREAD="0" TAGS="video,talk,obie,business,motivational">Confreaks: Ruby Hoedown 2008</A>
<DD>A short and nice introduction to create your own comapyn success by Obie. Suggestions, books, things to do to create your successful business.

<DT><A HREF="http://www.omnisio.com/startupschool08/david-heinemeier-hansson-at-startup-school-08" ADD_DATE="1217993623" PRIVATE="0" TOREAD="0" TAGS="inspiring,business,dhh">David Heinemeier Hansson at Startup School 08 | Omnisio</A>
<DD>The meaning of targeting the Fortune-5000000 company, the long tail of software development.

<DT><A HREF="http://codetunes.com/2008/07/20/tableless-models-in-rails/" ADD_DATE="1217249964" PRIVATE="0" TOREAD="0" TAGS="tableless,rails,activerecord">Tableless models in Rails</A>
<DD>snippet to create Tableless ActiveRecord models in Rails

<DT><A HREF="http://cse-mjmcl.cse.bris.ac.uk/blog/2007/12/23/1198436217875.html" ADD_DATE="1216961235" PRIVATE="0" TOREAD="0" TAGS="chart,twittrack">Sparklines (Google Analytics Style) with Google Chart API - Mark McLaren's Weblog</A>
<DD>Rendering of Google Analytics like sparklines via Google Chart API

<DT><A HREF="http://wiki.jboss.org/wiki/JBossASTuningSliming" ADD_DATE="1215638828" PRIVATE="0" TOREAD="0" TAGS="jboss">JBossWiki : JBossASTuningSliming</A>
<DD>The definitive list of removable jboss service in searching for ultimate performances.

<DT><A HREF="http://www.evolus.vn/Pencil/Home.html" ADD_DATE="1215483935" PRIVATE="0" TOREAD="0" TAGS="sketching,gui,design">Home - Pencil Project</A>
<DD>Cool tool for sketching UIs, written in XUL, runs in Firefox 3 or outside.

<DT><A HREF="http://trinixy.ru/michael_kenna.html" ADD_DATE="1213933194" PRIVATE="0" TOREAD="0" TAGS="photography,photographer,pictures">Silent World by Michael Kenna</A>
<DD>Wonderful collection of BW pictures, snow, chimneys, smoke and trees

<DT><A HREF="http://www.youtube.com/watch?v=-F-3E8pyjFo&feature=PlayList&p=6D9B701069B4F2F4&index=14" ADD_DATE="1213814432" PRIVATE="0" TOREAD="0" TAGS="video,poisonous,fitzpatrick,google">YouTube - Google I/O 2008 - Open Source Projects and Poisonous People</A>
<DD>Poisonous people are usually passing the interview process and they are difficult to spot. I think I've been poisonous at least a couple of time. This video helps you understand how to be more pragmatic and less poisonous..

<DT><A HREF="http://www.infoq.com/interviews/bryant-ruby-maglev-gemstone" ADD_DATE="1213449800" PRIVATE="0" TOREAD="0" TAGS="ruby,video,interview">InfoQ: Avi Bryant on MagLev and GemStone</A>
<DD>Avi talking about MagLev before RailsConf. Interesting the point on the flawed interoperability between VMs in Smalltalk which is not the case in Ruby which is file system based.

<DT><A HREF="http://www.podipodi.com/" ADD_DATE="1213382390" PRIVATE="0" TOREAD="0" TAGS="cool,quicksilver,enso,dhtml">PodiPodi - The magical box - Enhance your website with PodiPodi box for your visitors!</A>
<DD>Quicksilver as DHTML on a web page, lets you apply commands to the hosting page

<DT><A HREF="http://jakescruggs.blogspot.com/2008/06/breadcrumbs-are-evil.html" ADD_DATE="1213364532" PRIVATE="0" TOREAD="0" TAGS="usability,design,web">Jake Scruggs: Breadcrumbs are Evil</A>
<DD>re breadcrumbs necessary in all situation? When breadcrumbs are instead just fixing a poorly designed web site?

<DT><A HREF="http://www.brightcove.tv/title.jsp?title=1416866797" ADD_DATE="1212864530" PRIVATE="0" TOREAD="0" TAGS="software,design,process,vision,management">&quot;An Insurgency of Quality&quot; Saturday iXDA Keynote with Alan Cooper</A>
<DD>Best talk about software as craftsmanship so far.

<DT><A HREF="http://www.paulgraham.com/distraction.html" ADD_DATE="1212681288" PRIVATE="0" TOREAD="0" TAGS="procrastination,productivity,blogs">Disconnecting Distraction</A>
<DD>Enjoyable reading of Paul Graham on procrastination and the effect of being constantly &quot;on-line&quot;. Don't miss the comments too.

<DT><A HREF="http://www.brynary.com/uploads/Story_Driven_Development.pdf" ADD_DATE="1212550549" PRIVATE="0" TOREAD="0" TAGS="slides,pdf,bdd,ruby,filetype:pdf,media:document">http://www.brynary.com/uploads/Story_Driven_Development.pdf</A>
<DD>Slides from the presentation Story Driven Development from GoRuCo 2008 by Bryan Helmkamp
</DL></p>
